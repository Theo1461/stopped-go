<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stopped Go 2.0</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(to bottom right, #dce1e9, #f2f4f7);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #app {
      transform: scale(0.67);
      transform-origin: center center;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    canvas {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      backdrop-filter: blur(20px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
      border: none;
    }

    #controls {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 20px;
    }

    #controls button,
    #info,
    #vxDisplay,
    #passengerCount,
    #speedDistance,
    #stopNotice,
    #pointsDisplay,
    #stopHistoryDisplay {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      border-radius: 16px;
      backdrop-filter: blur(18px);
      background: rgba(255, 255, 255, 0.2);
      color: #222;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      padding: 10px 14px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      user-select: none;
    }

    #speedDistance,
    #pointsDisplay,
    #stopNotice {
      background: rgba(255, 255, 255, 0.25);
      color: #000;
      font-weight: 600;
    }

    #info {
      font-size: 14px;
      color: #333;
      background: rgba(255,255,255,0.2);
    }

    button {
      cursor: pointer;
      transition: all 0.25s ease;
      border: none;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.35);
      transform: scale(1.05);
    }

    #controls button {
      font-size: 15px;
      font-weight: 600;
      padding: 10px 16px;
      color: #111;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(15px);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
      text-align: center;
      min-width: 180px;
    }

    #controls button:active {
      transform: scale(0.97);
      background: rgba(255, 255, 255, 0.3);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1) inset;
    }

    #stopHistoryDisplay {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 16px;
      font-family: 'Segoe UI', sans-serif;
      color: #111;
      font-size: 14px;
      line-height: 1.0;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      margin-top: 20px;
    }

    #minimap {
      backdrop-filter: blur(12px);
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.4);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

  #busRoutePanelWrapper {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10000;
    user-select: none;
    font-family: monospace;
    color: white;
  }

  #busRoutePanelToggle {
    background: #444;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
  }

  #busRoutePanel {
    margin-top: 8px;
    background: #222;
    padding: 12px 16px;
    border-radius: 8px;
    width: 220px;
    box-shadow: 0 0 10px #0008;
  }

  #busRoutePanel label {
    display: block;
    margin-top: 10px;
    margin-bottom: 4px;
    font-weight: bold;
  }

  #busRoutePanel input[type="text"] {
    font-size: 1.4em;
    width: 100%;
    padding: 6px;
    border-radius: 4px;
    border: none;
    background: #333;
    color: white;
    text-align: center;
    letter-spacing: 3px;
  }

  #busRoutePanel input[type="checkbox"] {
    transform: scale(1.3);
    margin-right: 8px;
    vertical-align: middle;
  }

  #busRoutePanel .color-slider {
    width: 100%;
  }

  #routePreviewWrapper {
    position: fixed;
    top: 60px; /* below toggle & panel */
    z-index: 10001;
    font-size: 2em;
    font-weight: bold;
    font-family: monospace;
    user-select: none;
    padding: 10px 16px;
    background: #d8d5d511;
    border-radius: 10px;
    min-width: 90px;
    text-align: center;
    color: rgba(255, 255, 255, 0.358);
  }

  #translationText {
    font-size: 1.1em;
    margin-top: 6px;
    text-align: center;
    font-style: italic;
    color: #0a7;
  }
    #gradientPopup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #gradientPopup.show {
      display: flex;
    }

    #gradientContent {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      padding: 30px 40px;
      color: white;
      text-align: center;
      backdrop-filter: blur(20px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    #gradientContent h3 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 20px;
      color: #fff;
    }

    #gradientContent button {
      margin-top: 10px;
      padding: 8px 14px;
      border-radius: 10px;
      border: none;
      background: rgba(255,255,255,0.25);
      cursor: pointer;
      font-weight: bold;
      color: white;
      transition: 0.25s;
    }

    #gradientContent button:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.05);
    }
#controls {
  position: fixed;       /* fix position on screen */
  top: 60px;             /* some space from top */
  left: -400px;            /* some space from left */
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 16px;
  width: 350px;          /* fixed width */
  padding: 10px 16px;
  background: rgba(255, 255, 255, 0.12);
  border-radius: 20px;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.1);
  z-index: 10000;        /* above other content */
  max-height: 150vh;  /* so it doesn’t overflow vertically */
  overflow-y: auto;      /* scroll if content is too tall */
}


#controls > div,
#controls > pre {
  width: 150px;
  padding: 10px 14px;
  background: rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: inset 0 1px 5px rgba(255,255,255,0.3);
  color: #222;
  font-weight: 600;
  font-size: 15px;
  user-select: none;
  line-height: 1.3;
}

#pointsDisplay,
#speedDistance {
  background: rgba(255, 255, 255, 0.25);
  color: #111;
  font-weight: 700;
  font-size: 17px;
  line-height: 1.4;
}

#info {
  background: rgba(255, 255, 255, 0.15);
  font-weight: 500;
  font-size: 14px;
  color: #333;
  user-select: text;
}

#vxDisplay {
  display: none; /* keep hidden unless needed */
}

button {
  width: 100px;
  padding: 12px 0;
  border-radius: 14px;
  font-weight: 600;
  font-size: 16px;
  background: rgba(255, 255, 255, 0.3);
  color: #222;
  border: none;
  cursor: pointer;
  box-shadow: 0 5px 12px rgba(0, 0, 0, 0.1);
  transition: background 0.3s ease, transform 0.2s ease;
}

button:hover {
  background: rgba(255, 255, 255, 0.45);
  transform: scale(1.04);
}

button:active {
  transform: scale(0.97);
  background: rgba(255, 255, 255, 0.35);
}

#stopHistoryDisplay {
  position: fixed;       /* fix position on screen */
  top: 60px;             /* some space from top */
  right: -400px;            /* some space from left */
  max-height: 220px;
  overflow-y: auto;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  background: rgba(255, 255, 255, 0.1);
  color: #222;
  padding: 14px;
  border-radius: 14px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
  white-space: pre-wrap;
  line-height: 1.25;
}
#quickKeyboard {
  position: fixed;
  bottom: -70px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 9999;
  padding: 14px 20px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(15px);
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

#quickKeyboard button {
  font-size: 15px;
  font-weight: 600;
  padding: 10px 16px;
  color: #111;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(15px);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
  text-align: center;
  min-width: 60px;
}
.row {
  margin-top: 8px;
}
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <div id="fpsCounter">FPS: 0</div>
      <div id="pointsDisplay">Points: 0</div>
      <div id="speedDistance">Distance: 0 px<br>Speed: 0 px/s</div>
      <div id="vxDisplay" style="display: none">vx: 0</div>

      <button id="openGradientMenu">Customize Menu</button>
      <button onclick="showStopHistory()">View Stop History</button>

      <div style="display: none"id="info">Press 1, 2, or 3 to switch buses. Current: Gillig 29'</div>
      <canvas id="minimap" width="300" height="100"></canvas>
    </div>

    <div id="gradientPopup">
      <div id="gradientContent">
        <h3>Gradient Settings</h3>
        <label>
          Start Color:
          <input type="color" id="startColorPicker" value="#d3d3d3" />
        </label>
        <br /><br />
        <label>
          End Color:
          <input type="color" id="endColorPicker" value="#d3d3d3" />
        </label>
        <br /><br />
        <button onclick="exportGradient()">Export Gradient</button>
        <input type="file" id="importGradientFile" style="display:none" accept=".sg,.json" />
        <button onclick="document.getElementById('importGradientFile').click()">Import Gradient</button>
        <br /><br />
        <button id="closeGradientMenu">Close</button>
      </div>
    </div>

    <canvas id="busCanvas" width="800" height="600"></canvas>
          <pre id="stopHistoryDisplay"></pre>
          <div id="lateness-info" style="
  position: fixed;
  top: -90px; right: 10px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px 12px;
  font-family: monospace;
  font-size: 14px;
  border-radius: 8px;
  z-index: 1000;
  white-space: pre-line;
  pointer-events: none;
  user-select: none;
"></div>

<div id="quickKeyboard">
  <button data-key="1">1</button>
  <button data-key="2">2</button>
  <button data-key="3">3</button>
  <button data-key="ArrowRight">→</button>
  <button data-key="b">Brake</button>
  <button data-key="l">Kneel</button>

  <br>

  <button data-key="s">Light</button>
  <button data-key="n">Night</button>
  <button data-key="t">Test</button>
</div>

<pre id="lateness-info" style="white-space: pre-wrap; font-family: monospace;"></pre>

<div id="busRoutePanelWrapper">
  <button id="busRoutePanelToggle" aria-expanded="false" aria-controls="busRoutePanel" title="Toggle Bus Route Editor Panel">► Route Editor</button>
  <div id="busRoutePanel" hidden>
    <label for="routeNumber">Bus Route Number (0-999):</label>
    <input type="text" id="routeNumber" maxlength="3" pattern="\d*" inputmode="numeric" placeholder="Enter number" />

    <label>
      <input type="checkbox" id="translationCheck" />
      Translation (101-126 → A-Z)
    </label>

    <label for="rSlider">Red</label>
    <input type="range" id="rSlider" min="0" max="255" value="255" class="color-slider" />
    <label for="gSlider">Green</label>
    <input type="range" id="gSlider" min="0" max="255" value="255" class="color-slider" />
    <label for="bSlider">Blue</label>
    <input type="range" id="bSlider" min="0" max="255" value="255" class="color-slider" />

    <div id="translationText"></div>
  </div>
</div>

<div id="routePreviewWrapper">
  <div id="routePreview">---</div>
</div>

<div style="position: fixed; right: 0; top: 20px; background: #222; color: white; padding: 10px; font-family: monospace; width: 240px; z-index: 1000;">
  <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 8px;">
    <button id="leftArrow" style="font-size: 1.5em;">(-</button>
    <div id="bitDisplay" style="display: flex; gap: 5px; margin: 0 10px;">
      <!-- bits go here -->
    </div>
    <button id="rightArrow" style="font-size: 1.5em;">-)</button>
  </div>
  <button id="executeBtn" style="width: 100%; font-size: 1.2em;">Execute</button>
  <div id="status" style="margin-top: 10px; font-size: 0.9em;"></div>
</div>

  </div>

  <script>

  const keys = {};
  let fps = 0;
  let articulated = false
let lastFrameTime = performance.now();
let frames = 0;
let lastFpsUpdate = performance.now();
let debugMode = false;

  let accelerating = false;
  let braking = false;
  let friction = 0.9999;
 window.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (keys[key]) return;
    keys[key] = true;

    handleKeyPress(key);
  });

  window.addEventListener('keyup', e => {
    const key = e.key.toLowerCase();
    keys[key] = false;
  });
let spotlightOn = false
let night = true;  // toggle this to switch modes
  function handleKeyPress(key) {
    if (key === 'arrowright') {
      accelerating = !accelerating;
      braking = false;
      friction = 0.999;
      console.log('Accelerating:', accelerating);
    }

    if (key === 'b') {
      braking = true;
      console.log('Braking:', braking);
    }
    if (key === 't') {
      debugMode = !debugMode
    }
      if (key === 'n') {
      night = !night
    }
        if (key === 's') {
      if (night) {
        spotlightOn = !spotlightOn
      }
    }
  }
function simulateKeyPress(key) {
  // Create and dispatch a real keyboard event for the key
  const event = new KeyboardEvent('keydown', { key: key, bubbles: true });
  window.dispatchEvent(event);

  // Also dispatch keyup shortly after to mimic real press-release
  setTimeout(() => {
    const eventUp = new KeyboardEvent('keyup', { key: key, bubbles: true });
    window.dispatchEvent(eventUp);
  }, 100);
}

// Existing keys state and logic...

document.querySelectorAll('#quickKeyboard button').forEach(button => {
  button.addEventListener('click', () => {
    const key = button.getAttribute('data-key').toLowerCase();

    // For numbers and 'l', simulate real keypress event
    if (key === '1' || key === '2' || key === '3' || key === 'l') {
      simulateKeyPress(key);
    } else {
      // For other keys, use previous logic:
      if (keys[key]) return;
      keys[key] = true;

      handleKeyPress(key);

      setTimeout(() => {
        keys[key] = false;
      }, 100);
    }
  });
});
const fpsDiv = document.getElementById('fpsCounter');

function gameLoop(timestamp) {
  const delta = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  frames++;

  if (timestamp - lastFpsUpdate >= 500) {
    fps = Math.round((frames * 1000) / (timestamp - lastFpsUpdate));
    frames = 0;
    lastFpsUpdate = timestamp;
    if (fpsDiv) fpsDiv.textContent = `FPS: ${fps}`;
  }
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

  // === Simulate virtual keypress from quick keyboard buttons ===
  document.querySelectorAll('#quickKeyboard button').forEach(button => {
    button.addEventListener('click', () => {
      const key = button.getAttribute('data-key').toLowerCase();
      if (keys[key]) return;
      keys[key] = true;

      handleKeyPress(key);

      setTimeout(() => {
        keys[key] = false;
      }, 100);
    });
  });

    // Basic toggle popup logic (feel free to extend)
    const popup = document.getElementById('gradientPopup');
    document.getElementById('openGradientMenu').onclick = () => popup.classList.add('show');
    document.getElementById('closeGradientMenu').onclick = () => popup.classList.remove('show');
  const gradientPopup = document.getElementById("gradientPopup");
  const openBtn = document.getElementById("openGradientMenu");
  const closeBtn = document.getElementById("closeGradientMenu");

  openBtn.onclick = () => gradientPopup.classList.add("show");
  closeBtn.onclick = () => gradientPopup.classList.remove("show");

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 't') {
    debugMode = !debugMode;
    console.log(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
  }
});

  // Optional: Close on background click
  gradientPopup.onclick = (e) => {
    if (e.target === gradientPopup) {
      gradientPopup.classList.remove("show");
    }
  };
let acceleration = 0.1;      // Acceleration rate
const almostOne = 1 - 1e-222     // Max speed
const bridges = [];
let camFollowX = 0;          // Camera follow target x
let delayTimer = 0;          // For 2s delay
let distance2 = 0;
const lightCount = 5;

// Only regenerate when the center light needs to shift
let lastCenterIndex = null;

  const canvas = document.getElementById('busCanvas');
  const info = document.getElementById('info');
  const ctx = canvas.getContext('2d');
const lightColors = {
  0: "#00ff00", // green
  1: "#ffff00", // yellow
  2: "#ff0000", // red
};

let sharedTimer = 0;
let sharedState = 2; // Start on red


let violationMessageTimer = 0;
// Generate bridges with dark brown columns
const bridgePositions = [500]; // Required first bridge
while (bridgePositions.length < 10) {
  const next = bridgePositions[bridgePositions.length - 1] + Math.floor(10000 + Math.random() * 3000);
  bridgePositions.push(next);
}

for (const x of bridgePositions) {
  bridges.push({ x });
}

function update(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const delta = (timestamp - lastTimestamp) / 1000; // seconds elapsed since last frame

  // Distance traveled increment (assuming vx is px per second)
  distance2 += Math.abs(vx * delta);


  // Update the display text, multiply by 2
  const speedDisplay = document.getElementById('speedDistance');
  speedDisplay.innerHTML = `Distance: ${(distance2 * 2).toFixed(0)} px<br>Speed: ${(vx * 2).toFixed(0)} px/s`;

  lastTimestamp = timestamp;
  requestAnimationFrame(update);
  
}

requestAnimationFrame(update);


window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();

  if (keys[key]) return; // Ignore repeat until released
  keys[key] = true;

  if (key === 'arrowright') {
    accelerating = !accelerating; // Toggle acceleration
    console.log('Accelerating:', accelerating);
    braking = false
    friction = 0.9993
  }

  if (key === 'b') {
    braking = true
    console.log('Braking:', braking);
  }
});

window.addEventListener('keyup', e => {
  const key = e.key.toLowerCase();
  keys[key] = false; // Allow toggling again on next key press
});

let audioCtxA = new (window.AudioContext || window.webkitAudioContext)();
let idleGain, jitterGain, driveGain, driveNoiseSource;
let currentState = "idle";

let currentSystem = "D";
let audioAStarted = false, audioBStarted = false;
let vx = 0;
const maxSpeed = 120;
let violationOccurred = false;
// === Ensure AudioContext ===
// === Engine Tone Buffer ===
function createEngineToneBuffer(freq = 60, duration = 2, volume = 0.2) {
  const buffer = audioCtxA.createBuffer(1, duration * audioCtxA.sampleRate, audioCtxA.sampleRate);
  const data = buffer.getChannelData(0);
  const sampleRate = audioCtxA.sampleRate;
  for (let i = 0; i < data.length; i++) {
    data[i] = Math.sin(5)
  }
  return buffer;
}

// === Source with Gain ===
function createLoopingSource(buffer, gainValue = 0.5) {
  const source = audioCtxA.createBufferSource();
  source.buffer = buffer;
  source.loop = true;

  const gain = audioCtxA.createGain();
  gain.gain.value = gainValue;

  source.connect(gain).connect(audioCtxA.destination);
  return { source, gain };
}
const keysDown = new Set();
// === Start Audio A ===
let trainApproaching = false
const MAX_INT_32 = 2147483647;
let trainTrafficLights = [];
let trainFlashTimer = 0;
let trainFlashOn = true;
// === Update Audio Based on Speed ===
let jitterOscillator = null;
let jitterLFOGain = null;
let jitterOscActive = false;
function step() {
  if (currentSystem === "A") {
    updateAudioSystemA(vx);
  } else if (currentSystem === "C") {
    if (!articulated) {
    updateAudioSystemC(vx)
    } else {
      updateArticulatedAudio(vx)
    }
  }
}
step()
// === Audio Context ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// === Global Variables ===
let idleNoise, driveNoise, jitterNoise;
let idleSource, jitterSource

let idleOsc, jitterOsc, driveOsc;
let idleOscGain, jitterOscGain, driveOscGain;


// === Create White Noise Buffer ===
function createNoiseBuffer(duration = 2, volume = 0.5) {
  const sampleRate = audioCtx.sampleRate;
  const bufferSize = sampleRate * duration;
  const buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * volume; // White noise between -volume and +volume
  }
  return buffer;
}

// === Create Noise Source (BufferSource + Gain) ===
function createNoiseSource(buffer, gainValue = 0.5) {
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;

  const gain = audioCtx.createGain();
  gain.gain.value = gainValue;

  source.connect(gain).connect(audioCtx.destination);
  return { source, gain };
}

// === Create Raw Oscillator + Gain Node ===
function createOscillator(type = 'sine', freq = 60, gainVal = 0.2) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.value = gainVal;

  osc.connect(gain).connect(audioCtx.destination);
  osc.start();

  return { osc, gain };
}

// === Start Audio System A ===
function startAudioA() {
  // Create white noise buffers
  idleNoise = createNoiseBuffer(0.3, 0.3);
  jitterNoise = createNoiseBuffer(0.4, 0.8);
  driveNoise = createNoiseBuffer(2, 0.4);

  // Create looping noise sources
  const idle = createNoiseSource(idleNoise, 0.1);
  const jitter = createNoiseSource(jitterNoise, 0.0);

  // Raw oscillators for tonal layers
  const idleTone = createOscillator('sine', 55, 0.08);     // low hum
  const jitterTone = createOscillator('triangle', 90, 0.0); // subtle flicker (start muted)
  const driveTone = createOscillator('square', 200, 0.0);   // engine buzz (start muted)

  idleOsc = idleTone.osc;
  idleOscGain = idleTone.gain;

  jitterOsc = jitterTone.osc;
  jitterOscGain = jitterTone.gain;

  driveOsc = driveTone.osc;
  driveOscGain = driveTone.gain;

  // Drive noise source with effects
  driveNoiseSource = audioCtx.createBufferSource();
  driveNoiseSource.buffer = driveNoise;
  driveNoiseSource.loop = true;

  driveGain = audioCtx.createGain();
  driveGain.gain.value = 0.0;

  const filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 185;
  filter.Q.value = 6;

  const delay = audioCtx.createDelay();
  delay.delayTime.value = 0.045;

  const feedback = audioCtx.createGain();
  feedback.gain.value = 0.8;

  delay.connect(feedback);
  feedback.connect(delay);

  driveNoiseSource.connect(filter);
  filter.connect(delay);
  delay.connect(driveGain);
  filter.connect(driveGain);
  driveGain.connect(audioCtx.destination);

  // Start noise sources
  idle.source = idle.source || idle.source;
  jitter.source = jitter.source || jitter.source;
  idle.source.start();
  jitter.source.start();
  driveNoiseSource.start();

  idleGain = idle.gain;
  jitterGain = jitter.gain;

  currentState = "idle";

  // Initial gain values
  idleGain.gain.value = 0.3;
  idleOscGain.gain.value = 0.08;
}

// === Update Audio System A ===
function updateAudioSystemA() {
  const VX = vx;
  const speedNorm = Math.min(Math.abs(VX) / maxSpeed, 1);

  // Idle state
  if (VX < 0.5 && currentState !== "idle") {
    currentState = "idle";

    idleGain.gain.setTargetAtTime(0.25, audioCtx.currentTime, 0.3);
    idleOscGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.3);

    driveGain.gain.setTargetAtTime(0.005, audioCtx.currentTime, 0.3);
    driveOscGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.3);

    jitterGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.1);
    jitterOscGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.1);
  }

  // Jitter state (low speed)
  else if (VX >= 0.2 && VX < 2) {
    if (currentState !== "jitter") {
      currentState = "jitter";

      idleGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.2);
      idleOscGain.gain.setTargetAtTime(0.02, audioCtx.currentTime, 0.2);

      driveGain.gain.setTargetAtTime(0.01, audioCtx.currentTime, 0.3);
      driveOscGain.gain.setTargetAtTime(0.05, audioCtx.currentTime, 0.3);

      jitterGain.gain.setTargetAtTime(0.3, audioCtx.currentTime, 0.2);
      jitterOscGain.gain.setTargetAtTime(0.2, audioCtx.currentTime, 0.2);
    }
  }

  // Drive state (higher speed)
  else if (VX >= 2) {
    if (currentState !== "drive") {
      currentState = "drive";

      idleGain.gain.setTargetAtTime(0.23, audioCtx.currentTime, 0.9);
      idleOscGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.5);

      jitterGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.3);
      jitterOscGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.3);
    }

    const gain = 0.1 + 0.3 * speedNorm;
    driveGain.gain.setTargetAtTime(gain, audioCtx.currentTime, 0.15);

    const oscGain = 0.15 + 0.35 * speedNorm;
    driveOscGain.gain.setTargetAtTime(oscGain, audioCtx.currentTime, 0.15);

    const rate = 1.0 + 0.6 * speedNorm;
    driveNoiseSource.playbackRate.setTargetAtTime(rate, audioCtx.currentTime, 0.15);
  }

  // Cap max speed
  if (VX >= 12) {
    vx = 12;
    driveGain.gain.setTargetAtTime(0.35, audioCtx.currentTime, 0.1);
    driveOscGain.gain.setTargetAtTime(0.5, audioCtx.currentTime, 0.1);
  }
}

let flashAlpha = 0;
let flashTimer = 0;

    // ---------------- SYSTEM B ---------------- //
    let cruiseGainLevel = 0.005;
    const ctxB = new (window.AudioContext || window.webkitAudioContext)();
    let engineOsc, engineGain, filter, delay, delayGain;
    let noiseGain, whiteNoise, vibrationOsc, vibrationGain;
    let cruiseToneOsc, cruiseToneOscGain;
    let idleLFO = null, idleLFOGain = null;
    let frequency = 160, gainLevel = 0.1;
    let vxTimer = 0, lastAccelTime = 0;
    let cruising = false;
    const FREQ_MIN = 160, FREQ_MAX = 800;
    const GAIN_MIN = 0.1, GAIN_MAX = 0.5;
    const vxDisplay = document.getElementById('vxDisplay');
    const accelBtn = document.getElementById('accelBtn');

function createWhiteNoiseB() {
  const buffer = ctxB.createBuffer(1, ctxB.sampleRate * 2, ctxB.sampleRate);
  const data = buffer.getChannelData(0);

  // Generate slightly smoother noise (low-frequency emphasis)
  let lastValue = 0;
  for (let i = 0; i < data.length; i++) {
    // Apply slight smoothing between samples for wind-like texture
    const rand = Math.random() * 2 - 1;
    data[i] = (lastValue + rand * 0.05) / 1.25; // smooth blend
    lastValue = data[i];
  }

  const source = ctxB.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  return source;
}


function initAudioB() {
  engineOsc = ctxB.createOscillator();
  engineOsc.type = 'triangle';
  engineOsc.frequency.value = 0.1;

  engineGain = ctxB.createGain();
  engineGain.gain.value = 0.8;

  filter = ctxB.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 10;
  filter.Q.value = 1.5;

  delay = ctxB.createDelay();
  delay.delayTime.value = 0.00005;

  delayGain = ctxB.createGain();
  delayGain.gain.value = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001;

  whiteNoise = createWhiteNoiseB();
  noiseGain = ctxB.createGain();
  noiseGain.gain.value = 0.2;

  vibrationOsc = ctxB.createOscillator();
  vibrationOsc.frequency.value = 1;
  vibrationGain = ctxB.createGain();
  vibrationGain.gain.value = 0.8;

  cruiseToneOsc = ctxB.createOscillator();
  cruiseToneOsc.type = 'sine';
  cruiseToneOsc.frequency.value = 900;

  cruiseToneOscGain = ctxB.createGain();
  cruiseToneOscGain.gain.value = 0.005; // <-- Always audible alongside engine

  // Routing
  whiteNoise.connect(noiseGain).connect(ctxB.destination);
  delay.connect(delayGain).connect(delay);
  vibrationOsc.connect(vibrationGain).connect(engineOsc.frequency);
  engineOsc.connect(filter).connect(engineGain).connect(delay).connect(ctxB.destination);
  engineGain.connect(ctxB.destination);
cruiseToneOsc.connect(cruiseToneOscGain).connect(ctxB.destination);


  vibrationOsc.start();
  engineOsc.start();
  cruiseToneOsc.start();
  whiteNoise.start();
}


    function updateEngineB() {
      cruiseToneOsc.frequency.setTargetAtTime(cfrequency, ctxB.currentTime, 0.15);
      cruiseToneOscGain.gain.setTargetAtTime(cruiseGainLevel, ctxB.currentTime, 0.15);
      engineOsc.frequency.setTargetAtTime(frequency, ctxB.currentTime, 0.2);
      engineGain.gain.setTargetAtTime(gainLevel, ctxB.currentTime, 0.15);
      filter.frequency.setTargetAtTime(120 + (frequency - FREQ_MIN) * 0.8, ctxB.currentTime, 0.15);

    }
    let cfrequency = 900; // Cruise tone base frequency
let speedTimer = 0
    function simulationStepB() {
      const now = performance.now();
      if (accelerating) {
        if (lastAccelTime === 0 || now - lastAccelTime > 500) {
          speedTimer = 0;
          
        }
        lastAccelTime = now;
        speedTimer += 1 / 60;

        if (speedTimer < 13) {
          frequency += 0.25;
          cfrequency += 1;
          acceleration = 0.1
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 13.5) {
          frequency -= 4;
          cfrequency += 4;
          gainLevel -= 0.000000000000000000000000001;
        } else if (speedTimer < 17.5) {
          frequency += 0.2;
          cfrequency += 1;
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 18.51 && gainLevel >= 0.04) {
          gainLevel = 0.00001
          cfrequency = 900
          delay.delayTime.value = 0.0000000000000000000001;
        }
      } else {
        if (now - lastAccelTime > 500) {
          speedTimer = 0;
          cruising = false;
          vibrationOffTime = null;
        }
        frequency -= 1.5;
        gainLevel -= 0.001;
      }
      if (!accelerating) {
        speedTimer = 0
      }
      if (vx >= 20) {
        vx = 20
      }
      if (vx === 0) {
        cfrequency = 900
      }
      if (braking) {
        frequency -= 3;
        gainLevel -= 0.1;
        cfrequency -= 10;
        if (cfrequency <= 0) {
          cfrequency = 0
          cruiseGainLevel = 0.005
        }
        cruiseGainLevel += 0.00001
        speedTimer = 0
        cruising = false;
        vibrationOffTime = null;
      }

      frequency = Math.max(FREQ_MIN, Math.min(frequency, FREQ_MAX));
      gainLevel = Math.max(GAIN_MIN, Math.min(gainLevel, GAIN_MAX));
      updateEngineB();

      requestAnimationFrame(simulationStepB);
    }

let electricOsc, electricGain, dieselNoise, dieselGain, lowpass;
const audioCtxC = new (window.AudioContext || window.webkitAudioContext)();
let audioCStarted = false;

// Track when electric started playing to stop after 5 seconds
let electricStartTime = null;

function startAudioC() {
  if (audioCStarted) return;
  audioCStarted = true;

  electricOsc = audioCtxC.createOscillator();
  electricGain = audioCtxC.createGain();
  electricOsc.type = "square";
  electricOsc.frequency.value = 100;
  electricGain.gain.value = 0.0; // start silent
  electricOsc.connect(electricGain).connect(audioCtxC.destination);

  const bufferSize = 2 * audioCtxC.sampleRate;
  const buffer = audioCtxC.createBuffer(1, bufferSize, audioCtxC.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

  dieselNoise = audioCtxC.createBufferSource();
  dieselNoise.buffer = buffer;
  dieselNoise.loop = true;

  dieselGain = audioCtxC.createGain();
  dieselGain.gain.value = 0.0;

  lowpass = audioCtxC.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 10;

  dieselNoise.connect(lowpass).connect(dieselGain).connect(audioCtxC.destination);

  electricOsc.start();
  dieselNoise.start();

  electricStartTime = audioCtxC.currentTime;
}
let articulatedNodes = {};
let articulatedStarted = false;
let vibratoLFO = null;
let vibratoGain = null;
let vibratoActive = false;

function startArticulatedAudio() {
  if (articulatedStarted) return;
  articulatedStarted = true;

  // Oscillators for electric humming, harmonic layers
  const electricOsc = audioCtxC.createOscillator();
  const electricHarmOsc = audioCtxC.createOscillator();
  const electricGain = audioCtxC.createGain();
  const electricHarmGain = audioCtxC.createGain();

  electricOsc.type = "triangle";
  electricOsc.frequency.value = 30; // base freq lower than regular
  electricHarmOsc.type = "triangle";
  electricHarmOsc.frequency.value = 120;

  electricGain.gain.value = 0;
  electricHarmGain.gain.value = 0;

  electricOsc.connect(electricGain).connect(audioCtxC.destination);
  electricHarmOsc.connect(electricHarmGain).connect(audioCtxC.destination);

  electricOsc.start();
  electricHarmOsc.start();

  // Squeak-like modulation for siren pulse
  const squeakLFO = audioCtxC.createOscillator();
  const squeakDepth = audioCtxC.createGain();

  squeakLFO.frequency.value = 1.2; // ~1.2Hz pulse for siren in/out
  squeakDepth.gain.value = 0;

  squeakLFO.connect(squeakDepth).connect(electricHarmGain.gain);
  squeakLFO.start();

  // Diesel noise layer setup
  const bufferSize = 2 * audioCtxC.sampleRate;
  const noiseBuffer = audioCtxC.createBuffer(1, bufferSize, audioCtxC.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.12;
  }

  const dieselNoise = audioCtxC.createBufferSource();
  dieselNoise.buffer = noiseBuffer;
  dieselNoise.loop = true;

  const dieselGain = audioCtxC.createGain();
  dieselGain.gain.value = 0;

  const lowpass = audioCtxC.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 500;

  dieselNoise.connect(lowpass).connect(dieselGain).connect(audioCtxC.destination);

  dieselNoise.start();
vibratoLFO = audioCtxC.createOscillator();
vibratoGain = audioCtxC.createGain();
vibratoLFO.frequency.value = 3;
vibratoGain.gain.value = 1.1;

vibratoLFO.connect(vibratoGain).connect(electricHarmOsc.frequency);
vibratoLFO.start();
vibratoActive = true;

  articulatedNodes = {
    electricOsc,
    electricGain,
    electricHarmOsc,
    electricHarmGain,
    squeakLFO,
    squeakDepth,
    dieselNoise,
    dieselGain,
    lowpass,
    vibratoLFO,
    vibratoGain
  };
}

function updateArticulatedAudio() {
  const maxSpeed = 25;
  if (vx > maxSpeed) vx = maxSpeed;
  const norm = vx / 30;

  if (vx === 0) {
    articulatedNodes.electricGain.gain.setTargetAtTime(0.05, audioCtxC.currentTime, 0.2);
    articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.06, audioCtxC.currentTime, 0.2);
    articulatedNodes.squeakDepth.gain.setTargetAtTime(0.0, audioCtxC.currentTime, 0.3);
    articulatedNodes.dieselGain.gain.setTargetAtTime(0.6, audioCtxC.currentTime, 0.1);
    return;
  }
  if (vx >= 20) {
    articulatedNodes.electricGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.2);
    articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.2);
    articulatedNodes.squeakDepth.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.3);
    articulatedNodes.dieselGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.1);
  }

  // Base electric frequencies increase with speed
  articulatedNodes.electricOsc.frequency.setTargetAtTime(55 + norm * 28, audioCtxC.currentTime, 0.2);
  articulatedNodes.electricHarmOsc.frequency.setTargetAtTime(145 + norm * 40, audioCtxC.currentTime, 0.2);

  // Gain dynamics, harmonic and fundamental
  articulatedNodes.electricGain.gain.setTargetAtTime(0.1 + norm * 0.08, audioCtxC.currentTime, 0.3);
  articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.1 + norm * 0.07, audioCtxC.currentTime, 0.3);

  // Squeak modulation pulses like siren coming in/out
  const squeakTarget = accelerating ? 0.12 : 0.06;
  articulatedNodes.squeakDepth.gain.setTargetAtTime(squeakTarget * norm, audioCtxC.currentTime, 0.4);

  // Diesel noise louder with speed, filter frequency changes on acceleration
  articulatedNodes.dieselGain.gain.setTargetAtTime(0.3 + norm * 0.5, audioCtxC.currentTime, 0.4);
  const baseFreq = accelerating ? 550 : 350;
  articulatedNodes.lowpass.frequency.setTargetAtTime(baseFreq + norm * 600, audioCtxC.currentTime, 0.5);
}

// Call this continuously (e.g. in animation frame loop)
function updateAudioSystemC() {
  const maxSpeed = 13.5;
  if (vx > maxSpeed) vx = maxSpeed;
  const speedNorm = vx / maxSpeed;

  if (vx === 0) {
    // Reset when idle
    electricOsc.frequency.setValueAtTime(100, audioCtxC.currentTime);
    electricGain.gain.setTargetAtTime(0.0, audioCtxC.currentTime, 0.1);

    dieselGain.gain.setTargetAtTime(6, audioCtxC.currentTime, 0.01);
    return;
  }

  // Electric motor frequency ramps with speed
  const electricFreq = 4 + speedNorm * 200;
  electricOsc.frequency.setTargetAtTime(electricFreq, audioCtxC.currentTime, 0.2);

  // Electric gain: slowly increase from 0 to 0.4 as vx goes from 0 to 2,
  // then hold at 0.4 while diesel fades in after vx > 2.
  let electricTargetGain = 0;
  if (vx <= 2) {
    electricTargetGain = 0.1 * (vx / 2);  // linear ramp 0 to 0.4
  } else {
    electricTargetGain = 0.1; // hold max electric gain once diesel starts
  }
  electricGain.gain.setTargetAtTime(electricTargetGain, audioCtxC.currentTime, 0.2);

  // Diesel gain: fade in starting from vx > 2 up to max at vx=12
  if (vx > 2) {
    const dieselNorm = (vx - 2) / (maxSpeed - 2);
    const dieselVol = 0.2 + 0.5 * dieselNorm;
    dieselGain.gain.setTargetAtTime(dieselVol, audioCtxC.currentTime, 0.3);

    // Adjust diesel tone based on acceleration
    const filterFreq = accelerating
      ? 200 + 1000 * dieselNorm  // Brighter when accelerating
      : 100 + 500 * dieselNorm; // Deeper when slowing
    lowpass.frequency.setTargetAtTime(filterFreq, audioCtxC.currentTime, 0.3);
  } else {
    dieselGain.gain.setTargetAtTime(5, audioCtxC.currentTime, 0.01);
  }
}
function updateTrafficLights(deltaTime) {
  trafficLights.forEach((light, index) => {
    const cycleTime = 3000;

    if (light.timer === undefined) {
      light.timer = (index * 1000) % cycleTime;
      if (light.timer < 1000) light.state = 0;
      else if (light.timer < 2000) light.state = 1;
      else light.state = 2;
    } else {
      light.timer += deltaTime;
    }

    switch (light.state) {
      case 0:
        if (light.timer >= 9000) {
          light.state = 1;
          light.timer = 0;
          console.log(`Light ${index} switched to YELLOW`);
        }
        break;
      case 1:
        if (light.timer >= 1000) {
          light.state = 2;
          light.timer = 0;
          console.log(`Light ${index} switched to RED`);
        }
        break;
      case 2:
        if (light.timer >= 10000) {
          light.state = 0;
          light.timer = 0;
          console.log(`Light ${index} switched to GREEN`);
        }
        break;
    }
  });
}


function animate2() {
  if (articulated) {
    updateArticulatedAudio()
  } else if (!articulated && audioCStarted) {
  updateAudioSystemC();
  } else if (audioAStarted) {
   updateAudioSystemA()
  }
  requestAnimationFrame(animate2);
}
animate2()
// --- Keyboard Controls ---
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (keysDown.has(key)) return; // Prevent repeat while held

  if (key === '3') {
    if (!audioBStarted) {
      initAudioB();
      simulationStepB();
      audioBStarted = true;
    }
    ctxB.resume();
    audioCtxA.suspend();
    audioCtxC.suspend?.();
    currentSystem = "B";
  } else if (key === '1') {
    if (!audioAStarted) {
      startAudioA();
      audioAStarted = true;
    }
    audioCtxA.resume();
    ctxB.suspend();
    audioCtxC.suspend?.();
    currentSystem = "A";
  } else if (key === '2') {
    if (!audioCStarted) {
      if (articulated) {
        startArticulatedAudio()
      } else {
      startAudioC();
    }}
    audioCtxC.resume();
    ctxB.suspend?.();
    audioCtxA.suspend();
    currentSystem = "C";
    animate2(); 
  }

  keysDown.add(key);
});

window.addEventListener('keyup', e => {
  keysDown.delete(e.key.toLowerCase());
});

// --- System Toggle Function ---
async function toggleSystems() {
  if (currentSystem === "A") {
    await audioCtxA.suspend();
  } else if (currentSystem === "B") {
    await ctxB.suspend();
  } else if (currentSystem === "C") {
    await audioCtxC.suspend?.();
  }

  systemIndex = (systemIndex + 1) % systemOrder.length;
  const nextSystem = systemOrder[systemIndex];

  if (nextSystem === "A") {
    if (!audioAStarted) {
      startAudioA();
    }
    await audioCtxA.resume();
  } else if (nextSystem === "B") {
    if (!audioBStarted) {
      initAudioB();
      simulationStepB();
      audioBStarted = true;
    }
    await ctxB.resume();
  } else if (nextSystem === "C") {
    if (!audioCStarted) {
      if (!articulated) {
      startAudioC();
      updateAudioSystemC()
    } else {
      startArticulatedAudio()
      updateArticulatedAudio()
    }}
    await audioCtxC.resume();
  }

  currentSystem = nextSystem;
}
let trafficLights = [];
const trafficLightSpacing = 20000;
const firstLightX = 1000;
const lightRadius = 12;

// --- Global Variables ---
const STOP_INTERVAL = 1250;
const STOP_SPAWN_LIMIT = 5000000;
const STOP_RADIUS = 20;
const STOP_DETECTION_RANGE = 500;
const STOP_COUNTER_TRIGGER = 1000;

let stops = [];
let passengersOnBoard = 0;
let nextStopRequest = null;
let pendingDropRequest = false;
let collectedDisplay = null;
let collectedDisplayTimeout = null;
let camX = 0;
// --- Call this ONCE on game start/reset ---
let showNotice = false;
let distance = 3000; // define outside loop

const STOP_SPACING_OPTIONS = [1250, 2500, 2500];

function generateStops() {
  stops = [];
  let x = -10000;

  while (x <= STOP_SPAWN_LIMIT) {
    // Create primary stop
    const stop = {
      x,
      collected: false,
      regenTime: 0,
      special: Math.random() < 0.2,
      playerOnly: Math.random() < 0.05,
    };
    stops.push(stop);

    // 20% chance of double stop placed 100px after the current stop
    if (Math.random() < 0.2) {
      const doubleStop = {
        x: x + 500,
        collected: false,
        regenTime: 0,
        special: Math.random() < 0.2,
        playerOnly: Math.random() < 0.05,
      };
      stops.push(doubleStop);
    }

    // Advance x by a random spacing
    const spacing = STOP_SPACING_OPTIONS[Math.floor(Math.random() * STOP_SPACING_OPTIONS.length)];
    x += spacing;
  }
}
generateStops()
  let currentBusIndex = 0;

let startAudioCalled = false;
let amount = 0


  const tilt = 0;
  function drawMinimap(bus, camX) {
  const minimap = document.getElementById('minimap');
  const ctx = minimap.getContext('2d');
  const w = minimap.width;
  const h = minimap.height;

  ctx.clearRect(0, 0, w, h);

  const RANGE = 20000; // Show ±10,000px from bus
  const startX = bus.x - RANGE / 2;
  const endX = bus.x + RANGE / 2;

  // Background
  ctx.fillStyle = "#ddd";
  ctx.fillRect(0, h / 3, w, h / 3);

  // Only draw stops within the visible window
for (const stop of stops) {
  if (stop.x >= startX && stop.x <= endX) {
    const percent = (stop.x - startX) / RANGE;
    const x = percent * w;
    const y = h / 2; // Define y properly
    const color = stop.special ? "#777" : "#007bff";

    // Main stop circle
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI * 2);
    ctx.fillStyle = stop.collected ? "#ccc" : color;
    ctx.fill();

    // Player-only cyan indicator
    if (stop.playerOnly) {
      ctx.beginPath();
      ctx.arc(x, y, 2.75, 0, Math.PI * 2); // use `y` here
      ctx.fillStyle = "cyan";
      ctx.fill();
    }
  }
}

  // Draw the bus at center of minimap
  const busX = (bus.x - startX) / RANGE * w;
  ctx.beginPath();
  ctx.arc(busX, h / 2, 5, 0, Math.PI * 2);
  ctx.fillStyle = "#ff0000";
  ctx.fill();
    for (const aiBus of aiBuses) {
    if (aiBus.x >= startX && aiBus.x <= endX) {
      const percent = (aiBus.x - startX) / RANGE;
      const x = percent * w;
      ctx.beginPath();
      ctx.arc(x, h / 2 - 10, 5, 0, Math.PI * 2); // Slightly above center line
      ctx.fillStyle = "#0000ff";
      ctx.fill();
    }
  }
// === Draw Train Traffic Lights on Minimap ===
for (const light of trainTrafficLights) {
  if (light.x >= startX && light.x <= endX) {
    const percent = (light.x - startX) / RANGE;
    const x = percent * w;

    ctx.beginPath();
    ctx.arc(x, h / 2, 4, 0, Math.PI * 2); // 10 px above center
    ctx.fillStyle = light.state === 1 ? "#ff0000" : "#000000";
    ctx.fill();
  }
}

  // Viewport box based on screen size (approximation)
  const screenWidthPx = window.innerWidth;
  const percentCamStart = (camX - startX) / RANGE;
  const percentCamEnd = (camX + screenWidthPx - startX) / RANGE;
  const camStart = percentCamStart * w;
  const camEnd = percentCamEnd * w;

  ctx.strokeStyle = "#444";
  ctx.strokeRect(camStart, h / 3, camEnd - camStart, h / 3);
}




  const fuelPickups = [
    { x: 100, collected: false },
    { x: 300, collected: true },
    { x: 500, collected: false },
  ];
  // === GLOBAL STATE ===
const trainTracks = [];
const spawnedTracks = new Set();
const trains = [];


const trackSpacing = 50000;
const firstTrack = 5000;

// === GENERATE TRAIN TRACKS ===
function generateTracksUpTo(xLimit) {
  for (let x = firstTrack; x <= xLimit; x += trackSpacing) {
    if (!trainTracks.some(t => t.x === x)) {
      const isDouble = Math.random() < 0.9;
      trainTracks.push({ x, isDouble });
    }
  }
}

// === TRAIN SPAWNING ===
function spawnTrain(trackX) {
  trains.push({
    worldX: trackX,
    scale: 0.1,
    growthSpeed: 0.005,
    spawnTime: Date.now()
  });
}

function checkTrainSpawn(bus) {
  trainTracks.forEach(({ x }) => {
    if (bus.x >= x - 1000 && !spawnedTracks.has(x)) {
      spawnTrain(x);
      spawnedTracks.add(x);
    }
  });
}

// === TRAIN DRAWING ===
function drawTrains(ctx, camX) {
  const now = Date.now();
  for (let i = trains.length - 1; i >= 0; i--) {
    const train = trains[i];
    train.scale += train.growthSpeed;

    if (train.scale > 4 || now - train.spawnTime > 30000) {
      trains.splice(i, 1);
      continue;
    }

    const screenX = train.worldX - camX;
    const y = 500;
    const width = 100 * train.scale;
    const height = 100 * train.scale;

    ctx.fillStyle = "#333";
    ctx.fillRect(screenX - width / 2, y - height, width, height);
    ctx.fillStyle = "#ccc";
    ctx.fillRect(screenX - width / 4, y - height + 10 * train.scale, width / 2, 12 * train.scale);
    ctx.fillStyle = "#222";
    ctx.beginPath();
    ctx.ellipse(screenX - width / 3, y - 10, 10 * train.scale, 5 * train.scale, 0, 0, Math.PI * 2);
    ctx.ellipse(screenX + width / 3, y - 10, 10 * train.scale, 5 * train.scale, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}
function drawTransitStation(ctx, x, camX) {
  const screenX = x - camX;
  const buildingWidth = 1000;
  const buildingHeight = 900;
  const baseY = canvas.height - buildingHeight + 1100;

  // Main building
  ctx.fillStyle = '#666';
  ctx.fillRect(screenX, baseY, buildingWidth, buildingHeight);

  // Dark gray brick base
  ctx.fillStyle = '#444';
  ctx.fillRect(screenX, baseY + buildingHeight - 30, buildingWidth, 30);

  // Optional: Add windows
  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
  for (let i = 0; i < 5; i++) {
    ctx.fillRect(screenX + 40 + i * 100, baseY + 20, 40, 60);
  }

  // Optional: Add sign
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 18px sans-serif';
  ctx.fillText('TRANSIT STATION', screenX + 20, baseY + 5);
}

// === TRACK DRAWING ===
function drawTracks(ctx, camX) {
  trainTracks.forEach(({ x }) => {
    const screenX = x - camX;
    const y = 500;
    ctx.strokeStyle = "#6B4C3B";
    ctx.lineWidth = 100;
    ctx.beginPath();
    ctx.moveTo(screenX - 160, y);
    ctx.lineTo(screenX + 160, y);
    ctx.stroke();
  });
}

// === TRAIN TRAFFIC LIGHTS ===
function generateTrainTrafficLights(busX) {
  trainTrafficLights = [];
  trainTracks.forEach(({ x }) => {
    if (Math.abs(busX - x) < 5000) {
      trainTrafficLights.push({ x, state: 0 });
    }
  });
}

function updateTrainTrafficLights(deltaTime) {
  if (trains.length > 0) {
    trainFlashTimer += deltaTime;
    if (trainFlashTimer >= 500) {
      trainFlashOn = !trainFlashOn;
      trainFlashTimer = 0;
    }
    trainTrafficLights.forEach(light => {
      light.state = trainFlashOn ? 1 : 0;
    });
  } else {
    trainFlashTimer = 0;
    trainFlashOn = true;
    trainTrafficLights.forEach(light => {
      light.state = 0;
    });
  }
}

function drawTrainTrafficLights(ctx, camX, canvasWidth) {
  const y = 520;
  trainTrafficLights.forEach(light => {
    const x = light.x - camX;
    if (x < -100 || x > canvasWidth + 3000) return;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fillStyle = light.state === 1 ? "#ff0000" : "#000000";
    ctx.fill();


    // Draw railway rectangle 100px after the traffic light
    // Find traffic light x for this track (if any)
      const railX = (light.x + 290) - camX;  // 100 px after light

      // Draw brown rectangle representing railway tie
      const rectWidth = 150;
      const rectHeight = 30;
      ctx.fillStyle = "#6B4C3B";
      ctx.fillRect(railX - rectWidth / 2, y - 25, rectWidth, rectHeight);

      // Draw two small squares inside the rectangle
      const squareSize = 35;
      const gap = 30; // space between squares

      ctx.fillStyle = "#333"; // darker brown for squares

      // Left square
      ctx.fillRect(railX - gap - squareSize / 2, y - 25, squareSize, squareSize);

      // Right square
      ctx.fillRect(railX + gap - squareSize / 2, y - 25, squareSize, squareSize);
    
  });
}

function isTrainLightBlocking(busX) {
  return trainTrafficLights.some(light =>
    Math.abs(busX - light.x) < 500 && light.state === 1
  
  );
}

  // Bus data for each type
  const buses = [
    {
      name: "Gillig 29'",
      x: 200,
      y: 330,
      width: 450,   // slightly shorter than before (was 400)
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [300, 340], // relative to bus.x
      doorSize: {width: 40, height: 130},
      window: { x: 30, y: 40, width: 250, height: 93.33},
      wheelOffsets: [125, 260],
      window2: { x: 380, y: 45, width: 0, height: 0 },
      bodyBezierOffset: 63,
    },
    {
      name: "Gillig 40'",
      x: 200,
      y: 330,
      width: 470,
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [350, 390], // doors moved further back for longer bus
      backDoorPositions: [140, 180],
      doorSize: {width: 40, height: 130},
      window: { x: 0, y: 40, width: 140, height: 87.33},
      wheelOffsets: [100, 300],
      window2: { x: 220, y: 40, width: 130, height: 87.33 },
      bodyBezierOffset: 70,
    },
    {
      name: "New Flyer Xcelsior 40'",
      x: 200,
      y: 330,
      width: 500,
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [405, 430], // doors moved further back for longer bus
      doorSize: {width: 50, height: 130},
      backDoorPositions: [160, 205],
      window: { x: 55, y: 40, width: 105, height: 80.33},
      wheelOffsets: [125, 360],
      window2: { x: 255, y: 40, width: 150, height: 93.33 },
      bodyBezierOffset: 70,
    }
  ];
  // Control flags
let driverLocked = false;
let isLowered = false;
let xB = 0
// Kneeling amount
const LOWER_OFFSET = 10;// Default gradient stops
let gradientStops = [
  { offset: 0, color: '#d3d3d3' },
  { offset: 1, color: '#d3d3d3' }
];
let points = parseInt(localStorage.getItem('playerPoints')) || 1;
// Save to localStorage
function savePoints() {
  localStorage.setItem('playerPoints', points);
}

// Load from localStorage or fallback
function loadGradientStops() {
  const saved = localStorage.getItem('busGradientStops');
  if (saved) {
    gradientStops = JSON.parse(saved);
  }
}
loadGradientStops();
let stopHistory = JSON.parse(localStorage.getItem("stopHistory") || "[]");

function savePoints() {
  localStorage.setItem("points", points);
}

function saveStopHistoryEntry(entry) {
  stopHistory.push(entry);
  localStorage.setItem('stopHistory', JSON.stringify(stopHistory));
}

// Update the color pickers with loaded colors
const startColorPicker = document.getElementById('endColorPicker');
const endColorPicker = document.getElementById('startColorPicker');

startColorPicker.value = gradientStops[0].color;
endColorPicker.value = gradientStops[1].color;

// Save function
function saveGradientStops() {
  localStorage.setItem('busGradientStops', JSON.stringify(gradientStops));
}

// Set gradient colors and save
function setBusGradientColors(startColor, endColor) {
  gradientStops = [
    { offset: 0, color: startColor },
    { offset: 1, color: endColor }
  ];
  saveGradientStops();
}

// Listen for changes on the color pickers
startColorPicker.addEventListener('input', (e) => {
  setBusGradientColors(e.target.value, gradientStops[1].color);
});

endColorPicker.addEventListener('input', (e) => {
  setBusGradientColors(gradientStops[0].color, e.target.value);
});

// In your draw function, use gradientStops like this:

function generateTrafficLights(busX, intersection = null) {
  let centerX;

  if (intersection && typeof intersection.x === 'number') {
    centerX = intersection.x;
  } else if (typeof busX === 'number') {
    centerX = busX;
  } else {
    // fallback or error handling
    console.warn('generateTrafficLights: invalid busX and no intersection given');
    return;
  }

  // Calculate centerIndex as integer grid index based on position
  const centerIndex = Math.floor(centerX / trafficLightSpacing);

  if (centerIndex === lastCenterIndex) return;
  lastCenterIndex = centerIndex;

  const newLights = [];
  for (let i = -Math.floor(lightCount / 2); i <= Math.floor(lightCount / 2); i++) {
    const lightX = (centerIndex + i) * trafficLightSpacing;
    let existingLight = trafficLights.find(l => l.x === lightX);

    if (!existingLight) {
      existingLight = {
        x: lightX,
        state: 0,
        timer: 0,
        violated: false
      };
    }
    newLights.push(existingLight);
  }
  trafficLights = newLights;
}


window.addEventListener('keydown', e => {
  if ((e.key === 'l' || e.key === 'l') && vx === 0) {
    driverLocked = !driverLocked
    isLowered = !isLowered;
    console.log(isLowered ? "⬇ Bus lowered (kneeling)." : "⬆ Bus raised.");
  }
});
function saveGradient(stops) {
  if (!Array.isArray(stops)) return;

  try {
    localStorage.setItem('busGradient', JSON.stringify(stops));
  } catch (e) {
    console.error('Failed to save gradient:', e);
  }
}

let lastDrawTime = performance.now();
const signalSigns = [];
const maxSigns = 5;
function exportGradient() {
  const blob = new Blob([JSON.stringify(gradientStops, null, 2)], {
    type: 'application/json',
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'bus-gradient.sg';
  a.click();
  URL.revokeObjectURL(url);
}
document.getElementById('importGradientFile').addEventListener('change', function (event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const imported = JSON.parse(e.target.result);
      if (Array.isArray(imported)) {
        gradientStops = imported;
        saveGradientStops()
        alert("Gradient imported successfully!");
      } else {
        alert("Invalid gradient format.");
      }
    } catch (err) {
      alert("Failed to load gradient: " + err.message);
      saveGradientStops()
    }
  };
  reader.readAsText(file);
});
saveGradientStops()
const backgroundLayers = [
  { speed: 0.1, objects: [], type: 'cloud' },
  { speed: 0.2, objects: [], type: 'building' },
  { speed: 0.4, objects: [], type: 'tree' },
  { speed: 0.8, objects: [], type: 'car' }
];

const brightBackdropColors = [
  '#FF3B3B', '#FF9B00', '#FFEB3B', '#8BC34A', '#00BCD4', '#3F51B5', '#9C27B0', '#E91E63',
  '#FFC107', '#4CAF50', '#00E5FF', '#673AB7', '#F44336', '#CDDC39', '#2196F3', '#FF9800'
];

// Named buildings limited to 20 with 5 variants each
const namedBuildings = [
  'Post Office', 'Library', 'Supermarket', 'Bakery', 'Cafe', 'Cinema', 'Museum', 'Clinic',
  'Gym', 'Fire Station', 'Police Station', 'Bank', 'Fast Food', 'Pharmacy', 'Bookstore',
  'Hotel', 'Apartments', 'Office Tower', 'Gas Station', 'Court House'
];

// Fonts for each building name type (change as needed)
const buildingFonts = {
  'Post Office': 'italic 18px serif',
  'Library': 'bold 18px "Georgia", serif',
  'Supermarket': 'bold 16px "Arial Black", sans-serif',
  'Bakery': 'italic 16px "Comic Sans MS", cursive',
  'Cafe': 'bold 16px "Lucida Handwriting", cursive',
  'Cinema': 'bold 18px "Impact", sans-serif',
  'Museum': 'italic 18px "Times New Roman", serif',
  'Clinic': 'bold 18px "Trebuchet MS", sans-serif',
  'Gym': 'bold 20px "Verdana", sans-serif',
  'Fire Station': 'bold 18px "Tahoma", sans-serif',
  'Police Station': 'bold 18px "Courier New", monospace',
  'Bank': 'bold 20px "Georgia", serif',
  'Fast Food': 'bold 18px "Arial Black", sans-serif',
  'Pharmacy': 'italic 16px "Palatino", serif',
  'Bookstore': 'italic 18px "Georgia", serif',
  'Hotel': 'bold 18px "Lucida Bright", serif',
  'Apartments': 'bold 16px "Arial", sans-serif',
  'Office Tower': 'bold 18px "Helvetica", sans-serif',
  'Gas Station': 'bold 18px "Verdana", sans-serif',
  'Court House': 'bold 20px "Times New Roman", serif',
};

// Utility function to draw pillars (used for Court House, Bank, etc.)
function drawPillars(ctx, x, y, width, height, count) {
  const pillarWidth = width / (count * 2);
  const pillarHeight = height * 0.7;
  ctx.fillStyle = '#CCC';
  for (let i = 0; i < count; i++) {
    const px = x + i * pillarWidth * 2 + pillarWidth / 2;
    ctx.fillRect(px, y + height - pillarHeight, pillarWidth, pillarHeight);
    // Pillar top
    ctx.fillRect(px - 5, y + height - pillarHeight - 10, pillarWidth + 10, 10);
  }
}

// Icon drawing for specific building types (simple vector shapes)

function drawBookIcon(ctx, x, y, size) {
  ctx.fillStyle = '#7B3F00';
  ctx.fillRect(x, y, size * 0.7, size);
  ctx.fillStyle = '#A0522D';
  ctx.fillRect(x + size * 0.7, y + size * 0.1, size * 0.1, size * 0.8);
}

function drawBakeryDisplay(ctx, x, y, width, height) {
  ctx.fillStyle = '#FFDAB9';
  ctx.fillRect(x, y + height * 0.7, width, height * 0.3);
  ctx.fillStyle = '#F4A460';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.ellipse(x + width * (0.2 + i * 0.3), y + height * 0.85, width * 0.07, height * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawPillarRoof(ctx, x, y, width) {
  ctx.fillStyle = '#BBB';
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + width / 2, y - 30);
  ctx.lineTo(x + width, y);
  ctx.closePath();
  ctx.fill();
}

function drawBuildingName(ctx, name, x, y, width, align = 'center') {
  ctx.fillStyle = '#FFF';
  ctx.textBaseline = 'top';
  ctx.font = buildingFonts[name] || '16px sans-serif';
  ctx.textAlign = align;
  if (align === 'center') {
    ctx.fillText(name, x + width / 2, y);
  } else if (align === 'left') {
    ctx.fillText(name, x + 5, y);
  }
}

// Now the main drawing function for buildings including variants and decorations

function drawNamedBuilding(ctx, obj, time) {
  const { x, y, width, height, name, variant } = obj;
  const screenX = x - camX * 0.2;

  // Base colors & gradients for variants (adjust to taste)
  const baseColors = [
    '#2C3E50', '#34495E', '#7F8C8D', '#95A5A6', '#BDC3C7'
  ];
  const baseColor = baseColors[variant % baseColors.length];

  // Draw building base
  const grad = ctx.createLinearGradient(0, y, 0, y + height);
  grad.addColorStop(0, baseColor);
  grad.addColorStop(1, '#000');
  ctx.fillStyle = grad;
  ctx.fillRect(screenX, y, width, height);

  // Mono large window if applicable (some buildings have no windows)
  const windowMargin = 20;
  const windowWidth = width - windowMargin * 2;
  const windowHeight = height * 0.6;
  const windowY = y + height * 0.25;

  // Draw windows only on specific types
  if (['Library', 'Supermarket', 'Bakery', 'Cafe', 'Cinema', 'Museum', 'Clinic', 'Gym', 'Bank', 'Bookstore', 'Hotel', 'Office Tower'].includes(name)) {
    // Mono window with gradient
    const windowGrad = ctx.createLinearGradient(0, windowY, 0, windowY + windowHeight);
    windowGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
    windowGrad.addColorStop(1, 'rgba(200, 200, 255, 0.1)');
    ctx.fillStyle = windowGrad;
    ctx.fillRect(screenX + windowMargin, windowY, windowWidth, windowHeight);
  }

  // Draw building specific decoration by name and variant
  switch (name) {
    case 'Library':
      // Draw a book icon on wall
      drawBookIcon(ctx, screenX + width / 2 - 20, y + height * 0.15, 40);
      drawBuildingName(ctx, name, screenX, y + 5, width, 'center');
      break;

    case 'Bakery':
      drawBakeryDisplay(ctx, screenX + 10, y + height * 0.65, width * 0.8, height * 0.25);
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;

    case 'Court House':
      drawPillars(ctx, screenX + width * 0.15, y, width * 0.7, height, 6);
      drawPillarRoof(ctx, y, y, width);
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;

    case 'Bank':
      drawPillars(ctx, screenX + width * 0.1, y + height * 0.1, width * 0.8, height * 0.7, 4);
      drawBuildingName(ctx, name, screenX + width / 2, y + 5, width, 'center');
      break;

    case 'Post Office':
      // Use a stripe for the post office
      ctx.fillStyle = '#003366';
      ctx.fillRect(screenX, y + height * 0.1, width, height * 0.15);
      drawBuildingName(ctx, name, screenX + width / 2, y + 5, width, 'center');
      break;

    default:
      // Just building name top-left for others
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;
  }
}
const intersections = [];
const canvasWidth = 800; // example, adjust as needed
const canvasHeight = 600;
const mainRoadY = canvasHeight - 100;

// Generate intersections up to some max distance (e.g. 100000 px)
const maxDistance = 100000;
let lastX = 0;
while (lastX < maxDistance) {
  const gap = 2000 + Math.random() * 3000; // 2000-5000 px gap
  lastX += gap;
  intersections.push({
    x: lastX,
    hasTrafficLight: Math.random() < 0.2, // 20% chance
  });
}

function drawIntersection(ctx, camX, intersection) {
  const screenX = intersection.x - camX + canvasWidth / 2;

  // Only draw if on screen (roughly)
  if (screenX < -200 || screenX > canvasWidth + 200) return;

  const buildingWidth = 120;
  const buildingHeight = 200;

  // Draw perpendicular street (vertical road)
  ctx.fillStyle = '#444'; // dark asphalt
  ctx.fillRect(screenX - 50, 0, 100, canvasHeight);

  // Draw building at NE corner (right of vertical road, above main road)
  const buildingX = screenX + 50;
  const buildingY = mainRoadY - buildingHeight;
  ctx.fillStyle = '#a0522d';
  ctx.fillRect(buildingX, buildingY, buildingWidth, buildingHeight);

  // Windows on building
  ctx.fillStyle = '#555';
  const windowSize = 20;
  for(let y = buildingY + 10; y < buildingY + buildingHeight - 10; y += 40) {
    for(let x = buildingX + 10; x < buildingX + buildingWidth - 10; x += 40) {
      ctx.fillRect(x, y, windowSize, windowSize);
    }
  }

  // Draw traffic light if this intersection has one
  if (intersection.hasTrafficLight) {
    const lightX = buildingX - 40;
    const lightY = mainRoadY - 70;

    // Pole
    ctx.fillStyle = '#222';
    ctx.fillRect(lightX + 12, lightY, 6, 50);

    // Traffic light box
    ctx.fillStyle = '#000';
    ctx.fillRect(lightX, lightY - 30, 30, 60);

    // Lights: red, yellow, green
    const lightRadius = 8;
    const lightSpacing = 20;
    const colors = ['red', 'yellow', 'green'];
    for(let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.fillStyle = colors[i];
      ctx.arc(lightX + 15, lightY - 20 + i * lightSpacing, lightRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
  }
}
function drawAllIntersections(ctx, camX) {
  const roadWidth = 350;
  const mainRoadTop = canvas.height - 140;   // top edge of sidewalk
  const mainRoadHeight = 140;                // sidewalk + main road total height
  const sidewalkWidth = 15;
  const buildingWidth = 80;
  const buildingHeight = 140;

  // Remove traffic lights for intersections too far from camX (>500px)
  trafficLights = trafficLights.filter(light => {
    // Find corresponding intersection
    const intersection = intersections.find(i => i.x === light.x);
    if (!intersection) return false; // no intersection found => remove light
    const dist = Math.abs(intersection.x - camX);
    return dist <= 500;
  });

  for (const intersection of intersections) {
    // Calculate screen position relative to camera
    const screenX = intersection.x - camX + canvas.width / 2;

    // Draw perpendicular road - vertical rectangle cutting main road + sidewalk
    ctx.fillStyle = '#333';  // same as main road color
    ctx.fillRect(screenX - roadWidth / 2, mainRoadTop, roadWidth, mainRoadHeight);

  }
}
// Helper function to draw a traffic light at (x, y)
function drawTrafficLight(ctx, x, y) {
  const lightWidth = 20;
  const lightHeight = 60;
  ctx.fillStyle = '#222';
  ctx.fillRect(x - lightWidth / 2, y - lightHeight, lightWidth, lightHeight);

  // Lights: red, yellow, green circles
  const radius = 6;
  const spacing = 20;
  const colors = ['red', 'yellow', 'green'];
  for (let i = 0; i < colors.length; i++) {
    ctx.beginPath();
    ctx.fillStyle = colors[i];
    ctx.arc(x, y - lightHeight + spacing * (i + 1), radius, 0, Math.PI * 2);
    ctx.fill();
  }
}
let freeCam = false;
let freeCamX = 0;

// Inside key listener:
window.addEventListener('keydown', e => {
  if (e.key === 'f') freeCam = !freeCam;
});
// Modified main draw function to include named buildings variants
// Array to hold AI buses
const aiBuses = [];
let aiBusSpawned = false; // Prevent multiple spawns
const aiCars = []; // All dumb cars
const STUCK_CAR_PROBABILITY = 0.2; // 20% chance it's a stuck car
const MAX_CAR_SPEED = 7.5;

function spawnAICar(x, y) {
  const stuck = Math.random() < STUCK_CAR_PROBABILITY;
  const hateBuses = Math.random() < 0.5;

  aiCars.push({
    x,
    y,
    speed: stuck ? 0 : 3 + Math.random() * (MAX_CAR_SPEED - 3),
    stuck,
    hateBuses,
    slowdownTimer: 0,
  });
}

const BUS_SPACING_SEC = 30;      // 20 seconds between buses schedule offsets
const IDEAL_SPEED = 150;         // px per second (5000 px in 25 seconds)

function updateAICars(bus) {
  for (let i = aiCars.length - 1; i >= 0; i--) {
    const car = aiCars[i];

    if (car.stuck) continue;

    // Despawn if car is far behind the bus
    if (car.x < bus.x - 800) {
      aiCars.splice(i, 1); // Remove car
      continue;
    }

    // Initialize slowdown timer if missing
    car.slowdownTimer ??= 0;

    const distToBus = Math.abs(car.x - bus.x);

    if (car.hateBuses && distToBus < 200) {
      // Trigger slowdown
      car.slowdownTimer++;
      if (car.slowdownTimer < 60) {
        car.speed = Math.max(1, car.speed - 0.1); // Gradual slowdown
      } else {
        car.slowdownTimer = 0;
        car.speed = 3 + Math.random() * (MAX_CAR_SPEED - 3); // Resume speed
      }
    } else {
      car.slowdownTimer = 0;
    }

    car.x -= car.speed;
  }
}


let raceMode = false;
let raceTimer = 0;

// Config Constants
const MAX_AI_SPEED = 11;
const MIN_DISTANCE = 530;
const BEEP_INTERVAL = 30;
const GO_AROUND_DISTANCE = 1600;
const GO_AROUND_SPEED = 25;
const RANDOM_STOP_PROBABILITY = 0.002;
const RANDOM_STOP_DURATION = 300;

const BUS_INTERVAL_PX = 2000;
const PASS_INTERVAL_MS = 25000; // 25 sec per 5000px
const PASS_TOLERANCE_MS = 5000;

// Ideal speed = px/ms (distance over time)

const SPEED_PX_PER_MS = IDEAL_SPEED; // alias for clarity


// Global timing
const startTime = performance.now();


// Map to store each bus's schedule offset (in ms)
const scheduleOffsets = new Map();

/**
 * Assign schedule offsets:
 * - Player bus = 0 offset (base schedule)
 * - AI buses staggered ahead and behind by 20s intervals
 *   e.g. first AI bus 20s behind, second 20s ahead,
 *        third 40s behind, fourth 40s ahead, etc.
 * @param {Object} playerBus
 * @param {Array} aiBuses
 */
/**
 * Dynamically assign schedule offsets based on buses' current positions
 * relative to the playerBus.x
 * @param {Object} playerBus
 * @param {Array} aiBuses
 */
// Global constants

let lastLogTime = 0;


// Create AI Bus object
function createAIBus(startX = 0) {
  return {
    x: startX,
    y: 330,
    speed: 0,
    maxSpeed: 13,
    waiting: false,
    waitTimer: 0,
    width: 470,
    height: 180,
    wheelAngle: 0.1,
    doorPositions: [350, 390],
    backDoorPositions: [140, 180],
    doorSize: { width: 40, height: 130 },
    window: { x: 0, y: 40, width: 140, height: 87.33 },
    window2: { x: 220, y: 40, width: 130, height: 87.33 },
    wheelOffsets: [100, 300],
    bodyBezierOffset: 70,
    typeIndex: 1,
    beepTimer: 0,
    state: "follow",
    bypassProgress: 0,
    randomStopTimer: 0,
  };
}

// Play honk sound
function playHonkSound() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(440, ctx.currentTime);
  gain.gain.setValueAtTime(0.15, ctx.currentTime);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.4);
}

// Assign schedule offsets based on player bus position
function assignScheduleOffsetsByPosition(playerBus, aiBuses) {
  scheduleOffsets.clear();
  scheduleOffsets.set(playerBus, 0);

  const busesAhead = [];
  const busesBehind = [];

  for (const bus of aiBuses) {
    if (bus.x > playerBus.x) {
      busesAhead.push(bus);
    } else if (bus.x < playerBus.x) {
      busesBehind.push(bus);
    } else {
      busesAhead.push(bus); // treat equal position as ahead
    }
  }

  busesAhead.sort((a, b) => a.x - b.x);
  busesBehind.sort((a, b) => b.x - a.x);

  busesAhead.forEach((bus, i) => {
    scheduleOffsets.set(bus, (i + 1) * BUS_SPACING_SEC * 1000);
  });

  busesBehind.forEach((bus, i) => {
    scheduleOffsets.set(bus, -(i + 1) * BUS_SPACING_SEC * 1000);
  });
}

// Get ideal X position of a bus based on elapsed time and schedule offset
function getIdealPosition(bus, elapsedTime) {
  const offsetMs = scheduleOffsets.get(bus) ?? 0;
  const idealElapsed = elapsedTime - offsetMs;
  return idealElapsed > 0 ? idealElapsed * IDEAL_SPEED : 0;
}

function getLateness(bus, elapsedTime) {
  const offsetMs = scheduleOffsets.get(bus) ?? 0;
  const idealX = IDEAL_SPEED * ((elapsedTime - offsetMs) / 1000);  // Correct offset use
  return bus.x - idealX;
}

// Get nearest AI buses ahead and behind playerX
function getNearestAIBuses(playerX) {
  let behind = null, ahead = null;
  let minBehindDist = Infinity, minAheadDist = Infinity;

  for (const bus of aiBuses) {
    const dx = bus.x - playerX;
    if (dx < 0 && Math.abs(dx) < minBehindDist) {
      behind = bus;
      minBehindDist = Math.abs(dx);
    } else if (dx > 0 && dx < minAheadDist) {
      ahead = bus;
      minAheadDist = dx;
    }
  }
  return { behind, ahead };
}
// === Constants ===
const MAX_SPEED_BUFFER = 5;
const TOLERANCE_SEC = 1.5;
const MAX_CATCHUP_SPEED_BOOST = 7;
const MAX_LATE_SPEED_BOOST = 12;
const EARLY_OFFSET_SEC = 10;
const aiBusCount = 8;
const idealSpeedPerMs = IDEAL_SPEED / 1000;

// aiBusCount buses excluding playerBus
// Define exact spawn positions in pixels for each bus individually (length = aiBusCount excluding player)
const aiBusSpawnPositions = [
  -20600,
  -5500,
  4500,
  19300,  
];

// Corresponding schedule offsets in milliseconds (must match spacing to keep them on schedule)
const aiBusScheduleOffsetsMs = aiBusSpawnPositions.map(
  pos => -pos / idealSpeedPerMs  // inverse of startX = -offsetMs * idealSpeedPerMs => offsetMs = -startX / idealSpeedPerMs
);

// Spawn AI buses with your custom start positions and offsets
aiBuses.length = 0;
scheduleOffsets.clear();

for (let i = 0; i < aiBusSpawnPositions.length; i++) {
  const startX = aiBusSpawnPositions[i];
  const offsetMs = aiBusScheduleOffsetsMs[i];

  const aiBus = createAIBus(startX);
  aiBus.maxSpeed = 12;
  aiBus.randomStopTimer = 0;
  aiBus.bypassProgress = 0;
  aiBus.state = "follow";
  aiBus.beepTimer = 0;
  aiBus.lingerTimer = 0;
  aiBus.x = startX;
  aiBus.vx = 0;

  aiBuses.push(aiBus);
  scheduleOffsets.set(aiBus, offsetMs);
}

// Constants for mode probabilities and timings
const MODE_SWITCH_CHANCE_PER_FRAME = 0.001; // ~0.1% chance per frame to switch mode
const LONG_STOP_PROBABILITY = 0.002; // Probability to start a long stop for Stop-and-Go buses
const LONG_STOP_DURATION_FRAMES = 100; // 5 seconds at 60fps
const SAFE_FOLLOW_DISTANCE = 200; // min px distance to keep from bus ahead
const PATIENCE_FRAMES = 30;       // wait 1 second before accelerating after stop
function updateAIBuses(deltaTime, playerBus) {
  const elapsedTime = performance.now() - startTime;
  const logStatuses = [];

  for (const bus of aiBuses) {
    if (!bus.personality) {
      const rand = Math.random();
      if (rand < 0.3) bus.personality = "cruiser";
      else if (rand < 0.6) bus.personality = "stopGo";
      else if (rand < 0.8) bus.personality = "steady";
      else if (rand < 0.9) bus.personality = "nervous";
      else bus.personality = "skipper";

      bus.modeTimer = 0;
      bus.lingerTimer = 0;
      bus.patienceTimer = 0;
      bus.earlyHoldApplied = false;
      bus.maxSpeed = 8 + Math.random() * 3; // a bit slower overall
      bus.cruisingSpeed = IDEAL_SPEED * (0.75 + Math.random() * 0.2); // slightly under target
      bus.reliability = 0.05 + Math.random() * 0.2;
      bus.stopChance = 0.5 //more likely to stop
    }

    const distanceToPlayer = playerBus.x - bus.x - 450;

    // === Handle lingering ===
    if (bus.lingerTimer > 0) {
      bus.vx = 0;
      bus.lingerTimer--;
      bus.x += bus.vx;
      continue;
    }

    // === Random breakdowns ===
    if (Math.random() > bus.reliability && Math.random() < 0.001) {
      bus.lingerTimer = 180 + Math.floor(Math.random() * 300);
      continue;
    }

    // === Bypass logic ===
    if (bus.state === "bypass") {
      bus.vx = GO_AROUND_SPEED * 0.6 + Math.random() * GO_AROUND_SPEED * 0.4;
      bus.bypassProgress += bus.vx;
      if (bus.bypassProgress >= GO_AROUND_DISTANCE) {
        bus.state = "follow";
        bus.bypassProgress = 0;
      }
      bus.x += bus.vx;
      continue;
    }

    if (distanceToPlayer > 0 && distanceToPlayer <= MIN_DISTANCE) {
      bus.vx = 0;
      bus.beepTimer = (bus.beepTimer || 0) + 1;
      if (bus.beepTimer >= BEEP_INTERVAL) {
        bus.beepTimer = 0;
        playHonkSound();
        if (Math.random() < 0.05) {
          bus.state = "bypass";
          bus.bypassProgress = 0;
        }
      }
      bus.x += bus.vx;
      continue;
    }

    // === Time vs Schedule ===
    const offsetMs = scheduleOffsets.get(bus) ?? 0;
    const idealX = IDEAL_SPEED * ((elapsedTime - offsetMs) / 1000);
    const dx = idealX - bus.x;
    const absDx = Math.abs(dx);
    const latenessSec = dx / IDEAL_SPEED;

    if (latenessSec <= 10) {
      bus.earlyHoldApplied = false; // reset once closer to time
    }

    // === Extra-early waiting logic ===
    if (latenessSec > 15 && !bus.earlyHoldApplied) {
      // Find nearest valid stop
      let closestStop = null;
      let closestDist = Infinity;

      for (const stop of stops) {
        const dist = Math.abs(bus.x - stop.x);
        if (!stop.playerOnly && dist < STOP_DETECTION_RANGE * 1.5 && dist < closestDist) {
          closestDist = dist;
          closestStop = stop;
        }
      }

      if (closestStop) {
        closestStop.collected = true;
        bus.lingerTimer = 1200; // Wait 20 seconds
        bus.earlyHoldApplied = true;
        continue;
      }
    }

    // === Stop logic ===
    let stoppingNow = false;
    for (const stop of stops) {
      if (Math.abs(bus.x - stop.x) < STOP_DETECTION_RANGE && !stop.playerOnly) {
        let shouldStop = Math.random() < bus.stopChance;

        if (shouldStop) {
          bus.lingerTimer = 900;
          stoppingNow = true;
          break;
        }
      }
    }

    if (stoppingNow) {
      bus.vx = 0;
      bus.x += bus.vx;
      continue;
    }

    // === Bus following logic ===
    let nearestBusAhead = null;
    let minDistAhead = Infinity;
    for (const other of aiBuses) {
      if (other === bus) continue;
      const dist = other.x - bus.x;
      if (dist > 0 && dist < minDistAhead) {
        minDistAhead = dist;
        nearestBusAhead = other;
      }
    }

    let adjustedMaxSpeed = bus.maxSpeed;
    if (nearestBusAhead && minDistAhead < SAFE_FOLLOW_DISTANCE) {
      adjustedMaxSpeed *= minDistAhead / SAFE_FOLLOW_DISTANCE;
    }

    // === Personality-based movement ===
    let targetSpeed;
    switch (bus.personality) {
      case "cruiser":
        targetSpeed = bus.cruisingSpeed + (Math.random() - 0.5) * 0.4;
        break;
      case "stopGo":
        if (Math.random() < 0.002) {
          bus.lingerTimer = 120;
          targetSpeed = 0;
        } else {
          targetSpeed = IDEAL_SPEED + Math.random() * 2;
        }
        break;
      case "steady":
        targetSpeed = IDEAL_SPEED + dx * 0.015;
        break;
      case "nervous":
        targetSpeed = dx > 0
          ? Math.min(adjustedMaxSpeed, IDEAL_SPEED + absDx * 0.03)
          : Math.max(IDEAL_SPEED * 0.6, IDEAL_SPEED - absDx * 0.04);
        break;
      case "skipper":
        targetSpeed = adjustedMaxSpeed + (Math.random() - 0.5);
        break;
      default:
        targetSpeed = IDEAL_SPEED;
    }

    // Apply randomness and smoothing
    targetSpeed += (Math.random() - 0.5) * 0.2;
    targetSpeed = Math.max(0, Math.min(adjustedMaxSpeed, targetSpeed));
    bus.vx += (targetSpeed - bus.vx) * 0.08;
    bus.x += bus.vx;

    // === Log bus status ===
    const status =
      latenessSec > 1 ? "EARLY" :
      latenessSec < -1 ? "LATE" : "ON TIME";

    logStatuses.push(
      `Bus (${bus.personality}) x=${bus.x.toFixed(1)} ${status} (${latenessSec.toFixed(2)}s)`
    );
  }

  if (elapsedTime - lastLogTime > 5000) {
    console.log("=== Bus Status ===\n" + logStatuses.join(" | ") + "\n===================");
    lastLogTime = elapsedTime;
  }
}

function updateLatenessUI(playerBus) {
  const elapsedTime = performance.now() - startTime;

  // Get lateness in pixels, convert to seconds: px / px-per-second
  const playerLatenessPx = getLateness(playerBus, elapsedTime);
  const playerLatenessSeconds = playerLatenessPx / IDEAL_SPEED;

  const { behind, ahead } = getNearestAIBuses(playerBus.x);

  function getLatenessSeconds(bus) {
    if (!bus) return null;
    const latenessPx = getLateness(bus, elapsedTime);
    return latenessPx / IDEAL_SPEED;
  }

  function getTimeDiffSeconds(busA, busB) {
    if (!busA || !busB) return null;
    const dx = busA.x - busB.x;
    return dx / IDEAL_SPEED;
  }

  const behindDiff = getTimeDiffSeconds(playerBus, behind);
  const aheadDiff = getTimeDiffSeconds(ahead, playerBus);

  // Format the lateness status based on seconds (not pixels)
  const formatStatus = (seconds) => {
    if (seconds === null) return "N/A";
    if (Math.abs(seconds) <= 10) return "ON TIME";
    return seconds < 0 ? "Late" : "Early";
  };

  // Format time in seconds with no decimals for cleaner display
  const formatTime = (seconds) => {
    if (seconds === null) return "N/A";
    return `${Math.abs(seconds).toFixed(0)}s ${formatStatus(seconds)}`;
  };

  const lines = [
    `Player Lateness: ${formatTime(playerLatenessSeconds)}`,
    behind ? `AI Bus Behind: ${formatTime(getLatenessSeconds(behind))}` : "AI Bus Behind: N/A",
    ahead ? `AI Bus Ahead: ${formatTime(getLatenessSeconds(ahead))}` : "AI Bus Ahead: N/A"
  ];

  const elem = document.getElementById('lateness-info');
  if (elem) {
    elem.textContent = lines.join('\n');
  }
}

function updateStops(deltaTime) {
  const now = performance.now();
  for (let stop of stops) {
    if (stop.collected && now >= stop.regenTime) {
      stop.collected = false;
      stop.special = Math.random() < 0.2;
      // You can randomize isStation if desired, or keep it fixed
    }
  }
}

let spawnIndex = 0;
let spawning = false;
// Draw a single AI bus
function drawAIBuses(bus) {
  const typeIndex = bus.typeIndex;

  // Optional green path for type 1 or 2


  ctx.save();

  // Transform setup (no tilt here)
  ctx.translate(bus.x - camX + bus.width / 2, bus.y + bus.height / 2);
  ctx.translate(-(bus.x - camX + bus.width / 2), -(bus.y + bus.height / 2));

  // Bus gradient
  const x0 = bus.x - camX;
  const y0 = bus.y + bus.height;
  const x1 = bus.x - camX + bus.width;
  const y1 = bus.y;

  const busGradient = ctx.createLinearGradient(x0, y0, x1, y1);
  busGradient.addColorStop(0, '#555');
  busGradient.addColorStop(1, '#222');

  const leftX = bus.x - camX;
  const rightX = leftX + bus.width;
  const topY = bus.y;
  const bottomY = bus.y + bus.height;
  const ctrlOffset = 30;

  // Type-specific shapes
  if (typeIndex === 2) {
    ctx.save();
    ctx.translate(0, bus.y + 20);
    ctx.scale(1, -1);
    const startX = leftX;
    const startY = 10;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(startX, startY + 40);
    ctx.lineTo(startX + 370, startY + 40);
    ctx.quadraticCurveTo(startX + 420, startY + 40, startX + 420, startY);
    ctx.lineTo(startX + 300, startY);
    ctx.closePath();
    const curveGradient = ctx.createLinearGradient(x0, y0, x1, y1);
    curveGradient.addColorStop(0, '#555');
    curveGradient.addColorStop(1, '#222');
    ctx.fillStyle = curveGradient;
    ctx.fill();
    ctx.restore();
  }

  if (typeIndex === 1) {
    ctx.save();
    ctx.translate(0, bus.y + 20);
    ctx.scale(1, -1);
    const startX = leftX + 53;
    const startY = 20;
    ctx.beginPath();
    ctx.moveTo(startX - 50, startY);
    ctx.lineTo(startX - 50, startY + 42);
    const totalLen = 133;
    ctx.lineTo(startX + totalLen * 0.8 - 50, startY + 42);
    const curveEndX = startX + totalLen - 50;
    ctx.quadraticCurveTo(curveEndX + 30, startY + 52, curveEndX, startY + 52);
    ctx.lineTo(curveEndX, startY + 52);
    const dx = Math.cos(Math.PI * 75 / 180) * 31.5;
    const dy = Math.sin(Math.PI * 75 / 180) * 31.5;
    ctx.lineTo(startX + dx, startY + 59 + dy);
    ctx.lineTo(startX + 187, startY);
    ctx.closePath();
    ctx.fillStyle = 'rgba(211, 211, 211, 1)';
    ctx.fill();
    ctx.restore();
  }

  // Main body shape
  ctx.beginPath();
  ctx.moveTo(leftX, topY);
  ctx.lineTo(leftX, bottomY);
  ctx.lineTo(rightX - 5, bottomY);
  ctx.lineTo(rightX, bottomY - 10);
  ctx.lineTo(rightX, topY + bus.height * 0.59);
  ctx.bezierCurveTo(rightX, topY, rightX - ctrlOffset, topY, rightX - 65 - ctrlOffset, topY);
  ctx.lineTo(leftX, topY);
  ctx.closePath();
  ctx.fillStyle = busGradient;
  ctx.fill();

  // Doors
  ctx.save();
  const doorGradient = ctx.createLinearGradient(0, 0, 0, bus.doorSize.height);
  doorGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
  doorGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
  ctx.fillStyle = doorGradient;

  bus.doorPositions.forEach(doorX => {
    if (typeIndex === 2 && doorX === 430) return; // skip special case
    const x = bus.x - camX + doorX;
    const y = bus.y + 40;
    ctx.fillRect(x, y, bus.doorSize.width, bus.doorSize.height);
  });
  ctx.restore();

  // Special door for type 2
  if (typeIndex === 2) {
    const doorX = bus.x - camX + 450;
    const y = bus.y + 40;
    ctx.save();
    ctx.translate(0, y + bus.doorSize.height);
    ctx.scale(1, -1);
    ctx.beginPath();
    ctx.moveTo(doorX, 0);
    ctx.lineTo(doorX, bus.doorSize.height);
    ctx.lineTo(doorX + 10, bus.doorSize.height);
    ctx.quadraticCurveTo(doorX + 30, bus.doorSize.height, doorX + 30, bus.doorSize.height - 100);
    ctx.lineTo(doorX + 30, 0);
    ctx.closePath();
    ctx.fillStyle = doorGradient;
    ctx.fill();
    ctx.restore();
  }

  // Back doors
  if (bus.backDoorPositions) {
    bus.backDoorPositions.forEach(doorX => {
      const x = bus.x - camX + doorX;
      const y = bus.y + 40;
      const doorW = bus.doorSize.width;
      const doorH = bus.doorSize.height;

      // Top half: black gradient
      const topHeight = doorH / 1.5;
      const topGradient = ctx.createLinearGradient(0, y, 0, y + topHeight);
      topGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
      topGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
      ctx.fillStyle = topGradient;
      ctx.fillRect(x, y, doorW, topHeight);

      // Bottom half: darker bus body
      const busGradient = ctx.createLinearGradient(
        bus.x - camX,
        bus.y + bus.height,
        bus.x - camX + bus.width,
        bus.y
      );
      for (const stop of gradientStops) {
        busGradient.addColorStop(stop.offset, stop.color);
      }
      ctx.fillStyle = busGradient;
      ctx.fillRect(x, y + topHeight, doorW, doorH / 3);
    });
  }

  // Windows helper
  function drawWindow(win) {
    ctx.save();
    const gradient = ctx.createLinearGradient(0, 0, 0, win.height);
    gradient.addColorStop(0, 'rgba(30, 30, 30, 1)');
    gradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
    ctx.fillStyle = gradient;
    ctx.fillRect(bus.x - camX + win.x, bus.y + win.y, win.width, win.height);
    ctx.restore();
  }

  drawWindow(bus.window);
  drawWindow(bus.window2);

  // Wheels
  bus.wheelOffsets.forEach(offset => {
    ctx.save();
    const wheelX = bus.x - camX + offset;
    const wheelY = bus.y + bus.height;
    ctx.translate(wheelX, wheelY);
    ctx.rotate(bus.wheelAngle);

    const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
    wheelGradient.addColorStop(0, '#393939');
    wheelGradient.addColorStop(0.5, '#242424');
    wheelGradient.addColorStop(1, '#101010');

    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.fillStyle = wheelGradient;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fillStyle = '#999';
    ctx.fill();

    ctx.beginPath();
    ctx.arc(-8, -8, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fill();

    ctx.restore();
  });

  ctx.restore();
}

// Add event listener for spawning AI bus


function drawParallaxLayers(ctx, camX, time = 0) {
  backgroundLayers.forEach(layer => {
    layer.objects.forEach(obj => {
      const screenX = obj.x - camX * layer.speed;
      if (screenX + obj.width < -500 || screenX > canvas.width + 500) return;

      const fogOpacity = 0.1 + layer.speed * 0.3;

      if (obj.type === 'cloud') {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(screenX, obj.y, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      if (obj.type === 'building') {
        if (obj.name) {
          drawNamedBuilding(ctx, obj, time);
        } else if (obj.bType === 'fullGlass') {
          const bg = brightBackdropColors[obj.variant % brightBackdropColors.length];
          ctx.fillStyle = bg;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);

          ctx.fillStyle = `rgba(255,255,255,0.5)`;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
        } else if (obj.bType === 'brand') {
          ctx.fillStyle = '#654321';
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
          ctx.fillStyle = '#00FFFF';
          ctx.fillRect(screenX, obj.y + obj.height / 2 - 10, obj.width, 20);
        } else {
          // Generic building gradient
          const grad = ctx.createLinearGradient(0, obj.y, 0, obj.y + obj.height);
          grad.addColorStop(0, '#222');
          grad.addColorStop(1, '#111');
          ctx.fillStyle = grad;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
        }

        // Universal shadow overlay for depth
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(screenX + obj.width * 0.1, obj.y + obj.height * 0.1, obj.width * 0.8, obj.height * 0.8);

        // Optional building name for unnamed types - skipped here

        ctx.fillStyle = `rgba(255,255,255,${fogOpacity})`;
        ctx.fillRect(screenX, obj.y, obj.width, obj.height);
      }

      if (obj.type === 'tree') {
        ctx.fillStyle = '#5A3A1E';
        ctx.fillRect(screenX + obj.width / 2 - 24, 320, 40, 150);
        const foliageColor = obj.variant === 'special' ? '#66FFC4' : '#3FA';
        ctx.fillStyle = foliageColor;
        ctx.beginPath();
        ctx.arc(screenX + obj.width / 2, 330, obj.width * 0.90, 0, Math.PI * 2);
        ctx.fill();
      }

      if (obj.type === 'car') {
        ctx.fillStyle = '#222';
        ctx.fillRect(screenX, obj.y, obj.width, 20);
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(screenX + 10, obj.y + 20, 5, 0, Math.PI * 2);
        ctx.arc(screenX + obj.width - 10, obj.y + 20, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  });
}

// Generate objects remains mostly the same, with named buildings assigned
function generateParallaxObjects() {
  const groundY = canvas.height - 160;

  backgroundLayers.forEach(layer => {
    layer.objects = [];

    for (let i = 0; i < 100; i++) {
      const x = i * 600 + Math.random() * 200;
      let y = 0, width = 0, height = 0, variant = 0, name = '', type = 'normal';

      if (layer.type === 'building') {
        variant = i;
        width = 100 + Math.random() * 300;
        height = 180 + Math.random() * 320;
        y = canvas.height - 140 - height;

        if (Math.random() < 0.15) {  // Reduced chance for named buildings
          name = namedBuildings[Math.floor(Math.random() * namedBuildings.length)];
        }
        if (Math.random() < 0.2) type = 'fullGlass';
        if (Math.random() < 0.1) type = 'brand';

        layer.objects.push({ x, y, width, height, type: layer.type, variant, bType: type, name });
        continue;
      }

      if (layer.type === 'tree') {
        variant = i % 20 === 0 ? 'special' : Math.floor(Math.random() * 6);
        width = 100 + Math.random() * 30;
        height = 180 + Math.random() * 40;
        y = groundY - height;
      }

      if (layer.type === 'car') {
        width = 70 + Math.random() * 40;
        height = 25;
        y = canvas.height - 100 - height;
      }

      if (layer.type === 'cloud') {
        width = 120 + Math.random() * 100;
        height = 50;
        y = Math.random() * 200 + 40;
      }

      layer.objects.push({ x, y, width, height, type: layer.type, variant });
    }
  });
}
const busPath = [];

generateParallaxObjects();
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'n') {
    night = !night;
  }
});
function drawAICars(ctx) {
  const scale = 1; // scale up the wheels & car body for proportion
    for (const car of aiCars) {
  const baseX = car.x
  const baseY = car.y + 150;

  // --- Draw car body ---
  ctx.save();
  ctx.translate(baseX, baseY);

  // Body outline path inspired by Tesla Model S shape simplified
  ctx.beginPath();

  // Start bottom front curve
  ctx.moveTo(-60 * scale, 0);
  ctx.quadraticCurveTo(-50 * scale, -20 * scale, -30 * scale, -30 * scale); // front curve
  ctx.lineTo(20 * scale, -30 * scale); // flat front bottom to cabin base
  ctx.lineTo(30 * scale, -70 * scale); // rise up to cabin roof start
  ctx.quadraticCurveTo(40 * scale, -90 * scale, 60 * scale, -70 * scale); // cabin roof curve
  ctx.lineTo(80 * scale, -70 * scale); // roof flat top
  ctx.quadraticCurveTo(90 * scale, -70 * scale, 90 * scale, -60 * scale); // roof to rear curve start
  ctx.lineTo(90 * scale, -10 * scale); // down rear
  ctx.quadraticCurveTo(80 * scale, 0, 60 * scale, 0); // rear curve
  ctx.closePath();

  // Fill car body
  const bodyGradient = ctx.createLinearGradient(0, -70 * scale, 0, 0);
  bodyGradient.addColorStop(0, '#0072CE'); // Tesla blue-ish
  bodyGradient.addColorStop(1, '#004A8F'); // Darker shade
  ctx.fillStyle = bodyGradient;
  ctx.fill();

  // --- Draw cabin windows ---
  ctx.beginPath();
  ctx.moveTo(30 * scale, -70 * scale);
  ctx.quadraticCurveTo(40 * scale, -80 * scale, 60 * scale, -70 * scale);
  ctx.lineTo(50 * scale, -40 * scale);
  ctx.lineTo(30 * scale, -40 * scale);
  ctx.closePath();

  ctx.fillStyle = 'rgba(200, 230, 255, 0.7)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(180, 210, 235, 0.9)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // --- Draw wheels ---
  const wheelRadius = 30 * scale;
  const wheelOffsets = [-50 * scale, 70 * scale]; // front and rear wheels x offset relative to car center
  const wheelY = 0;

  wheelOffsets.forEach(offsetX => {
    ctx.save();
    ctx.translate(offsetX, wheelY);

    // Draw wheel outer circle gradient
    const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, wheelRadius);
    wheelGradient.addColorStop(0, '#393939');
    wheelGradient.addColorStop(0.5, '#242424');
    wheelGradient.addColorStop(1, '#101010');
    ctx.beginPath();
    ctx.arc(0, 0, wheelRadius, 0, Math.PI * 2);
    ctx.fillStyle = wheelGradient;
    ctx.fill();

    // Inner wheel circle
    ctx.beginPath();
    ctx.arc(0, 0, wheelRadius * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = '#999';
    ctx.fill();

    // Highlight circle
    ctx.beginPath();
    ctx.arc(-wheelRadius * 0.27, -wheelRadius * 0.27, wheelRadius * 0.2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fill();

    ctx.restore();
  });

  ctx.restore();
}
}


// Toggle spotlight on/off when pressing 'S'
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 's') {
    if (night) {
    spotlightOn = !spotlightOn;
  }}
});
let canSwitchLane = true;

function drawBus() {
  const skygradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
  if (night) {
    skygradient.addColorStop(0, '#0b0c17');  // very dark blue/black
    skygradient.addColorStop(1, '#000000');  // black
  } else {
    skygradient.addColorStop(0, '#87ceeb');  // day sky blue
    skygradient.addColorStop(1, '#b0e0e6');  // lighter blue
  }


  const baseBus = buses[currentBusIndex];
  const bus = { ...baseBus };
  if (vx === 0) {
    bus.y += isLowered ? LOWER_OFFSET : 0;
  }

window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "w" && blockedByCar && canSwitchLane) {
    bus.y += 10;
    canSwitchLane = false;

    // prevent repeated lane switching
    setTimeout(() => (canSwitchLane = true), 300); 
  }
});

  ctx.clearRect(0, 0, canvas.width, canvas.height);

ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
ctx.shadowBlur = 12;

  // Sky
  ctx.fillStyle = skygradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Parallax Background
  drawParallaxLayers(ctx, camX);
// 1. Sidewalk (opposite side)
ctx.fillStyle = '#bbb';
ctx.fillRect(0, canvas.height - 140, canvas.width, 40);

// 2. Perpendicular roads cutting into sidewalk
// 3. Main horizontal road (on top of sidewalk & perp roads)
ctx.fillStyle = '#333';
ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

ctx.strokeStyle = '#FFD700';
ctx.lineWidth = 4;

ctx.beginPath();
ctx.moveTo(0, canvas.height - 85);
ctx.lineTo(canvas.width, canvas.height - 85);
ctx.stroke();

drawAllIntersections(ctx, camX, bus);  // this should draw the perpendicular roads and buildings
  drawAICars(ctx)
// Parameters for highway curve
const highway = {
  baseY: canvas.height - 600,  // vertical position of highway deck
  width: 300,                  // bridge width
  deckHeight: 50,
  baseColor: '#008B8B',        // dark cyan base under road
  deckColor: '#D6BDA3',        // lighter brown deck top
  pillarWidth: 20,
  pillarHeight: 150,
  pillarSpacing: 120,          // distance between pillars along highway
  curveAmplitude: 100,         // horizontal curve amplitude
  curveFrequency: 0.0025,      // curve frequency
  zLayers: 3                   // number of layered decks
};

// Draw highway function, called after drawing bus to overlay it
function drawCurvingHighway(ctx, busX, time) {
  // We'll draw 3 decks stacked with vertical offsets
  for (let layer = 0; layer < highway.zLayers; layer++) {
    const verticalOffset = layer * (highway.deckHeight + 20); // space between decks

    // Draw bridge deck (top)
    // Curve horizontally using sine wave for smooth left-right
    const curveX = x => x + Math.sin(x * highway.curveFrequency + time * 0.002 + layer) * highway.curveAmplitude;

    // Draw highway segments spaced horizontally, centered on bus
    // We draw a range around busX so highway covers canvas width + margin
    const startX = busX - canvas.width / 2 - 500;
    const endX = busX + canvas.width / 2 + 500;

    // Draw base and deck in segments for smooth curve
    for (let x = startX; x < endX; x += highway.width) {
      const cx = curveX(x);

      // Base under road (dark cyan)
      ctx.fillStyle = highway.baseColor;
      ctx.fillRect(cx - highway.width / 2, highway.baseY - verticalOffset, highway.width, 30);

      // Deck (lighter brown)
      ctx.fillStyle = highway.deckColor;
      ctx.fillRect(cx - highway.width / 2 - 10, highway.baseY - verticalOffset - highway.deckHeight, highway.width + 20, highway.deckHeight);

      // Draw pillars under deck
      const pillarCount = Math.floor(highway.width / highway.pillarSpacing) + 1;
      ctx.fillStyle = '#654321'; // dark brown pillars
      for (let p = 0; p < pillarCount; p++) {
        const pillarX = cx - highway.width / 2 + p * highway.pillarSpacing;
        ctx.fillRect(pillarX, highway.baseY - verticalOffset + 30, highway.pillarWidth, highway.pillarHeight);
      }
    }
  }
}

  // Draw signal signs
  drawSignalSigns(ctx, camX, canvas.width);
// Draw bridge columns and bridge structure
for (const bridge of bridges) {
  const screenX = bridge.x - bus.x + canvas.width / 2;

  // Wide dark cyan base under the road
  ctx.fillStyle = '#008B8B'; // dark cyan
  ctx.fillRect(screenX - 160, canvas.height - 585, 300, 30);

  // Layered 2D "z-style" deck (brown, sits on top)
  ctx.fillStyle = '#D6BDA3'; // lighter brown bridge top
  ctx.fillRect(screenX - 170, canvas.height - 625, 320, 50);

  // Wide dark cyan base under the road
  ctx.fillStyle = '#008B8B'; // dark cyan
  ctx.fillRect(screenX + 190, canvas.height - 585, 300, 30);

  // Layered 2D "z-style" deck (brown, sits on top)
  ctx.fillStyle = '#D6BDA3'; // lighter brown bridge top
  ctx.fillRect(screenX + 180, canvas.height - 625, 320, 50);

}


ctx.save();
// Apply tilt
 const busGradient = ctx.createLinearGradient(
  bus.x - camX,
  bus.y + bus.height,
  bus.x - camX + bus.width,
  bus.y
);
if (currentBusIndex === 2) {
  ctx.save();

  // Flip vertically around a horizontal axis at Y = flipY
  const flipY = bus.y + 20;
  ctx.translate(0, flipY);
  ctx.scale(1, -1);

  // Calculate drawing origin
  const startX = bus.x - camX + bus.width - 470;
  const startY = 10;

  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(startX, startY + 40);
  ctx.lineTo(startX + 370, startY + 40);
  ctx.quadraticCurveTo(startX + 420, startY + 40, startX + 420, startY);
  ctx.lineTo(startX + 300, startY);
  ctx.lineTo(startX, startY);
  ctx.closePath();

  // === Fill style logic ===
  const useGradient = true; // 🔁 Change to false if you want solidColor

  if (useGradient) {
    const curveGradient = ctx.createLinearGradient(
      bus.x - camX,
      bus.y + bus.height,
      bus.x - camX + bus.width,
      bus.y
    );
    for (const stop of gradientStops) {
      curveGradient.addColorStop(stop.offset, stop.color);
    }
    ctx.fillStyle = curveGradient;
  } else {
    const solidColor = '#444'; //  Replace this if you want a different solid color
    ctx.fillStyle = solidColor;
  }

  ctx.fill();
  ctx.restore();
}
  for (const stop of gradientStops) {
    busGradient.addColorStop(stop.offset, stop.color);
  }

ctx.translate(bus.x - camX + bus.width / 2, bus.y + bus.height / 2);
ctx.rotate(tilt * Math.PI / 180);
ctx.translate(-(bus.x - camX + bus.width / 2), -(bus.y + bus.height / 2));

const leftX = bus.x - camX;
const rightX = leftX + bus.width;
const topY = bus.y;
const bottomY = bus.y + bus.height;
const curveStartY = topY + bus.height * 0.0;
const curveEndY = topY + bus.height * 0.59;
const ctrlOffset = 30;
if (currentBusIndex === 1) {

const flipY = bus.y + 20;
const startX = bus.x - camX + bus.width - 417;
const startY = 20;

ctx.save();

ctx.translate(0, flipY);
ctx.scale(1, -1); // Flip vertically

ctx.beginPath();

// Vertical line down (originally 60 px tall, now 42 px)
ctx.moveTo(startX - 50, startY);
ctx.lineTo(startX - 50, startY + 42);

// Adjusted horizontal line length and curve details
const totalHorizontalLength = 102.4 * 1.3; // 133 px

const lineStartX = startX - 50;
const lineY = startY + 42;

// Break down horizontal length into parts
const part1Length = totalHorizontalLength * 0.8;  // 40% straight
const part2Length = totalHorizontalLength * 0.2;  // 20% curved down 10 px
const part3Length = totalHorizontalLength * 0.8;  // 40% straight again

// Part 1: straight horizontal line (40%)
ctx.lineTo(lineStartX + part1Length, lineY);

// Part 2: curve down 10px with quadratic curve (20%)
const curveControlX = lineStartX + part1Length + 30;
const curveControlY = lineY + 10;
const curveEndX = lineStartX + part1Length + part2Length - 0;
const curveEndY = lineY + 10;

ctx.quadraticCurveTo(curveControlX, curveControlY, curveEndX, curveEndY);

// Part 3: straight horizontal line (40%) from curve end to total length, 10 px lower
ctx.lineTo(lineStartX + totalHorizontalLength, lineY + 10);

// Diagonal line \ with length scaled proportionally to vertical height

const angleDeg = 75;
const angleRad = angleDeg * Math.PI / 180;

// Original length was 30, scaled 1.5 = 45 px for 60 px height
// New length scales proportionally: 45 * (42 / 60) = 31.5 px approx
const length = 30 * 1.5 * (42 / 60); // ~31.5 px

const dx = Math.cos(angleRad) * length;
const dy = Math.sin(angleRad) * length;

ctx.lineTo(startX + dx, startY + 59 + dy);

// Close shape top, scale closing length horizontally
ctx.lineTo(startX + 170 * 1.1, startY); // 169 px
ctx.lineTo(startX, startY);

ctx.closePath();

ctx.fillStyle = 'rgba(211, 211, 211, 1)';
ctx.fill();

ctx.restore();
}
// Length of the bottom-right diagonal (studle)
const studleHeight = 10;
const studleAngleX = 45; // small inward angle

ctx.beginPath();
ctx.moveTo(leftX, topY);
ctx.lineTo(leftX, bottomY);

// Draw bottom edge to before studle
ctx.lineTo(rightX - studleAngleX + 40, bottomY);

// Add upward diagonal studle
ctx.lineTo(rightX, bottomY - studleHeight);

// Draw up-right curve
ctx.lineTo(rightX, curveEndY);
ctx.bezierCurveTo(
  rightX, curveStartY,
  rightX - ctrlOffset, topY,
  rightX - 65 - ctrlOffset, topY
);

// Flat roof back to front
ctx.lineTo(leftX, topY);
ctx.closePath();

ctx.fillStyle = busGradient;
ctx.fill();
ctx.restore();

  // --- Doors ---
  // === 1. UNIVERSAL DOOR GRADIENT DRAWING ===
ctx.save();

// Door gradient
const doorGradient = ctx.createLinearGradient(0, 0, 0, bus.doorSize.height);
doorGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
doorGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
ctx.fillStyle = doorGradient;

buses[currentBusIndex].doorPositions.forEach(doorX => {
  // Skip door 430 if it's bus 2 (we’ll draw that separately with curve)
  if (currentBusIndex === 2 && doorX === 430) return;

  const x = bus.x - camX + doorX;
  const y = bus.y + 40;
  const doorW = bus.doorSize.width;
  const doorH = bus.doorSize.height;

  ctx.fillRect(x, y, doorW, doorH);
});


ctx.restore();

// === 2. SPECIAL CURVED DOOR FOR BUS 2 ===
if (currentBusIndex === 2) {
  const doorX = 430;
  const x = bus.x - camX + doorX + 20;
  const y = bus.y + 40;
  const doorW = bus.doorSize.width - 20;
  const doorH = bus.doorSize.height;

  ctx.save();
  ctx.translate(0, y + doorH);
  ctx.scale(1, -1); // Flip over X-axis
  ctx.fillStyle = doorGradient; // use the same gradient

  ctx.beginPath();
  ctx.moveTo(x, 0);
  ctx.lineTo(x, doorH);
  ctx.lineTo(x + doorW - 10, doorH);
  ctx.quadraticCurveTo(
    x + doorW, doorH,
    x + doorW, doorH - 100
  );
  ctx.lineTo(x + doorW, 0);
  ctx.closePath();

  ctx.fill();


  ctx.restore();
}
if (currentBusIndex === 1) {{
const flipY = bus.y + 20;
ctx.translate(0, flipY);
ctx.scale(1, -1);

const startX = bus.x - camX + bus.width - 35;
const startY = -120;

ctx.beginPath();
ctx.moveTo(startX, startY);
ctx.lineTo(startX, startY + 100);

// Make horizontal segment shorter (e.g., 220px instead of 370)
ctx.lineTo(startX + 0, startY + 100);

// Adjust curve control point (was +440)
ctx.quadraticCurveTo(
  startX + 30, // control X
  startY + 100,  // control Y
  startX + 30, // end X
  startY + 0    // end Y
);

// Adjust closing top line (was +300)
ctx.lineTo(startX + 10, startY);
ctx.lineTo(startX, startY);
ctx.closePath();

ctx.fillStyle = 'rgba(30, 30, 30, 1)';
ctx.fill();

ctx.restore();
}
}

drawBackDoors(bus);
  // --- Windows ---
  function drawWindow(window) {
    ctx.save();
    const gradient = ctx.createLinearGradient(0, 0, 0, window.height);
    gradient.addColorStop(0, 'rgba(30, 30, 30, 1)');
    gradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
    ctx.fillStyle = gradient;
    ctx.fillRect(bus.x - camX + window.x, bus.y + window.y, window.width, window.height);
  }

  drawWindow(bus.window);
  drawWindow(bus.window2);



  // --- Fuel Pickups ---
  fuelPickups.forEach(pickup => {
    if (!pickup.collected) {
      ctx.fillStyle = 'orange';
      ctx.fillRect(pickup.x - bus.x + canvas.width / 2 - 10, 400, 20, 20);
    }
  });
ctx.restore();
  // --- Wheels ---
  const wheelOffsetY = tilt * 0.2;
  bus.wheelOffsets.forEach(offset => {
    ctx.save();
    const wheelX = bus.x - camX + offset;
    let wheelY = bus.y + bus.height + wheelOffsetY;
    if (driverLocked) {
      wheelY = wheelY - 10
    }
    ctx.translate(wheelX, wheelY);
    ctx.rotate(bus.wheelAngle);

    const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
    wheelGradient.addColorStop(0, '#393939');
    wheelGradient.addColorStop(0.5, '#242424');
    wheelGradient.addColorStop(1, '#101010');

    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.fillStyle = wheelGradient;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fillStyle = '#999';
    ctx.fill();

    ctx.save();
    ctx.translate(-8, -8);
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fill();
    ctx.restore();

    ctx.restore();
    drawTrainTrafficLights(ctx, camX, canvas.width);

  });
aiBuses.forEach(aiBus => drawAIBuses(aiBus, aiBus.typeIndex));

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'v' && !spawning) {
    spawnIndex = 0;
    spawning = true;

    const interval = setInterval(() => {
      spawnAICar(spawnIndex * 600 + bus.x + 1000, bus.y);
      spawnIndex++;

      if (spawnIndex >= 10) {
        clearInterval(interval);
        spawning = false;
      }
    }, 300); // Adjust delay between spawns (milliseconds)
  }
});



  for (const stop of stops) {
  if (stop.isStation && stop.x > bus.x - 2000) {
    drawTransitStation(ctx, stop.x, camX);
  }
}
for (const bridge of bridges) {
  const screenX = bridge.x - bus.x + canvas.width / 2;
  
  // Bridge columns and top rectangle
  ctx.fillStyle = '#CAB298'; // dark brown column
  ctx.fillRect(screenX - 55, 100, 100, 450);

  ctx.fillStyle = '#CAB298'; // dark brown column
  ctx.fillRect(screenX + 295, 100, 100, 450);

  ctx.fillStyle = '#CAB298'; // dark brown top rectangle
  ctx.fillRect(screenX - 125, 40, 590, 100);
}
// Full width brown bar at bottom, fixed to screen width

const barY = 550;
const barHeight = 100;
const barX = 0;
const barWidth = canvas.width;  // Full canvas width

ctx.fillStyle = '#999'; // dark brown bar color
ctx.fillRect(barX, barY, barWidth, barHeight);

// Labels and their glow colors
const labels = [
  { label: 'Stop Nearby', active: distance < 1000, glowColor: 'rgba(100, 150, 255, 0.7', circleColor: '#337BFF' },           
  {label: 'Stop Requested', active: pendingDropRequest, glowColor: 'rgba(255, 165, 0, 0.8)', circleColor: '#FFA500' },
  { label: 'Air Brakes', active: braking, glowColor: 'rgba(163, 217, 165, 0.8)', circleColor: '#A3D9A5' },
  { label: 'Stopped', active: vx === 0, glowColor: 'rgba(221, 0, 0, 0.7)', circleColor: '#DD0000' }                    
];

ctx.font = '10px Arial';
ctx.textAlign = 'center';

// Vertical positions for text (label above, status below)
const labelY = barY + 10;
const statusY = barY + 25;
const panelX = 35
const panelY = statusY + 85
// Horizontal spacing
const segmentWidth = barWidth / labels.length;

labels.forEach((item, i) => {
  const centerX = segmentWidth * i + segmentWidth / 2;

  // Label text (smaller, above)
  ctx.fillStyle = '#ccc';
  ctx.fillText(item.label, centerX, labelY);

  // Status indicator: circle with glow if active, gray if not
  ctx.save();
  if (item.active) {
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowColor = item.glowColor;
    ctx.shadowBlur = 18;
    ctx.fillStyle = item.circleColor;
  } else {
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#888'; // gray when off
  }

  ctx.beginPath();
  ctx.arc(centerX, statusY, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  // Reset font to default for next iteration
  ctx.font = '10px Arial';
});



  const now = performance.now();
  const deltaTime = now - lastDrawTime;
  
  lastDrawTime = now;
  drawTrainTrafficLights(ctx, camX, canvas.width);
  updateTrafficLights(deltaTime)
  updateTrainTrafficLights(deltaTime);
  drawTracks(ctx);
  xB = bus.x

  checkTrafficLightViolations(bus);
  drawTrafficLights(ctx, camX);  
// Call this every frame, passing deltaTime in milliseconds

// --- Draw Stops ---
for (const stop of stops) {
  if (!stop.collected) {
    const screenX = stop.x - camX;
    const stopY = window.innerHeight * 0.5;

    // Outer glow (different for special stops)
    ctx.beginPath();
    ctx.arc(screenX, stopY, STOP_RADIUS + 10, 0, Math.PI * 2);
    ctx.fillStyle = stop.special
      ? 'rgba(128, 128, 128, 0.4)'
      : 'rgba(100, 150, 255, 0.3)';
    ctx.fill();

    // Inner circle
    ctx.beginPath();
    ctx.arc(screenX, stopY, STOP_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = stop.special ? '#888' : '#337BFF';
    ctx.fill();
  }
}
for (const stop of stops) {
  if (!stop.collected && vx === 0 && Math.abs(bus.x - stop.x) < STOP_DETECTION_RANGE) {
    
    // Special stop check
    if (stop.special && !driverLocked) continue;

    stop.collected = true;

    // Passenger logic
    const newPassengers = Math.floor(Math.random() * 2 + 2); // 2–3
    const dropOff = Math.floor(Math.random() * 2 + 2);       // 2–3
    const basePoints = newPassengers;
    const multiplier = stop.special ? 3 : 1;
    const actualPoints = basePoints * multiplier;

    if (passengersOnBoard < 16) {
      passengersOnBoard += newPassengers;
      points += actualPoints;
      savePoints();
    } else {
      passengersOnBoard -= 6;
    }

    if (passengersOnBoard >= 4) {
      passengersOnBoard = Math.max(passengersOnBoard - dropOff, 0);
    }

    // Clear drop request
    if (nextStopRequest && stop.x >= bus.x) {
      pendingDropRequest = false;
      nextStopRequest = null;
    }
ctx.fillText(`Passengers: ${newPassengers}`, 10, canvas.height - 35);
ctx.fillText(`Stop Requested: ${pendingDropRequest ? "Yes" : "No"}`, 10, canvas.height - 20);

    // Save stop event to history
    saveStopHistoryEntry({
      x: (distance2) * 2,
      time: Date.now(),
      special: stop.special,
      passengersAdded: newPassengers,
      passengersDropped: dropOff,
      pointsGained: actualPoints
    });

    break;
  }
}
const stopNoticeDiv = document.getElementById('stopNotice');

for (const stop of stops) {
  if (!stop.collected && stop.x > bus.x) {
    distance = Math.floor((stop.x - bus.x) / 2);

    break;
  }
}


ctx.fillStyle = '#f0f0f0';
ctx.strokeStyle = '#333';
ctx.lineWidth = 2;
ctx.fillRect(panelX, panelY, 180, 190);
ctx.strokeRect(panelX, panelY, 180, 190);


labels.forEach((item, i) => {
  const boxY = panelY + 10 + i * 45;

  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;

  ctx.fillStyle = item.color;
  ctx.beginPath();
  ctx.moveTo(panelX + 16, boxY);
  ctx.lineTo(panelX + 34, boxY);
  ctx.quadraticCurveTo(panelX + 40, boxY, panelX + 40, boxY + 6);
  ctx.lineTo(panelX + 40, boxY + 18);
  ctx.quadraticCurveTo(panelX + 40, boxY + 24, panelX + 34, boxY + 24);
  ctx.lineTo(panelX + 16, boxY + 24);
  ctx.quadraticCurveTo(panelX + 10, boxY + 24, panelX + 10, boxY + 18);
  ctx.lineTo(panelX + 10, boxY + 6);
  ctx.quadraticCurveTo(panelX + 10, boxY, panelX + 16, boxY);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  ctx.fillStyle = 'black';
  ctx.font = '12px Arial';
  ctx.fillText(item.label, panelX + 60, boxY + 18);
});


// --- Request Drop at Future Stop ---
if (passengersOnBoard > 0 && !pendingDropRequest) {
  pendingDropRequest = true;
  nextStopRequest = stops.find(stop => stop.x > bus.x && !stop.collected);
}

// --- Highlight Requested Stop ---
if (pendingDropRequest && nextStopRequest) {
  const screenX = nextStopRequest.x - camX;
  ctx.beginPath();
  ctx.arc(screenX, window.innerHeight * 0.5, STOP_RADIUS + 10, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 220, 0, 0.6)';
  ctx.fill();
}

if (flashAlpha > 0) {
  ctx.save();
  ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  flashAlpha -= 0.1; // Decrease transparency
  if (flashAlpha < 0) flashAlpha = 0;
}

drawTrains(ctx);
  if (night && !spotlightOn) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.99)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
if (spotlightOn) {
  // Dark overlay over whole canvas (more opaque)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';  // dark shadow over everything
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Create a linear gradient for the spotlight light cone
  const busScreenX = bus.x - camX + canvas.width / 2 + 50; 
  const busScreenY = 430

  const coneLength = 500;
  const coneBaseWidth = 1200;
  const coneTipWidth = 10;

  // Create gradient along the cone's axis
  let gradient = ctx.createLinearGradient(busScreenX, busScreenY, busScreenX + coneLength, busScreenY);

  // Gradient stops - from almost transparent light to full shadow
  gradient.addColorStop(0, 'rgba(0,0,0,0)');    // fully transparent at the tip of bus
  gradient.addColorStop(0.2, 'rgba(127,127,127,0.1)');
  gradient.addColorStop(0.6, 'rgba(255,255,255,0.1)');
  gradient.addColorStop(1, 'rgba(127,127,127,0.1)');

  // Save current context and clip to cone shape
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(busScreenX, busScreenY - coneTipWidth / 2);
  ctx.lineTo(busScreenX + coneLength, busScreenY - coneBaseWidth / 2);
  ctx.lineTo(busScreenX + coneLength, busScreenY + coneBaseWidth / 2);
  ctx.lineTo(busScreenX, busScreenY + coneTipWidth / 2);
  ctx.closePath();

  ctx.clip();

  // Draw the gradient inside the cone shape
  ctx.fillStyle = gradient;
  ctx.fillRect(busScreenX, busScreenY - coneBaseWidth / 2, coneLength, coneBaseWidth);

  ctx.restore();

}
  drawTrafficLights(ctx, camX);  
  if (debugMode) {
  ctx.strokeStyle = 'lime';
  ctx.strokeRect(bus.x - camX, bus.y, bus.width, bus.height);
}
if (debugMode) {
  ctx.fillStyle = 'white';
  ctx.font = '14px monospace';
  ctx.fillText(`Bus X: ${bus.x.toFixed(0)}`, 10, 20);
  ctx.fillText(`Cam X: ${camX.toFixed(0)}`, 10, 40);
}
if (debugMode) {
  stops.forEach(stop => {
    ctx.fillStyle = stop.special ? 'yellow' : 'orange';
    ctx.fillRect(stop.x - camX, canvas.height - 110, 10, 10);
  });
}
  if (!debugMode) return;
  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  for (let x = -camX % 100; x < canvas.width; x += 100) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  if (debugMode) {
  const nextStop = stops.find(s => s.x > bus.x && !s.collected);
  if (nextStop) {
    ctx.fillStyle = '#ff0';
    ctx.fillText('Next Stop →', nextStop.x - camX, bus.y - 50);
  }
}

  trackSpeed()
  drawSpeedGraph()
  let frameTimeColor = 'green';
if (deltaTime > 33) frameTimeColor = 'red';
else if (deltaTime > 16) frameTimeColor = 'yellow';

ctx.fillStyle = frameTimeColor;
ctx.fillRect(canvas.width - 60, 0, 50, 10);
ctx.fillStyle = '#fff';
ctx.font = '10px monospace';
ctx.fillText(`${Math.round(deltaTime)}ms`, canvas.width - 55, 0);
}
let speedHistory = [];
function trackSpeed() {
  speedHistory.push(vx);
  if (speedHistory.length > 100) speedHistory.shift();
}
function drawSpeedGraph() {
  if (!debugMode || speedHistory.length < 2) return;

  const graphWidth = 200;
  const graphHeight = 100;
  const graphX = canvas.width - graphWidth - 10;
  const graphY = canvas.height - graphHeight - 10;

  // Draw background box
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(graphX, graphY, graphWidth, graphHeight);

  // Draw border
  ctx.strokeStyle = '#00ffff';
  ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);

  // Draw graph line
  ctx.beginPath();
  ctx.strokeStyle = '#00ffff';
  for (let i = 0; i < speedHistory.length; i++) {
    const x = graphX + (i / speedHistory.length) * graphWidth;
    const y = graphY + graphHeight - (speedHistory[i] * 3); // Scale speed visually
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Draw labels
  ctx.fillStyle = '#ffffff';
  ctx.font = '10px monospace';
  ctx.fillText('Speed', graphX + 5, graphY + 10);
  ctx.fillText(`vx: ${vx.toFixed(2)}`, graphX + 5, graphY + graphHeight - 3);
}


drawBus()
  // Listen for keys to switch bus
  window.addEventListener('keydown', e => {
    if (e.key === '1') {
      currentBusIndex = 0;
      info.textContent = "Current: Gillig 29'";
      currentSystem === "A"
      acceleration = 0.011
      drawBus();
    } else if (e.key === '2') {
      currentBusIndex = 1;
      info.textContent = "Current: Gillig 40 HEV'";
      currentSystem === "C"
      acceleration = 0.1
      drawBus();
    } else if (e.key === '3') {
      currentBusIndex = 2;
      info.textContent = "Current: New Flyer Xcelsior 40'";
      currentSystem === "B"
      acceleration = 0.011
      drawBus();
    }
  });
  let highFriction = false;
function drawBackDoors(bus) {
  if (!bus.backDoorPositions) return;

  bus.backDoorPositions.forEach(doorX => {
    const x = bus.x - camX + doorX;
    const y = bus.y + 40;
    const doorW = bus.doorSize.width;
    const doorH = bus.doorSize.height;

    // Top Half: Black gradient
    const topHeight = doorH / 1.5;
    const topGradient = ctx.createLinearGradient(0, y, 0, y + topHeight);
    topGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
    topGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
    ctx.fillStyle = topGradient;
    ctx.fillRect(x, y, doorW, topHeight);

    // Bottom Half: Darker than bus body
    const busGradient = ctx.createLinearGradient(
      bus.x - camX,
      bus.y + bus.height,
      bus.x - camX + bus.width,
      bus.y
    );

    for (const stop of gradientStops) {
      busGradient.addColorStop(stop.offset, stop.color);
    }

    ctx.fillStyle = busGradient;
    ctx.fillRect(x, y + topHeight, doorW, doorH / 3);
  });


}// ==== GLOBALS ====

let lastTimestamp = performance.now();



// Signal signs globals

// ==== FUNCTIONS ====

// Traffic Lights Generation and Update (unchanged from before)

function drawTrafficLights(ctx, camX, canvasWidth) {
  const y = 520;

  trafficLights.forEach(light => {
    const x = light.x - camX;
    if (x < -100 || x > canvasWidth + 100) return;

    const color = lightColors[light.state] || "#00ff00";

    ctx.beginPath();
    ctx.arc(x, y, lightRadius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  });
}

// Signal signs generation and cleanup
function updateSignalSigns(bus, canvasWidth) {
  const busX = bus.x;

  // Remove signs far behind the bus
  for (let i = signalSigns.length - 1; i >= 0; i--) {
    if (signalSigns[i].x < busX - 300) {
      signalSigns.splice(i, 1);
    }
  }

  // Add new signs ahead if fewer than maxSigns
  while (signalSigns.length < maxSigns) {
    let nextLight = null;
    for (let light of trafficLights) {
      if (light.x > busX + 100) {
        const hasSign = signalSigns.some(sign => 
          Math.abs(sign.x - (light.x - 100)) < 10 || 
          Math.abs(sign.x - (light.x - 2000)) < 10
        );
        if (!hasSign) {
          nextLight = light;
          break;
        }
      }
    }
    if (!nextLight) break;

    const possibleOffsets = [500, 1000].filter(offset => 
      !signalSigns.some(sign => Math.abs(sign.x - (nextLight.x - offset)) < 10)
    );
    if (possibleOffsets.length === 0) break;

    const offset = possibleOffsets[Math.floor(Math.random() * possibleOffsets.length)];
    const signX = nextLight.x - offset;

    if (signX > busX - 1000) {
      signalSigns.push({ x: signX, distance: offset });
    } else {
      break;
    }
  }
}

// Draw signal signs on canvas
function drawSignalSigns(ctx, camX, canvasWidth) {
  const boxColor = "#1abf00";
  const textColor = "#fff";
  const boxWidth = 110;
  const boxHeight = 30;

  signalSigns.forEach(sign => {
    const x = sign.x - camX;
    const y = 150;

    if (x < -100 || x > canvasWidth + 100) return;


    // Sign box
    ctx.fillStyle = boxColor;
    ctx.fillRect(x - boxWidth / 2, y - boxHeight, boxWidth, boxHeight);

    // Text
    ctx.fillStyle = textColor;
    ctx.font = "bold 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("NEXT SIGNAL", x, y - boxHeight + 12);
    ctx.fillText(`${sign.distance}px`, x, y - boxHeight + 25);
  });
}
function showStopHistory() {
  const history = JSON.parse(localStorage.getItem("stopHistory") || "[]");
  const display = document.getElementById("stopHistoryDisplay");

  if (!history.length) {
    display.innerHTML = "<div class='entry empty'>No stop history yet.</div>";
    return;
  }

  display.innerHTML = history.map((entry, index) => {
    const date = new Date(entry.time).toLocaleString();
    return `
      <div class="entry">
        <div class="entry-header">#${index + 1} • ${entry.special ? "Kneeling" : "Standard"}</div>
        <div class="entry-body">
          <div><strong>Time:</strong> ${date}</div>
          <div><strong>Stop Position:</strong> ${entry.x}px</div>
          <div><strong>Passengers:</strong> +${entry.passengersAdded}, -${entry.passengersDropped}</div>
          <div><strong>Points:</strong> +${entry.pointsGained}</div>
        </div>
      </div>
    `;
  }).join('');
}

function checkTrafficLightViolations(bus) {
  for (let light of trafficLights) {
    if (light.state === 2) { // Red light
      const dx = bus.x - light.x;

      if (Math.abs(dx) < 100 && bus.vx > 0.1 && !light.violated) {
        points -= 10;
savePoints()
        console.log("Violation! -10 Points. Points now:", points);
        light.violated = true;

        // Trigger flash
        flashAlpha = 1;
        flashTimer = 10; // Frames to fade out
      }

      if (Math.abs(dx) > 200) {
        light.violated = false;
      }
    }
  }
}

function updateViolationMessage(deltaTime) {
  if (violationMessageTimer > 0) {
    violationMessageTimer -= deltaTime;
    if (violationMessageTimer < 0) violationMessageTimer = 0;
  }
}

function drawViolationMessage(ctx) {
  if (violationMessageTimer > 0) {
    ctx.fillStyle = "red";
    ctx.font = "bold 24px Arial";
    ctx.fillText("TRAFFIC VIOLATION!", 300, 50);
  }
}
let key8Pressed = false;
let key9Pressed = false;
window.addEventListener('keydown', (e) => {
  if (e.key === '8') key8Pressed = true;
  if (e.key === '9') key9Pressed = true;
});

window.addEventListener('keyup', (e) => {
  if (e.key === '8') key8Pressed = false;
  if (e.key === '9') key9Pressed = false;
});
let blockedByCar = false;

function checkBusBlockedByCars() {
  blockedByCar = false;

  for (const car of aiCars) {
    const dx = car.x - bus.x;
    const dy = car.y - bus.y;

    if (car.stuck && dx > 0 && dx < 100 && Math.abs(dy) < 10) {
      blockedByCar = true;
      break;
    }
  }
}
let t = true
function animate(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp; // initialize first frame
  const deltaTime = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  const bus = buses[currentBusIndex];

  if (!driverLocked) {
    if (accelerating) {
      vx += acceleration;
      if (vx > maxSpeed) vx = maxSpeed;
    } else {
      if (vx < 0.1) {
        vx = 0;
        braking = false;
        if (currentBusIndex === 1) {
          acceleration = 0.1;
        } else {
          acceleration = 0.07;
        }
      }
      if (braking) {
        vx *= 0.981233;
      } else {
        vx *= 0.9999;
      }
    }
  } else {
    vx = 0;
  }
  if (vx > maxSpeed) vx = maxSpeed;
if (t) {

// === Assign player offset ===
scheduleOffsets.set(bus, 0);
t = false
}
  bus.vx = vx;
  if (!blockedByCar) {
    bus.x += bus.vx;
  }
  bus.wheelAngle += bus.vx / 22.5;

  if (freeCam) {
    if (key8Pressed) freeCamX -= 10; // Move left
    if (key9Pressed) freeCamX += 10; // Move right
    camX = freeCamX;
  } else {
    if (Math.abs(camFollowX - bus.x) > 100) {
      camX = bus.x - 100;
      camFollowX = bus.x;
      delayTimer = 0;
    } else {
      delayTimer++;
      if (delayTimer > 120) {
        camFollowX = bus.x;
        camX += (camFollowX - camX) * 0.05;
      }
    }
  }

  checkTrainSpawn(bus);

  const trainApproaching = trains.some(train =>
    trainTracks.some(track =>
      Math.abs(train.worldX - track.x) < 100
    )
  );

  generateTrainTrafficLights(bus.x);
  updateTrainTrafficLights(deltaTime);

  generateTracksUpTo(bus.x + 100000); // Generate tracks 100k ahead of bus
  checkTrainSpawn(bus);
  updateAICars(bus);
  updateTrainTrafficLights(deltaTime);
  busPath.push({ x: bus.x, y: bus.y });
  updateLatenessUI(bus);
  generateTrafficLights(bus.x);
  updateTrafficLights(deltaTime);
  updateSignalSigns(bus, ctx.canvas.width);
  drawMinimap(bus, camX);
  updateAIBuses(deltaTime, bus);

  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  // Remove or comment out if playerBus is const
  // playerBus = bus;

  updateLatenessUI(bus);
  if (stop.collected) {
  stop.regenTime = performance.now() + STOP_REGEN_MIN + Math.random() * (STOP_REGEN_MAX - STOP_REGEN_MIN);
    updateStops(deltaTime);
  }
  drawBus();
  drawTrafficLights(ctx, camX, ctx.canvas.width);
  drawSignalSigns(ctx, camX, ctx.canvas.width);

  checkTrafficLightViolations(bus);
  updateViolationMessage(deltaTime);
  drawViolationMessage(ctx);

  if (braking) {
    accelerating = false;
  }

  document.getElementById("pointsDisplay").innerText = "Points: " + points;

  requestAnimationFrame(animate);
}

  // Initial bits, default to 0s
  let bits = Array(8).fill(0);

  // Focused bit index (for arrows)
  let focusedIndex = 0;

  const bitDisplay = document.getElementById("bitDisplay");
  const statusEl = document.getElementById("status");

  // Command map as before
  const binaryCommandMap = {
    "01101101": () => articulated = !articulated,
  };

  // Render bits visually
  function renderBits() {
    bitDisplay.innerHTML = "";
    bits.forEach((bit, i) => {
      const span = document.createElement("span");
      span.textContent = bit;
      span.style.cursor = "pointer";
      span.style.padding = "5px 10px";
      span.style.border = "2px solid";
      span.style.borderColor = (i === focusedIndex) ? "yellow" : "white";
      span.style.borderRadius = "4px";
      span.style.userSelect = "none";
      span.style.fontWeight = "bold";
      span.style.fontSize = "1.5em";
      span.style.backgroundColor = bit ? "#0a7" : "#333";
      span.style.color = bit ? "black" : "white";

      // Toggle bit on click
      span.addEventListener("click", () => {
        bits[i] = bits[i] === 0 ? 1 : 0;
        renderBits();
      });

      bitDisplay.appendChild(span);
    });
  }

  // Arrow button handlers
  document.getElementById("leftArrow").addEventListener("click", () => {
    focusedIndex = (focusedIndex - 1 + bits.length) % bits.length;
    renderBits();
  });

  document.getElementById("rightArrow").addEventListener("click", () => {
    focusedIndex = (focusedIndex + 1) % bits.length;
    renderBits();
  });

  // Execute button handler
  document.getElementById("executeBtn").addEventListener("click", () => {
    const binaryStr = bits.join("");
    const command = binaryCommandMap[binaryStr];
    if (command) {
      command();
      alert(`Command for ${binaryStr} executed!`);
    } else {
      alert(`No command found for ${binaryStr}`);
    }
  });

  // Initial render and status
  renderBits();

  const routeInput = document.getElementById("routeNumber");
  const translationCheck = document.getElementById("translationCheck");
  const rSlider = document.getElementById("rSlider");
  const gSlider = document.getElementById("gSlider");
  const bSlider = document.getElementById("bSlider");
  const routePreview = document.getElementById("routePreview");
  const translationText = document.getElementById("translationText");

  const panel = document.getElementById("busRoutePanel");
  const toggleBtn = document.getElementById("busRoutePanelToggle");

  // Toggle panel visibility
  toggleBtn.addEventListener("click", () => {
    if (panel.hasAttribute("hidden")) {
      panel.removeAttribute("hidden");
      toggleBtn.textContent = "▼ Route Editor";
      toggleBtn.setAttribute("aria-expanded", "true");
    } else {
      panel.setAttribute("hidden", "");
      toggleBtn.textContent = "► Route Editor";
      toggleBtn.setAttribute("aria-expanded", "false");
    }
  });

  // Convert number 101-126 to letters A-Z
  function translateNumberToLetter(num) {
    if (num < 101 || num > 126) return null;
    return String.fromCharCode(65 + (num - 101)); // 65 = 'A'
  }

  function updateDisplay() {
    let val = routeInput.value.replace(/\D/g, ""); // digits only
    if (val.length === 0) {
      routePreview.textContent = "---";
      translationText.textContent = "";
      return;
    }
    let num = Math.min(Math.max(parseInt(val, 10), 0), 999);
    routeInput.value = num.toString();

    if (translationCheck.checked) {
      let letter = translateNumberToLetter(num);
      if (letter) {
        routePreview.textContent = letter;
        translationText.textContent = `Translated from ${num}`;
      } else {
        routePreview.textContent = num;
        translationText.textContent = "";
      }
    } else {
      routePreview.textContent = num;
      translationText.textContent = "";
    }

    // Update preview color
    routePreview.style.color = `rgb(${rSlider.value},${gSlider.value},${bSlider.value})`;
  }

  // Update on all input changes
  routeInput.addEventListener("input", updateDisplay);
  translationCheck.addEventListener("change", updateDisplay);
  rSlider.addEventListener("input", updateDisplay);
  gSlider.addEventListener("input", updateDisplay);
  bSlider.addEventListener("input", updateDisplay);

  // Initial display update
  updateDisplay();
animate();
</script>
