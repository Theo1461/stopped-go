<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bus Visual Canvas - Multiple Buses</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(to bottom right, #dce1e9, #f2f4f7);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #app {
      transform: scale(0.67);
      transform-origin: center center;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    canvas {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      backdrop-filter: blur(20px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
      border: none;
    }

    #controls {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 20px;
    }

    #controls button,
    #info,
    #vxDisplay,
    #passengerCount,
    #speedDistance,
    #stopNotice,
    #pointsDisplay,
    #stopHistoryDisplay {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      border-radius: 16px;
      backdrop-filter: blur(18px);
      background: rgba(255, 255, 255, 0.2);
      color: #222;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      padding: 10px 14px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      user-select: none;
    }

    #speedDistance,
    #pointsDisplay,
    #stopNotice {
      background: rgba(255, 255, 255, 0.25);
      color: #000;
      font-weight: 600;
    }

    #info {
      font-size: 14px;
      color: #333;
      background: rgba(255,255,255,0.2);
    }

    button {
      cursor: pointer;
      transition: all 0.25s ease;
      border: none;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.35);
      transform: scale(1.05);
    }

    #controls button {
      font-size: 15px;
      font-weight: 600;
      padding: 10px 16px;
      color: #111;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(15px);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
      text-align: center;
      min-width: 180px;
    }

    #controls button:active {
      transform: scale(0.97);
      background: rgba(255, 255, 255, 0.3);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1) inset;
    }

    #stopHistoryDisplay {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 16px;
      font-family: 'Segoe UI', sans-serif;
      color: #111;
      font-size: 14px;
      line-height: 1.0;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      margin-top: 20px;
    }

    #minimap {
      backdrop-filter: blur(12px);
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.4);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

    #gradientPopup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #gradientPopup.show {
      display: flex;
    }

    #gradientContent {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      padding: 30px 40px;
      color: white;
      text-align: center;
      backdrop-filter: blur(20px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    #gradientContent h3 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 20px;
      color: #fff;
    }

    #gradientContent button {
      margin-top: 10px;
      padding: 8px 14px;
      border-radius: 10px;
      border: none;
      background: rgba(255,255,255,0.25);
      cursor: pointer;
      font-weight: bold;
      color: white;
      transition: 0.25s;
    }

    #gradientContent button:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.05);
    }
#controls {
  position: fixed;       /* fix position on screen */
  top: 60px;             /* some space from top */
  left: -400px;            /* some space from left */
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 16px;
  width: 350px;          /* fixed width */
  padding: 10px 16px;
  background: rgba(255, 255, 255, 0.12);
  border-radius: 20px;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.1);
  z-index: 10000;        /* above other content */
  max-height: 150vh;  /* so it doesn’t overflow vertically */
  overflow-y: auto;      /* scroll if content is too tall */
}


#controls > div,
#controls > pre {
  width: 150px;
  padding: 10px 14px;
  background: rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: inset 0 1px 5px rgba(255,255,255,0.3);
  color: #222;
  font-weight: 600;
  font-size: 15px;
  user-select: none;
  line-height: 1.3;
}

#pointsDisplay,
#speedDistance {
  background: rgba(255, 255, 255, 0.25);
  color: #111;
  font-weight: 700;
  font-size: 17px;
  line-height: 1.4;
}

#info {
  background: rgba(255, 255, 255, 0.15);
  font-weight: 500;
  font-size: 14px;
  color: #333;
  user-select: text;
}

#vxDisplay {
  display: none; /* keep hidden unless needed */
}

button {
  width: 100px;
  padding: 12px 0;
  border-radius: 14px;
  font-weight: 600;
  font-size: 16px;
  background: rgba(255, 255, 255, 0.3);
  color: #222;
  border: none;
  cursor: pointer;
  box-shadow: 0 5px 12px rgba(0, 0, 0, 0.1);
  transition: background 0.3s ease, transform 0.2s ease;
}

button:hover {
  background: rgba(255, 255, 255, 0.45);
  transform: scale(1.04);
}

button:active {
  transform: scale(0.97);
  background: rgba(255, 255, 255, 0.35);
}

#stopHistoryDisplay {
  position: fixed;       /* fix position on screen */
  top: 60px;             /* some space from top */
  right: -400px;            /* some space from left */
  max-height: 220px;
  overflow-y: auto;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  background: rgba(255, 255, 255, 0.1);
  color: #222;
  padding: 14px;
  border-radius: 14px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
  white-space: pre-wrap;
  line-height: 1.25;
}
#quickKeyboard {
  position: fixed;
  bottom: -70px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 9999;
  padding: 14px 20px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(15px);
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

#quickKeyboard button {
  font-size: 15px;
  font-weight: 600;
  padding: 10px 16px;
  color: #111;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(15px);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
  text-align: center;
  min-width: 60px;
}
.row {
  margin-top: 8px;
}
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <div id="fpsCounter">FPS: 0</div>
      <div id="pointsDisplay">Points: 0</div>
      <div id="speedDistance">Distance: 0 px<br>Speed: 0 px/s</div>
      <div id="vxDisplay" style="display: none">vx: 0</div>

      <button id="openGradientMenu">Customize Menu</button>
      <button onclick="showStopHistory()">View Stop History</button>

      <div style="display: none"id="info">Press 1, 2, or 3 to switch buses. Current: Gillig 29'</div>
      <canvas id="minimap" width="300" height="100"></canvas>
    </div>

    <div id="gradientPopup">
      <div id="gradientContent">
        <h3>Gradient Settings</h3>
        <label>
          Start Color:
          <input type="color" id="startColorPicker" value="#d3d3d3" />
        </label>
        <br /><br />
        <label>
          End Color:
          <input type="color" id="endColorPicker" value="#d3d3d3" />
        </label>
        <br /><br />
        <button onclick="exportGradient()">Export Gradient</button>
        <input type="file" id="importGradientFile" style="display:none" accept=".sg,.json" />
        <button onclick="document.getElementById('importGradientFile').click()">Import Gradient</button>
        <br /><br />
        <button id="closeGradientMenu">Close</button>
      </div>
    </div>

    <canvas id="busCanvas" width="800" height="600"></canvas>
          <pre id="stopHistoryDisplay"></pre>
<div id="quickKeyboard">
  <button data-key="1">1</button>
  <button data-key="2">2</button>
  <button data-key="3">3</button>
  <button data-key="ArrowRight">→</button>
  <button data-key="b">Brake</button>
  <button data-key="l">Kneel</button>

  <br>

  <button data-key="s">Light</button>
  <button data-key="n">Night</button>
  <button data-key="t">Test</button>
</div>


  </div>

  <script>
  const keys = {};
  let fps = 0;
let lastFrameTime = performance.now();
let frames = 0;
let lastFpsUpdate = performance.now();
let debugMode = false;

  let accelerating = false;
  let braking = false;
  let friction = 0.9999;
 window.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (keys[key]) return;
    keys[key] = true;

    handleKeyPress(key);
  });

  window.addEventListener('keyup', e => {
    const key = e.key.toLowerCase();
    keys[key] = false;
  });
let spotlightOn = false
let night = true;  // toggle this to switch modes
  function handleKeyPress(key) {
    if (key === 'arrowright') {
      accelerating = !accelerating;
      braking = false;
      friction = 0.999;
      console.log('Accelerating:', accelerating);
    }

    if (key === 'b') {
      braking = true;
      console.log('Braking:', braking);
    }
    if (key === 't') {
      debugMode = !debugMode
    }
      if (key === 'n') {
      night = !night
    }
        if (key === 's') {
      if (night) {
        spotlightOn = !spotlightOn
      }
    }
  }
function simulateKeyPress(key) {
  // Create and dispatch a real keyboard event for the key
  const event = new KeyboardEvent('keydown', { key: key, bubbles: true });
  window.dispatchEvent(event);

  // Also dispatch keyup shortly after to mimic real press-release
  setTimeout(() => {
    const eventUp = new KeyboardEvent('keyup', { key: key, bubbles: true });
    window.dispatchEvent(eventUp);
  }, 100);
}

// Existing keys state and logic...

document.querySelectorAll('#quickKeyboard button').forEach(button => {
  button.addEventListener('click', () => {
    const key = button.getAttribute('data-key').toLowerCase();

    // For numbers and 'l', simulate real keypress event
    if (key === '1' || key === '2' || key === '3' || key === 'l') {
      simulateKeyPress(key);
    } else {
      // For other keys, use previous logic:
      if (keys[key]) return;
      keys[key] = true;

      handleKeyPress(key);

      setTimeout(() => {
        keys[key] = false;
      }, 100);
    }
  });
});
const fpsDiv = document.getElementById('fpsCounter');

function gameLoop(timestamp) {
  const delta = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  frames++;

  if (timestamp - lastFpsUpdate >= 500) {
    fps = Math.round((frames * 1000) / (timestamp - lastFpsUpdate));
    frames = 0;
    lastFpsUpdate = timestamp;
    if (fpsDiv) fpsDiv.textContent = `FPS: ${fps}`;
  }
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

  // === Simulate virtual keypress from quick keyboard buttons ===
  document.querySelectorAll('#quickKeyboard button').forEach(button => {
    button.addEventListener('click', () => {
      const key = button.getAttribute('data-key').toLowerCase();
      if (keys[key]) return;
      keys[key] = true;

      handleKeyPress(key);

      setTimeout(() => {
        keys[key] = false;
      }, 100);
    });
  });

    // Basic toggle popup logic (feel free to extend)
    const popup = document.getElementById('gradientPopup');
    document.getElementById('openGradientMenu').onclick = () => popup.classList.add('show');
    document.getElementById('closeGradientMenu').onclick = () => popup.classList.remove('show');
  const gradientPopup = document.getElementById("gradientPopup");
  const openBtn = document.getElementById("openGradientMenu");
  const closeBtn = document.getElementById("closeGradientMenu");

  openBtn.onclick = () => gradientPopup.classList.add("show");
  closeBtn.onclick = () => gradientPopup.classList.remove("show");

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 't') {
    debugMode = !debugMode;
    console.log(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
  }
});

  // Optional: Close on background click
  gradientPopup.onclick = (e) => {
    if (e.target === gradientPopup) {
      gradientPopup.classList.remove("show");
    }
  };
let acceleration = 0.1;      // Acceleration rate
const almostOne = 1 - 1e-222     // Max speed
const bridges = [];
let camFollowX = 0;          // Camera follow target x
let delayTimer = 0;          // For 2s delay
let distance2 = 0;
const lightCount = 5;

// Only regenerate when the center light needs to shift
let lastCenterIndex = null;

  const canvas = document.getElementById('busCanvas');
  const info = document.getElementById('info');
  const ctx = canvas.getContext('2d');
const lightColors = {
  0: "#00ff00", // green
  1: "#ffff00", // yellow
  2: "#ff0000", // red
};

let sharedTimer = 0;
let sharedState = 2; // Start on red


let violationMessageTimer = 0;
// Generate bridges with dark brown columns
const bridgePositions = [500]; // Required first bridge
while (bridgePositions.length < 10) {
  const next = bridgePositions[bridgePositions.length - 1] + Math.floor(10000 + Math.random() * 3000);
  bridgePositions.push(next);
}

for (const x of bridgePositions) {
  bridges.push({ x });
}

function update(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const delta = (timestamp - lastTimestamp) / 1000; // seconds elapsed since last frame

  // Distance traveled increment (assuming vx is px per second)
  distance2 += Math.abs(vx * delta);


  // Update the display text, multiply by 2
  const speedDisplay = document.getElementById('speedDistance');
  speedDisplay.innerHTML = `Distance: ${(distance2 * 2).toFixed(0)} px<br>Speed: ${(vx * 2).toFixed(0)} px/s`;

  lastTimestamp = timestamp;
  requestAnimationFrame(update);
  
}

requestAnimationFrame(update);


window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();

  if (keys[key]) return; // Ignore repeat until released
  keys[key] = true;

  if (key === 'arrowright') {
    accelerating = !accelerating; // Toggle acceleration
    console.log('Accelerating:', accelerating);
    braking = false
    friction = 0.999
  }

  if (key === 'b') {
    braking = true
    console.log('Braking:', braking);
  }
});

window.addEventListener('keyup', e => {
  const key = e.key.toLowerCase();
  keys[key] = false; // Allow toggling again on next key press
});

let audioCtxA = new (window.AudioContext || window.webkitAudioContext)();
let idleGain, jitterGain, driveGain, driveNoiseSource;
let currentState = "idle";

let currentSystem = "D";
let audioAStarted = false, audioBStarted = false;
let vx = 0;
const maxSpeed = 120;
let violationOccurred = false;
// === Ensure AudioContext ===
function ensureAudioContext() {
  if (!audioCtxA || audioCtxA.state === "closed") {
    audioCtxA = new (window.AudioContext || window.webkitAudioContext)();
  }
}

// === Engine Tone Buffer ===
function createEngineToneBuffer(freq = 60, duration = 2, volume = 0.2) {
  const buffer = audioCtxA.createBuffer(1, duration * audioCtxA.sampleRate, audioCtxA.sampleRate);
  const data = buffer.getChannelData(0);
  const sampleRate = audioCtxA.sampleRate;
  for (let i = 0; i < data.length; i++) {
    data[i] = Math.sin(5)
  }
  return buffer;
}

// === Source with Gain ===
function createLoopingSource(buffer, gainValue = 0.5) {
  const source = audioCtxA.createBufferSource();
  source.buffer = buffer;
  source.loop = true;

  const gain = audioCtxA.createGain();
  gain.gain.value = gainValue;

  source.connect(gain).connect(audioCtxA.destination);
  return { source, gain };
}

// === Start Audio A ===
let trainApproaching = false
const MAX_INT_32 = 2147483647;
let trainTrafficLights = [];
let trainFlashTimer = 0;
let trainFlashOn = true;
// === Update Audio Based on Speed ===
let jitterOscillator = null;
let jitterLFOGain = null;
let jitterOscActive = false;
function step() {
  if (currentSystem === "A") {
    updateAudioSystemA(vx);
  } else if (currentSystem === "C") {
    updateAudioSystemC(vx)
  }
}
step()

// === Ensure AudioContext ===
function ensureAudioContext() {
  if (!audioCtxA || audioCtxA.state === "closed") {
    audioCtxA = new (window.AudioContext || window.webkitAudioContext)();
  }
}
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Buffers and Nodes
let idleNoise, driveNoise, jitterNoise;


// Create white noise buffer
function createNoiseBuffer(duration = 2, volume = 0.5) {
  const buffer = audioCtx.createBuffer(1, duration * audioCtx.sampleRate, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) {
    data[i] = (Math.random() * 2 - 1) * volume;
  }
  return buffer;
}

// Create looping white noise source
function createNoiseSource(buffer, gainValue = 0.5) {
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;

  const gain = audioCtx.createGain();
  gain.gain.value = gainValue;

  source.connect(gain).connect(audioCtx.destination);
  return { source, gain };
}

// Start Audio (A-type)
function startAudioA() {
  idleNoise = createNoiseBuffer(0.3, 0.3);
  jitterNoise = createNoiseBuffer(0.4, 0.8);
  driveNoise = createNoiseBuffer(2, 0.4);

  const idle = createNoiseSource(idleNoise, 0.1);
  const jitter = createNoiseSource(jitterNoise, 0.0);

  const driveSource = audioCtx.createBufferSource();
  driveSource.buffer = driveNoise;
  driveSource.loop = true;

  driveGain = audioCtx.createGain();
  driveGain.gain.value = 0.0;

  const bandpassFilter = audioCtx.createBiquadFilter();
  bandpassFilter.type = 'bandpass';
  bandpassFilter.frequency.value = 201;
  bandpassFilter.Q.value = 5;

  const delayNode = audioCtx.createDelay();
  delayNode.delayTime.value = 0.05;

  const feedbackGain = audioCtx.createGain();
  feedbackGain.gain.value = 1;

  delayNode.connect(feedbackGain);
  feedbackGain.connect(delayNode);

  driveSource.connect(bandpassFilter);
  bandpassFilter.connect(delayNode);
  delayNode.connect(driveGain);
  bandpassFilter.connect(driveGain);
  driveGain.connect(audioCtx.destination);

  // driveSource.playbackRate.value = 1.0; // Optional pitch
  driveSource.start();

  idle.source.start();
  jitter.source.start();

  idleGain = idle.gain;
  jitterGain = jitter.gain;
  driveNoiseSource = driveSource;

  currentState = "idle";
  idleGain.gain.value = 0.3;
}

// Update Engine Sound (A-type)
function updateAudioSystemA() {
  VX = vx
  const speedNorm = Math.min(Math.abs(VX) / maxSpeed, 1);

  if (VX < 0.5 && currentState !== "idle") {
    currentState = "idle";
    idleGain.gain.setTargetAtTime(0.05, audioCtx.currentTime, 0.5);
    driveGain.gain.setTargetAtTime(0.01, audioCtx.currentTime, 0.4);
    jitterGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.1);
  }

  else if (VX >= 0.5) {
    if (currentState === "idle") {
      currentState = "jitter";
      idleGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.1);
      driveGain.gain.setTargetAtTime(0.01, audioCtx.currentTime, 0.1);
      const jitterOscillator = audioCtx.createOscillator();
      jitterOscillator.type = "sine"; // harsh wave
      jitterOscillator.frequency.value = 10;

      const jitterLFOGain = audioCtx.createGain();
      jitterLFOGain.gain.value = 0.4;

      jitterOscillator.connect(jitterLFOGain);
      jitterLFOGain.connect(jitterGain.gain);

      jitterOscillator.start();

      setTimeout(() => {
        jitterOscillator.stop();
        jitterOscillator.disconnect();
        jitterLFOGain.disconnect();

        if (vx >= 0.5) {
          currentState = "drive";
          jitterGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.2);

          driveGain.gain.setTargetAtTime(0.01 + 0.5 * speedNorm, audioCtx.currentTime, 0.4);
          // Optional pitch ramp:
          // driveNoiseSource.playbackRate.setTargetAtTime(1 + 0.8 * speedNorm, audioCtx.currentTime, 0.3);
        }
      }, 500); // 0.5 sec jitter before drive
    }

    else if (currentState === "drive") {
      idleGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.5);
    const speedNorm = Math.min(vx / 12, 1); // Normalize for gain
    const driveVolume = Math.min(0.01 + 0.2 * speedNorm, 0.8);
      driveGain.gain.setTargetAtTime(driveVolume, audioCtx.currentTime, 0.2);
    }
  }
  if (vx >= 12) {
    vx = 12
    driveGain.gain.setTargetAtTime(0.1 + 0.2 * speedNorm, audioCtx.currentTime, 0.001);
  }
}
let flashAlpha = 0;
let flashTimer = 0;

    // ---------------- SYSTEM B ---------------- //
    let cruiseGainLevel = 0.005;
    const ctxB = new (window.AudioContext || window.webkitAudioContext)();
    let engineOsc, engineGain, filter, delay, delayGain;
    let noiseGain, whiteNoise, vibrationOsc, vibrationGain;
    let cruiseToneOsc, cruiseToneOscGain;
    let idleLFO = null, idleLFOGain = null;
    let frequency = 160, gainLevel = 0.1;
    let vxTimer = 0, lastAccelTime = 0;
    let cruising = false;
    const FREQ_MIN = 160, FREQ_MAX = 800;
    const GAIN_MIN = 0.1, GAIN_MAX = 0.5;
    const vxDisplay = document.getElementById('vxDisplay');
    const accelBtn = document.getElementById('accelBtn');

function createWhiteNoiseB() {
  const buffer = ctxB.createBuffer(1, ctxB.sampleRate * 2, ctxB.sampleRate);
  const data = buffer.getChannelData(0);

  // Generate slightly smoother noise (low-frequency emphasis)
  let lastValue = 0;
  for (let i = 0; i < data.length; i++) {
    // Apply slight smoothing between samples for wind-like texture
    const rand = Math.random() * 2 - 1;
    data[i] = (lastValue + rand * 0.05) / 1.25; // smooth blend
    lastValue = data[i];
  }

  const source = ctxB.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  return source;
}


function initAudioB() {
  engineOsc = ctxB.createOscillator();
  engineOsc.type = 'triangle';
  engineOsc.frequency.value = 0.1;

  engineGain = ctxB.createGain();
  engineGain.gain.value = 0.8;

  filter = ctxB.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 10;
  filter.Q.value = 1.5;

  delay = ctxB.createDelay();
  delay.delayTime.value = 0.00005;

  delayGain = ctxB.createGain();
  delayGain.gain.value = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001;

  whiteNoise = createWhiteNoiseB();
  noiseGain = ctxB.createGain();
  noiseGain.gain.value = 0.2;

  vibrationOsc = ctxB.createOscillator();
  vibrationOsc.frequency.value = 1;
  vibrationGain = ctxB.createGain();
  vibrationGain.gain.value = 0.8;

  cruiseToneOsc = ctxB.createOscillator();
  cruiseToneOsc.type = 'sine';
  cruiseToneOsc.frequency.value = 900;

  cruiseToneOscGain = ctxB.createGain();
  cruiseToneOscGain.gain.value = 0.005; // <-- Always audible alongside engine

  // Routing
  whiteNoise.connect(noiseGain).connect(ctxB.destination);
  delay.connect(delayGain).connect(delay);
  vibrationOsc.connect(vibrationGain).connect(engineOsc.frequency);
  engineOsc.connect(filter).connect(engineGain).connect(delay).connect(ctxB.destination);
  engineGain.connect(ctxB.destination);
cruiseToneOsc.connect(cruiseToneOscGain).connect(ctxB.destination);


  vibrationOsc.start();
  engineOsc.start();
  cruiseToneOsc.start();
  whiteNoise.start();
}


    function updateEngineB() {
      cruiseToneOsc.frequency.setTargetAtTime(cfrequency, ctxB.currentTime, 0.15);
      cruiseToneOscGain.gain.setTargetAtTime(cruiseGainLevel, ctxB.currentTime, 0.15);
      engineOsc.frequency.setTargetAtTime(frequency, ctxB.currentTime, 0.2);
      engineGain.gain.setTargetAtTime(gainLevel, ctxB.currentTime, 0.15);
      filter.frequency.setTargetAtTime(120 + (frequency - FREQ_MIN) * 0.8, ctxB.currentTime, 0.15);

    }
    let cfrequency = 900; // Cruise tone base frequency
let speedTimer = 0
    function simulationStepB() {
      const now = performance.now();
      if (accelerating) {
        if (lastAccelTime === 0 || now - lastAccelTime > 500) {
          speedTimer = 0;
          
        }
        lastAccelTime = now;
        speedTimer += 1 / 60;

        if (speedTimer < 16) {
          frequency += 0.25;
          cfrequency += 1;
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 16.5) {
          frequency -= 4;
          cfrequency += 4;
          gainLevel -= 0.000000000000000000000000001;
        } else if (speedTimer < 26.5) {
          frequency += 0.2;
          cfrequency += 1;
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 27.51 && gainLevel >= 0.04) {
          gainLevel = 0.0001
          cfrequency = 900
          delay.delayTime.value = 0.0000000000000000000001;
          frequency = 400
        }
      } else {
        if (now - lastAccelTime > 500) {
          speedTimer = 0;
          cruising = false;
          vibrationOffTime = null;
        }
        frequency -= 1.5;
        gainLevel -= 0.001;
      }
      if (!accelerating) {
        speedTimer = 0
      }
      if (vx >= 15) {
        vx = 15
      }
      if (braking) {
        frequency -= 3;
        gainLevel -= 0.1;
        cfrequency -= 10;
        if (cfrequency <= 0) {
          cfrequency = 0
          cruiseGainLevel = 0.005
        }
        cruiseGainLevel += 0.00001
        speedTimer = 0
        cruising = false;
        vibrationOffTime = null;
      }

      frequency = Math.max(FREQ_MIN, Math.min(frequency, FREQ_MAX));
      gainLevel = Math.max(GAIN_MIN, Math.min(gainLevel, GAIN_MAX));
      updateEngineB();

      requestAnimationFrame(simulationStepB);
    }
let electricOsc, electricGain, dieselNoise, dieselGain, lowpass;
const audioCtxC = new (window.AudioContext || window.webkitAudioContext)();
let audioCStarted = false;

// Track when electric started playing to stop after 5 seconds
let electricStartTime = null;

function startAudioC() {
  if (audioCStarted) return;
  audioCStarted = true;

  electricOsc = audioCtxC.createOscillator();
  electricGain = audioCtxC.createGain();
  electricOsc.type = "square";
  electricOsc.frequency.value = 100;
  electricGain.gain.value = 0.0; // start silent
  electricOsc.connect(electricGain).connect(audioCtxC.destination);

  const bufferSize = 2 * audioCtxC.sampleRate;
  const buffer = audioCtxC.createBuffer(1, bufferSize, audioCtxC.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

  dieselNoise = audioCtxC.createBufferSource();
  dieselNoise.buffer = buffer;
  dieselNoise.loop = true;

  dieselGain = audioCtxC.createGain();
  dieselGain.gain.value = 0.0;

  lowpass = audioCtxC.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 10;

  dieselNoise.connect(lowpass).connect(dieselGain).connect(audioCtxC.destination);

  electricOsc.start();
  dieselNoise.start();

  electricStartTime = audioCtxC.currentTime;
}
const keysDown = new Set();
// Call this continuously (e.g. in animation frame loop)
function updateAudioSystemC() {
  const maxSpeed = 13.5;
  if (vx > maxSpeed) vx = maxSpeed;
  const speedNorm = vx / maxSpeed;

  if (vx === 0) {
    // Reset when idle
    electricOsc.frequency.setValueAtTime(100, audioCtxC.currentTime);
    electricGain.gain.setTargetAtTime(0.0, audioCtxC.currentTime, 0.1);

    dieselGain.gain.setTargetAtTime(6, audioCtxC.currentTime, 0.01);
    return;
  }

  // Electric motor frequency ramps with speed
  const electricFreq = 4 + speedNorm * 200;
  electricOsc.frequency.setTargetAtTime(electricFreq, audioCtxC.currentTime, 0.2);

  // Electric gain: slowly increase from 0 to 0.4 as vx goes from 0 to 2,
  // then hold at 0.4 while diesel fades in after vx > 2.
  let electricTargetGain = 0;
  if (vx <= 2) {
    electricTargetGain = 0.1 * (vx / 2);  // linear ramp 0 to 0.4
  } else {
    electricTargetGain = 0.1; // hold max electric gain once diesel starts
  }
  electricGain.gain.setTargetAtTime(electricTargetGain, audioCtxC.currentTime, 0.2);

  // Diesel gain: fade in starting from vx > 2 up to max at vx=12
  if (vx > 2) {
    const dieselNorm = (vx - 2) / (maxSpeed - 2);
    const dieselVol = 0.2 + 0.5 * dieselNorm;
    dieselGain.gain.setTargetAtTime(dieselVol, audioCtxC.currentTime, 0.3);

    // Adjust diesel tone based on acceleration
    const filterFreq = accelerating
      ? 200 + 1000 * dieselNorm  // Brighter when accelerating
      : 100 + 500 * dieselNorm; // Deeper when slowing
    lowpass.frequency.setTargetAtTime(filterFreq, audioCtxC.currentTime, 0.3);
  } else {
    dieselGain.gain.setTargetAtTime(5, audioCtxC.currentTime, 0.01);
  }
}

function updateTrafficLights(deltaTime) {
  trafficLights.forEach((light, index) => {
    const cycleTime = 3000;

    if (light.timer === undefined) {
      light.timer = (index * 1000) % cycleTime;
      if (light.timer < 1000) light.state = 0;
      else if (light.timer < 2000) light.state = 1;
      else light.state = 2;
    } else {
      light.timer += deltaTime;
    }

    switch (light.state) {
      case 0:
        if (light.timer >= 9000) {
          light.state = 1;
          light.timer = 0;
          console.log(`Light ${index} switched to YELLOW`);
        }
        break;
      case 1:
        if (light.timer >= 1000) {
          light.state = 2;
          light.timer = 0;
          console.log(`Light ${index} switched to RED`);
        }
        break;
      case 2:
        if (light.timer >= 10000) {
          light.state = 0;
          light.timer = 0;
          console.log(`Light ${index} switched to GREEN`);
        }
        break;
    }
  });
}


function animate2() {
  updateAudioSystemC();
  requestAnimationFrame(animate2);
}
// --- Keyboard Controls ---
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (keysDown.has(key)) return; // Prevent repeat while held

  if (key === '3') {
    if (!audioBStarted) {
      initAudioB();
      simulationStepB();
      audioBStarted = true;
    }
    ctxB.resume();
    audioCtxA.suspend();
    audioCtxC.suspend?.();
    currentSystem = "B";
  } else if (key === '1') {
    if (!audioAStarted) {
      startAudioA();
      audioAStarted = true;
    }
    audioCtxA.resume();
    ctxB.suspend();
    audioCtxC.suspend?.();
    currentSystem = "A";
  } else if (key === '2') {
    if (!audioCStarted) {
      startAudioC();
    }
    audioCtxC.resume();
    ctxB.suspend?.();
    audioCtxA.suspend();
    currentSystem = "C";
    animate2(); 
  }

  keysDown.add(key);
});

window.addEventListener('keyup', e => {
  keysDown.delete(e.key.toLowerCase());
});

// --- System Toggle Function ---
async function toggleSystems() {
  if (currentSystem === "A") {
    await audioCtxA.suspend();
  } else if (currentSystem === "B") {
    await ctxB.suspend();
  } else if (currentSystem === "C") {
    await audioCtxC.suspend?.();
  }

  systemIndex = (systemIndex + 1) % systemOrder.length;
  const nextSystem = systemOrder[systemIndex];

  if (nextSystem === "A") {
    if (!audioAStarted) {
      startAudioA();
    }
    await audioCtxA.resume();
  } else if (nextSystem === "B") {
    if (!audioBStarted) {
      initAudioB();
      simulationStepB();
      audioBStarted = true;
    }
    await ctxB.resume();
  } else if (nextSystem === "C") {
    if (!audioCStarted) {
      startAudioC();
      updateAudioSystemC()
    }
    await audioCtxC.resume();
  }

  currentSystem = nextSystem;
}
let trafficLights = [];
const trafficLightSpacing = 20000;
const firstLightX = 1000;
const lightRadius = 12;

// --- Global Variables ---
const STOP_INTERVAL = 7500;
const STOP_SPAWN_LIMIT = 50000000;
const STOP_RADIUS = 20;
const STOP_DETECTION_RANGE = 500;
const STOP_COUNTER_TRIGGER = 1000;

let stops = [];
let passengersOnBoard = 0;
let nextStopRequest = null;
let pendingDropRequest = false;
let collectedDisplay = null;
let collectedDisplayTimeout = null;

// --- Call this ONCE on game start/reset ---
let showNotice = false;
let distance = 3000; // define outside loop
function generateStops() {
  stops = [];
  for (let i = 0, x = 10000; x <= STOP_SPAWN_LIMIT; x += STOP_INTERVAL, i++) {
    stops.push({
      x,
      collected: false,
      special: Math.random() < 0.5,
      isStation: i % 10 === 0  // Every 10th stop becomes a station
    });
  }
}

generateStops(); // Initialize stops

  let currentBusIndex = 0;

let startAudioCalled = false;
let amount = 0


  let camX = 0;
  const tilt = 0;
  function drawMinimap(bus, camX) {
  const minimap = document.getElementById('minimap');
  const ctx = minimap.getContext('2d');
  const w = minimap.width;
  const h = minimap.height;

  ctx.clearRect(0, 0, w, h);

  const RANGE = 20000; // Show ±10,000px from bus
  const startX = bus.x - RANGE / 2;
  const endX = bus.x + RANGE / 2;

  // Background
  ctx.fillStyle = "#ddd";
  ctx.fillRect(0, h / 3, w, h / 3);

  // Only draw stops within the visible window
  for (const stop of stops) {
    if (stop.x >= startX && stop.x <= endX) {
      const percent = (stop.x - startX) / RANGE;
      const x = percent * w;
      const color = stop.special ? "#777" : "#007bff";
      ctx.beginPath();
      ctx.arc(x, h / 2, 4, 0, Math.PI * 2);
      ctx.fillStyle = stop.collected ? "#ccc" : color;
      ctx.fill();
    }
  }

  // Draw the bus at center of minimap
  const busX = (bus.x - startX) / RANGE * w;
  ctx.beginPath();
  ctx.arc(busX, h / 2, 5, 0, Math.PI * 2);
  ctx.fillStyle = "#ff0000";
  ctx.fill();
// === Draw Train Traffic Lights on Minimap ===
for (const light of trainTrafficLights) {
  if (light.x >= startX && light.x <= endX) {
    const percent = (light.x - startX) / RANGE;
    const x = percent * w;

    ctx.beginPath();
    ctx.arc(x, h / 2, 4, 0, Math.PI * 2); // 10 px above center
    ctx.fillStyle = light.state === 1 ? "#ff0000" : "#000000";
    ctx.fill();
  }
}

  // Viewport box based on screen size (approximation)
  const screenWidthPx = window.innerWidth;
  const percentCamStart = (camX - startX) / RANGE;
  const percentCamEnd = (camX + screenWidthPx - startX) / RANGE;
  const camStart = percentCamStart * w;
  const camEnd = percentCamEnd * w;

  ctx.strokeStyle = "#444";
  ctx.strokeRect(camStart, h / 3, camEnd - camStart, h / 3);
}




  const fuelPickups = [
    { x: 100, collected: false },
    { x: 300, collected: true },
    { x: 500, collected: false },
  ];
  // === GLOBAL STATE ===
const trainTracks = [];
const spawnedTracks = new Set();
const trains = [];


const trackSpacing = 50000;
const firstTrack = 5000;

// === GENERATE TRAIN TRACKS ===
function generateTracksUpTo(xLimit) {
  for (let x = firstTrack; x <= xLimit; x += trackSpacing) {
    if (!trainTracks.some(t => t.x === x)) {
      const isDouble = Math.random() < 0.9;
      trainTracks.push({ x, isDouble });
    }
  }
}

// === TRAIN SPAWNING ===
function spawnTrain(trackX) {
  trains.push({
    worldX: trackX,
    scale: 0.1,
    growthSpeed: 0.005,
    spawnTime: Date.now()
  });
}

function checkTrainSpawn(bus) {
  trainTracks.forEach(({ x }) => {
    if (bus.x >= x - 1000 && !spawnedTracks.has(x)) {
      spawnTrain(x);
      spawnedTracks.add(x);
    }
  });
}

// === TRAIN DRAWING ===
function drawTrains(ctx, camX) {
  const now = Date.now();
  for (let i = trains.length - 1; i >= 0; i--) {
    const train = trains[i];
    train.scale += train.growthSpeed;

    if (train.scale > 4 || now - train.spawnTime > 30000) {
      trains.splice(i, 1);
      continue;
    }

    const screenX = train.worldX - camX;
    const y = 500;
    const width = 100 * train.scale;
    const height = 100 * train.scale;

    ctx.fillStyle = "#333";
    ctx.fillRect(screenX - width / 2, y - height, width, height);
    ctx.fillStyle = "#ccc";
    ctx.fillRect(screenX - width / 4, y - height + 10 * train.scale, width / 2, 12 * train.scale);
    ctx.fillStyle = "#222";
    ctx.beginPath();
    ctx.ellipse(screenX - width / 3, y - 10, 10 * train.scale, 5 * train.scale, 0, 0, Math.PI * 2);
    ctx.ellipse(screenX + width / 3, y - 10, 10 * train.scale, 5 * train.scale, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}
function drawTransitStation(ctx, x, camX) {
  const screenX = x - camX;
  const buildingWidth = 1000;
  const buildingHeight = 900;
  const baseY = canvas.height - buildingHeight + 1100;

  // Main building
  ctx.fillStyle = '#666';
  ctx.fillRect(screenX, baseY, buildingWidth, buildingHeight);

  // Dark gray brick base
  ctx.fillStyle = '#444';
  ctx.fillRect(screenX, baseY + buildingHeight - 30, buildingWidth, 30);

  // Optional: Add windows
  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
  for (let i = 0; i < 5; i++) {
    ctx.fillRect(screenX + 40 + i * 100, baseY + 20, 40, 60);
  }

  // Optional: Add sign
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 18px sans-serif';
  ctx.fillText('TRANSIT STATION', screenX + 20, baseY + 5);
}

// === TRACK DRAWING ===
function drawTracks(ctx, camX) {
  trainTracks.forEach(({ x }) => {
    const screenX = x - camX;
    const y = 500;
    ctx.strokeStyle = "#6B4C3B";
    ctx.lineWidth = 100;
    ctx.beginPath();
    ctx.moveTo(screenX - 160, y);
    ctx.lineTo(screenX + 160, y);
    ctx.stroke();
  });
}

// === TRAIN TRAFFIC LIGHTS ===
function generateTrainTrafficLights(busX) {
  trainTrafficLights = [];
  trainTracks.forEach(({ x }) => {
    if (Math.abs(busX - x) < 5000) {
      trainTrafficLights.push({ x, state: 0 });
    }
  });
}

function updateTrainTrafficLights(deltaTime) {
  if (trains.length > 0) {
    trainFlashTimer += deltaTime;
    if (trainFlashTimer >= 500) {
      trainFlashOn = !trainFlashOn;
      trainFlashTimer = 0;
    }
    trainTrafficLights.forEach(light => {
      light.state = trainFlashOn ? 1 : 0;
    });
  } else {
    trainFlashTimer = 0;
    trainFlashOn = true;
    trainTrafficLights.forEach(light => {
      light.state = 0;
    });
  }
}

function drawTrainTrafficLights(ctx, camX, canvasWidth) {
  const y = 520;
  trainTrafficLights.forEach(light => {
    const x = light.x - camX;
    if (x < -100 || x > canvasWidth + 3000) return;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fillStyle = light.state === 1 ? "#ff0000" : "#000000";
    ctx.fill();


    // Draw railway rectangle 100px after the traffic light
    // Find traffic light x for this track (if any)
      const railX = (light.x + 290) - camX;  // 100 px after light

      // Draw brown rectangle representing railway tie
      const rectWidth = 150;
      const rectHeight = 30;
      ctx.fillStyle = "#6B4C3B";
      ctx.fillRect(railX - rectWidth / 2, y - 25, rectWidth, rectHeight);

      // Draw two small squares inside the rectangle
      const squareSize = 35;
      const gap = 30; // space between squares

      ctx.fillStyle = "#333"; // darker brown for squares

      // Left square
      ctx.fillRect(railX - gap - squareSize / 2, y - 25, squareSize, squareSize);

      // Right square
      ctx.fillRect(railX + gap - squareSize / 2, y - 25, squareSize, squareSize);
    
  });
}

function isTrainLightBlocking(busX) {
  return trainTrafficLights.some(light =>
    Math.abs(busX - light.x) < 500 && light.state === 1
  
  );
}

  // Bus data for each type
  const buses = [
    {
      name: "Gillig 29'",
      x: 200,
      y: 330,
      width: 450,   // slightly shorter than before (was 400)
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [300, 340], // relative to bus.x
      doorSize: {width: 40, height: 130},
      window: { x: 30, y: 40, width: 250, height: 93.33},
      wheelOffsets: [125, 260],
      window2: { x: 380, y: 45, width: 0, height: 0 },
      bodyBezierOffset: 63,
    },
    {
      name: "Gillig 40'",
      x: 200,
      y: 330,
      width: 470,
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [350, 390], // doors moved further back for longer bus
      backDoorPositions: [140, 180],
      doorSize: {width: 40, height: 130},
      window: { x: 0, y: 40, width: 140, height: 87.33},
      wheelOffsets: [100, 300],
      window2: { x: 220, y: 40, width: 130, height: 87.33 },
      bodyBezierOffset: 70,
    },
    {
      name: "New Flyer Xcelsior 40'",
      x: 200,
      y: 330,
      width: 500,
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [405, 430], // doors moved further back for longer bus
      doorSize: {width: 50, height: 130},
      backDoorPositions: [160, 205],
      window: { x: 55, y: 40, width: 105, height: 80.33},
      wheelOffsets: [125, 360],
      window2: { x: 255, y: 40, width: 150, height: 93.33 },
      bodyBezierOffset: 70,
    }
  ];
  // Control flags
let driverLocked = false;
let isLowered = false;
let xB = 0
// Kneeling amount
const LOWER_OFFSET = 10;// Default gradient stops
let gradientStops = [
  { offset: 0, color: '#d3d3d3' },
  { offset: 1, color: '#d3d3d3' }
];
let points = parseInt(localStorage.getItem('playerPoints')) || 1;
// Save to localStorage
function savePoints() {
  localStorage.setItem('playerPoints', points);
}

// Load from localStorage or fallback
function loadGradientStops() {
  const saved = localStorage.getItem('busGradientStops');
  if (saved) {
    gradientStops = JSON.parse(saved);
  }
}
loadGradientStops();
let stopHistory = JSON.parse(localStorage.getItem("stopHistory") || "[]");

function savePoints() {
  localStorage.setItem("points", points);
}

function saveStopHistoryEntry(entry) {
  stopHistory.push(entry);
  localStorage.setItem('stopHistory', JSON.stringify(stopHistory));
}

// Update the color pickers with loaded colors
const startColorPicker = document.getElementById('endColorPicker');
const endColorPicker = document.getElementById('startColorPicker');

startColorPicker.value = gradientStops[0].color;
endColorPicker.value = gradientStops[1].color;

// Save function
function saveGradientStops() {
  localStorage.setItem('busGradientStops', JSON.stringify(gradientStops));
}

// Set gradient colors and save
function setBusGradientColors(startColor, endColor) {
  gradientStops = [
    { offset: 0, color: startColor },
    { offset: 1, color: endColor }
  ];
  saveGradientStops();
}

// Listen for changes on the color pickers
startColorPicker.addEventListener('input', (e) => {
  setBusGradientColors(e.target.value, gradientStops[1].color);
});

endColorPicker.addEventListener('input', (e) => {
  setBusGradientColors(gradientStops[0].color, e.target.value);
});

// In your draw function, use gradientStops like this:

function generateTrafficLights(busX, intersection = null) {
  let centerX;

  if (intersection && typeof intersection.x === 'number') {
    centerX = intersection.x;
  } else if (typeof busX === 'number') {
    centerX = busX;
  } else {
    // fallback or error handling
    console.warn('generateTrafficLights: invalid busX and no intersection given');
    return;
  }

  // Calculate centerIndex as integer grid index based on position
  const centerIndex = Math.floor(centerX / trafficLightSpacing);

  if (centerIndex === lastCenterIndex) return;
  lastCenterIndex = centerIndex;

  const newLights = [];
  for (let i = -Math.floor(lightCount / 2); i <= Math.floor(lightCount / 2); i++) {
    const lightX = (centerIndex + i) * trafficLightSpacing;
    let existingLight = trafficLights.find(l => l.x === lightX);

    if (!existingLight) {
      existingLight = {
        x: lightX,
        state: 0,
        timer: 0,
        violated: false
      };
    }
    newLights.push(existingLight);
  }
  trafficLights = newLights;
}


window.addEventListener('keydown', e => {
  if ((e.key === 'l' || e.key === 'l') && vx === 0) {
    driverLocked = !driverLocked
    isLowered = !isLowered;
    console.log(isLowered ? "⬇ Bus lowered (kneeling)." : "⬆ Bus raised.");
  }
});
function saveGradient(stops) {
  if (!Array.isArray(stops)) return;

  try {
    localStorage.setItem('busGradient', JSON.stringify(stops));
  } catch (e) {
    console.error('Failed to save gradient:', e);
  }
}

let lastDrawTime = performance.now();
const signalSigns = [];
const maxSigns = 5;
function exportGradient() {
  const blob = new Blob([JSON.stringify(gradientStops, null, 2)], {
    type: 'application/json',
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'bus-gradient.sg';
  a.click();
  URL.revokeObjectURL(url);
}
document.getElementById('importGradientFile').addEventListener('change', function (event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const imported = JSON.parse(e.target.result);
      if (Array.isArray(imported)) {
        gradientStops = imported;
        saveGradientStops()
        alert("Gradient imported successfully!");
      } else {
        alert("Invalid gradient format.");
      }
    } catch (err) {
      alert("Failed to load gradient: " + err.message);
      saveGradientStops()
    }
  };
  reader.readAsText(file);
});
saveGradientStops()
const backgroundLayers = [
  { speed: 0.1, objects: [], type: 'cloud' },
  { speed: 0.2, objects: [], type: 'building' },
  { speed: 0.4, objects: [], type: 'tree' },
  { speed: 0.8, objects: [], type: 'car' }
];

const brightBackdropColors = [
  '#FF3B3B', '#FF9B00', '#FFEB3B', '#8BC34A', '#00BCD4', '#3F51B5', '#9C27B0', '#E91E63',
  '#FFC107', '#4CAF50', '#00E5FF', '#673AB7', '#F44336', '#CDDC39', '#2196F3', '#FF9800'
];

// Named buildings limited to 20 with 5 variants each
const namedBuildings = [
  'Post Office', 'Library', 'Supermarket', 'Bakery', 'Cafe', 'Cinema', 'Museum', 'Clinic',
  'Gym', 'Fire Station', 'Police Station', 'Bank', 'Fast Food', 'Pharmacy', 'Bookstore',
  'Hotel', 'Apartments', 'Office Tower', 'Gas Station', 'Court House'
];

// Fonts for each building name type (change as needed)
const buildingFonts = {
  'Post Office': 'italic 18px serif',
  'Library': 'bold 18px "Georgia", serif',
  'Supermarket': 'bold 16px "Arial Black", sans-serif',
  'Bakery': 'italic 16px "Comic Sans MS", cursive',
  'Cafe': 'bold 16px "Lucida Handwriting", cursive',
  'Cinema': 'bold 18px "Impact", sans-serif',
  'Museum': 'italic 18px "Times New Roman", serif',
  'Clinic': 'bold 18px "Trebuchet MS", sans-serif',
  'Gym': 'bold 20px "Verdana", sans-serif',
  'Fire Station': 'bold 18px "Tahoma", sans-serif',
  'Police Station': 'bold 18px "Courier New", monospace',
  'Bank': 'bold 20px "Georgia", serif',
  'Fast Food': 'bold 18px "Arial Black", sans-serif',
  'Pharmacy': 'italic 16px "Palatino", serif',
  'Bookstore': 'italic 18px "Georgia", serif',
  'Hotel': 'bold 18px "Lucida Bright", serif',
  'Apartments': 'bold 16px "Arial", sans-serif',
  'Office Tower': 'bold 18px "Helvetica", sans-serif',
  'Gas Station': 'bold 18px "Verdana", sans-serif',
  'Court House': 'bold 20px "Times New Roman", serif',
};

// Utility function to draw pillars (used for Court House, Bank, etc.)
function drawPillars(ctx, x, y, width, height, count) {
  const pillarWidth = width / (count * 2);
  const pillarHeight = height * 0.7;
  ctx.fillStyle = '#CCC';
  for (let i = 0; i < count; i++) {
    const px = x + i * pillarWidth * 2 + pillarWidth / 2;
    ctx.fillRect(px, y + height - pillarHeight, pillarWidth, pillarHeight);
    // Pillar top
    ctx.fillRect(px - 5, y + height - pillarHeight - 10, pillarWidth + 10, 10);
  }
}

// Icon drawing for specific building types (simple vector shapes)

function drawBookIcon(ctx, x, y, size) {
  ctx.fillStyle = '#7B3F00';
  ctx.fillRect(x, y, size * 0.7, size);
  ctx.fillStyle = '#A0522D';
  ctx.fillRect(x + size * 0.7, y + size * 0.1, size * 0.1, size * 0.8);
}

function drawBakeryDisplay(ctx, x, y, width, height) {
  ctx.fillStyle = '#FFDAB9';
  ctx.fillRect(x, y + height * 0.7, width, height * 0.3);
  ctx.fillStyle = '#F4A460';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.ellipse(x + width * (0.2 + i * 0.3), y + height * 0.85, width * 0.07, height * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawPillarRoof(ctx, x, y, width) {
  ctx.fillStyle = '#BBB';
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + width / 2, y - 30);
  ctx.lineTo(x + width, y);
  ctx.closePath();
  ctx.fill();
}

function drawBuildingName(ctx, name, x, y, width, align = 'center') {
  ctx.fillStyle = '#FFF';
  ctx.textBaseline = 'top';
  ctx.font = buildingFonts[name] || '16px sans-serif';
  ctx.textAlign = align;
  if (align === 'center') {
    ctx.fillText(name, x + width / 2, y);
  } else if (align === 'left') {
    ctx.fillText(name, x + 5, y);
  }
}

// Now the main drawing function for buildings including variants and decorations

function drawNamedBuilding(ctx, obj, time) {
  const { x, y, width, height, name, variant } = obj;
  const screenX = x - camX * 0.2;

  // Base colors & gradients for variants (adjust to taste)
  const baseColors = [
    '#2C3E50', '#34495E', '#7F8C8D', '#95A5A6', '#BDC3C7'
  ];
  const baseColor = baseColors[variant % baseColors.length];

  // Draw building base
  const grad = ctx.createLinearGradient(0, y, 0, y + height);
  grad.addColorStop(0, baseColor);
  grad.addColorStop(1, '#000');
  ctx.fillStyle = grad;
  ctx.fillRect(screenX, y, width, height);

  // Mono large window if applicable (some buildings have no windows)
  const windowMargin = 20;
  const windowWidth = width - windowMargin * 2;
  const windowHeight = height * 0.6;
  const windowY = y + height * 0.25;

  // Draw windows only on specific types
  if (['Library', 'Supermarket', 'Bakery', 'Cafe', 'Cinema', 'Museum', 'Clinic', 'Gym', 'Bank', 'Bookstore', 'Hotel', 'Office Tower'].includes(name)) {
    // Mono window with gradient
    const windowGrad = ctx.createLinearGradient(0, windowY, 0, windowY + windowHeight);
    windowGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
    windowGrad.addColorStop(1, 'rgba(200, 200, 255, 0.1)');
    ctx.fillStyle = windowGrad;
    ctx.fillRect(screenX + windowMargin, windowY, windowWidth, windowHeight);
  }

  // Draw building specific decoration by name and variant
  switch (name) {
    case 'Library':
      // Draw a book icon on wall
      drawBookIcon(ctx, screenX + width / 2 - 20, y + height * 0.15, 40);
      drawBuildingName(ctx, name, screenX, y + 5, width, 'center');
      break;

    case 'Bakery':
      drawBakeryDisplay(ctx, screenX + 10, y + height * 0.65, width * 0.8, height * 0.25);
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;

    case 'Court House':
      drawPillars(ctx, screenX + width * 0.15, y, width * 0.7, height, 6);
      drawPillarRoof(ctx, y, y, width);
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;

    case 'Bank':
      drawPillars(ctx, screenX + width * 0.1, y + height * 0.1, width * 0.8, height * 0.7, 4);
      drawBuildingName(ctx, name, screenX + width / 2, y + 5, width, 'center');
      break;

    case 'Post Office':
      // Use a stripe for the post office
      ctx.fillStyle = '#003366';
      ctx.fillRect(screenX, y + height * 0.1, width, height * 0.15);
      drawBuildingName(ctx, name, screenX + width / 2, y + 5, width, 'center');
      break;

    default:
      // Just building name top-left for others
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;
  }
}
const intersections = [];
const canvasWidth = 800; // example, adjust as needed
const canvasHeight = 600;
const mainRoadY = canvasHeight - 100;

// Generate intersections up to some max distance (e.g. 100000 px)
const maxDistance = 100000;
let lastX = 0;
while (lastX < maxDistance) {
  const gap = 2000 + Math.random() * 3000; // 2000-5000 px gap
  lastX += gap;
  intersections.push({
    x: lastX,
    hasTrafficLight: Math.random() < 0.2, // 20% chance
  });
}

function drawIntersection(ctx, camX, intersection) {
  const screenX = intersection.x - camX + canvasWidth / 2;

  // Only draw if on screen (roughly)
  if (screenX < -200 || screenX > canvasWidth + 200) return;

  const buildingWidth = 120;
  const buildingHeight = 200;

  // Draw perpendicular street (vertical road)
  ctx.fillStyle = '#444'; // dark asphalt
  ctx.fillRect(screenX - 50, 0, 100, canvasHeight);

  // Draw building at NE corner (right of vertical road, above main road)
  const buildingX = screenX + 50;
  const buildingY = mainRoadY - buildingHeight;
  ctx.fillStyle = '#a0522d';
  ctx.fillRect(buildingX, buildingY, buildingWidth, buildingHeight);

  // Windows on building
  ctx.fillStyle = '#555';
  const windowSize = 20;
  for(let y = buildingY + 10; y < buildingY + buildingHeight - 10; y += 40) {
    for(let x = buildingX + 10; x < buildingX + buildingWidth - 10; x += 40) {
      ctx.fillRect(x, y, windowSize, windowSize);
    }
  }

  // Draw traffic light if this intersection has one
  if (intersection.hasTrafficLight) {
    const lightX = buildingX - 40;
    const lightY = mainRoadY - 70;

    // Pole
    ctx.fillStyle = '#222';
    ctx.fillRect(lightX + 12, lightY, 6, 50);

    // Traffic light box
    ctx.fillStyle = '#000';
    ctx.fillRect(lightX, lightY - 30, 30, 60);

    // Lights: red, yellow, green
    const lightRadius = 8;
    const lightSpacing = 20;
    const colors = ['red', 'yellow', 'green'];
    for(let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.fillStyle = colors[i];
      ctx.arc(lightX + 15, lightY - 20 + i * lightSpacing, lightRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
  }
}
function drawAllIntersections(ctx, camX) {
  const roadWidth = 350;
  const mainRoadTop = canvas.height - 140;   // top edge of sidewalk
  const mainRoadHeight = 140;                // sidewalk + main road total height
  const sidewalkWidth = 15;
  const buildingWidth = 80;
  const buildingHeight = 140;

  // Remove traffic lights for intersections too far from camX (>500px)
  trafficLights = trafficLights.filter(light => {
    // Find corresponding intersection
    const intersection = intersections.find(i => i.x === light.x);
    if (!intersection) return false; // no intersection found => remove light
    const dist = Math.abs(intersection.x - camX);
    return dist <= 500;
  });

  for (const intersection of intersections) {
    // Calculate screen position relative to camera
    const screenX = intersection.x - camX + canvas.width / 2;

    // Draw perpendicular road - vertical rectangle cutting main road + sidewalk
    ctx.fillStyle = '#333';  // same as main road color
    ctx.fillRect(screenX - roadWidth / 2, mainRoadTop, roadWidth, mainRoadHeight);

  }
}
// Helper function to draw a traffic light at (x, y)
function drawTrafficLight(ctx, x, y) {
  const lightWidth = 20;
  const lightHeight = 60;
  ctx.fillStyle = '#222';
  ctx.fillRect(x - lightWidth / 2, y - lightHeight, lightWidth, lightHeight);

  // Lights: red, yellow, green circles
  const radius = 6;
  const spacing = 20;
  const colors = ['red', 'yellow', 'green'];
  for (let i = 0; i < colors.length; i++) {
    ctx.beginPath();
    ctx.fillStyle = colors[i];
    ctx.arc(x, y - lightHeight + spacing * (i + 1), radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Modified main draw function to include named buildings variants

function drawParallaxLayers(ctx, camX, time = 0) {
  backgroundLayers.forEach(layer => {
    layer.objects.forEach(obj => {
      const screenX = obj.x - camX * layer.speed;
      if (screenX + obj.width < -500 || screenX > canvas.width + 500) return;

      const fogOpacity = 0.1 + layer.speed * 0.3;

      if (obj.type === 'cloud') {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(screenX, obj.y, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      if (obj.type === 'building') {
        if (obj.name) {
          drawNamedBuilding(ctx, obj, time);
        } else if (obj.bType === 'fullGlass') {
          const bg = brightBackdropColors[obj.variant % brightBackdropColors.length];
          ctx.fillStyle = bg;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);

          ctx.fillStyle = `rgba(255,255,255,0.5)`;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
        } else if (obj.bType === 'brand') {
          ctx.fillStyle = '#654321';
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
          ctx.fillStyle = '#00FFFF';
          ctx.fillRect(screenX, obj.y + obj.height / 2 - 10, obj.width, 20);
        } else {
          // Generic building gradient
          const grad = ctx.createLinearGradient(0, obj.y, 0, obj.y + obj.height);
          grad.addColorStop(0, '#222');
          grad.addColorStop(1, '#111');
          ctx.fillStyle = grad;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
        }

        // Universal shadow overlay for depth
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(screenX + obj.width * 0.1, obj.y + obj.height * 0.1, obj.width * 0.8, obj.height * 0.8);

        // Optional building name for unnamed types - skipped here

        ctx.fillStyle = `rgba(255,255,255,${fogOpacity})`;
        ctx.fillRect(screenX, obj.y, obj.width, obj.height);
      }

      if (obj.type === 'tree') {
        ctx.fillStyle = '#5A3A1E';
        ctx.fillRect(screenX + obj.width / 2 - 24, 320, 40, 150);
        const foliageColor = obj.variant === 'special' ? '#66FFC4' : '#3FA';
        ctx.fillStyle = foliageColor;
        ctx.beginPath();
        ctx.arc(screenX + obj.width / 2, 330, obj.width * 0.90, 0, Math.PI * 2);
        ctx.fill();
      }

      if (obj.type === 'car') {
        ctx.fillStyle = '#222';
        ctx.fillRect(screenX, obj.y, obj.width, 20);
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(screenX + 10, obj.y + 20, 5, 0, Math.PI * 2);
        ctx.arc(screenX + obj.width - 10, obj.y + 20, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  });
}

// Generate objects remains mostly the same, with named buildings assigned
function generateParallaxObjects() {
  const groundY = canvas.height - 160;

  backgroundLayers.forEach(layer => {
    layer.objects = [];

    for (let i = 0; i < 100; i++) {
      const x = i * 600 + Math.random() * 200;
      let y = 0, width = 0, height = 0, variant = 0, name = '', type = 'normal';

      if (layer.type === 'building') {
        variant = i;
        width = 100 + Math.random() * 300;
        height = 180 + Math.random() * 320;
        y = canvas.height - 140 - height;

        if (Math.random() < 0.15) {  // Reduced chance for named buildings
          name = namedBuildings[Math.floor(Math.random() * namedBuildings.length)];
        }
        if (Math.random() < 0.2) type = 'fullGlass';
        if (Math.random() < 0.1) type = 'brand';

        layer.objects.push({ x, y, width, height, type: layer.type, variant, bType: type, name });
        continue;
      }

      if (layer.type === 'tree') {
        variant = i % 20 === 0 ? 'special' : Math.floor(Math.random() * 6);
        width = 100 + Math.random() * 30;
        height = 180 + Math.random() * 40;
        y = groundY - height;
      }

      if (layer.type === 'car') {
        width = 70 + Math.random() * 40;
        height = 25;
        y = canvas.height - 100 - height;
      }

      if (layer.type === 'cloud') {
        width = 120 + Math.random() * 100;
        height = 50;
        y = Math.random() * 200 + 40;
      }

      layer.objects.push({ x, y, width, height, type: layer.type, variant });
    }
  });
}

generateParallaxObjects();
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'n') {
    night = !night;
  }
});

// Toggle spotlight on/off when pressing 'S'
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 's') {
    if (night) {
    spotlightOn = !spotlightOn;
  }}
});
function drawBus() {
  const skygradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
  if (night) {
    skygradient.addColorStop(0, '#0b0c17');  // very dark blue/black
    skygradient.addColorStop(1, '#000000');  // black
  } else {
    skygradient.addColorStop(0, '#87ceeb');  // day sky blue
    skygradient.addColorStop(1, '#b0e0e6');  // lighter blue
  }


  const baseBus = buses[currentBusIndex];
  const bus = { ...baseBus };
  if (vx === 0) {
    bus.y += isLowered ? LOWER_OFFSET : 0;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
ctx.shadowBlur = 12;

  // Sky
  ctx.fillStyle = skygradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Parallax Background
  drawParallaxLayers(ctx, camX);
// 1. Sidewalk (opposite side)
ctx.fillStyle = '#bbb';
ctx.fillRect(0, canvas.height - 140, canvas.width, 40);

// 2. Perpendicular roads cutting into sidewalk
// 3. Main horizontal road (on top of sidewalk & perp roads)
ctx.fillStyle = '#333';
ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

ctx.strokeStyle = '#FFD700';
ctx.lineWidth = 4;

ctx.beginPath();
ctx.moveTo(0, canvas.height - 85);
ctx.lineTo(canvas.width, canvas.height - 85);
ctx.stroke();

drawAllIntersections(ctx, camX, bus);  // this should draw the perpendicular roads and buildings

// Parameters for highway curve
const highway = {
  baseY: canvas.height - 600,  // vertical position of highway deck
  width: 300,                  // bridge width
  deckHeight: 50,
  baseColor: '#008B8B',        // dark cyan base under road
  deckColor: '#D6BDA3',        // lighter brown deck top
  pillarWidth: 20,
  pillarHeight: 150,
  pillarSpacing: 120,          // distance between pillars along highway
  curveAmplitude: 100,         // horizontal curve amplitude
  curveFrequency: 0.0025,      // curve frequency
  zLayers: 3                   // number of layered decks
};

// Draw highway function, called after drawing bus to overlay it
function drawCurvingHighway(ctx, busX, time) {
  // We'll draw 3 decks stacked with vertical offsets
  for (let layer = 0; layer < highway.zLayers; layer++) {
    const verticalOffset = layer * (highway.deckHeight + 20); // space between decks

    // Draw bridge deck (top)
    // Curve horizontally using sine wave for smooth left-right
    const curveX = x => x + Math.sin(x * highway.curveFrequency + time * 0.002 + layer) * highway.curveAmplitude;

    // Draw highway segments spaced horizontally, centered on bus
    // We draw a range around busX so highway covers canvas width + margin
    const startX = busX - canvas.width / 2 - 500;
    const endX = busX + canvas.width / 2 + 500;

    // Draw base and deck in segments for smooth curve
    for (let x = startX; x < endX; x += highway.width) {
      const cx = curveX(x);

      // Base under road (dark cyan)
      ctx.fillStyle = highway.baseColor;
      ctx.fillRect(cx - highway.width / 2, highway.baseY - verticalOffset, highway.width, 30);

      // Deck (lighter brown)
      ctx.fillStyle = highway.deckColor;
      ctx.fillRect(cx - highway.width / 2 - 10, highway.baseY - verticalOffset - highway.deckHeight, highway.width + 20, highway.deckHeight);

      // Draw pillars under deck
      const pillarCount = Math.floor(highway.width / highway.pillarSpacing) + 1;
      ctx.fillStyle = '#654321'; // dark brown pillars
      for (let p = 0; p < pillarCount; p++) {
        const pillarX = cx - highway.width / 2 + p * highway.pillarSpacing;
        ctx.fillRect(pillarX, highway.baseY - verticalOffset + 30, highway.pillarWidth, highway.pillarHeight);
      }
    }
  }
}

  // Draw signal signs
  drawSignalSigns(ctx, camX, canvas.width);
// Draw bridge columns and bridge structure
for (const bridge of bridges) {
  const screenX = bridge.x - bus.x + canvas.width / 2;

  // Wide dark cyan base under the road
  ctx.fillStyle = '#008B8B'; // dark cyan
  ctx.fillRect(screenX - 160, canvas.height - 585, 300, 30);

  // Layered 2D "z-style" deck (brown, sits on top)
  ctx.fillStyle = '#D6BDA3'; // lighter brown bridge top
  ctx.fillRect(screenX - 170, canvas.height - 625, 320, 50);

  // Wide dark cyan base under the road
  ctx.fillStyle = '#008B8B'; // dark cyan
  ctx.fillRect(screenX + 190, canvas.height - 585, 300, 30);

  // Layered 2D "z-style" deck (brown, sits on top)
  ctx.fillStyle = '#D6BDA3'; // lighter brown bridge top
  ctx.fillRect(screenX + 180, canvas.height - 625, 320, 50);

}

ctx.save();
// Apply tilt
 const busGradient = ctx.createLinearGradient(
  bus.x - camX,
  bus.y + bus.height,
  bus.x - camX + bus.width,
  bus.y
);
if (currentBusIndex === 2) {
  ctx.save();

  // Flip vertically around a horizontal axis at Y = flipY
  const flipY = bus.y + 20;
  ctx.translate(0, flipY);
  ctx.scale(1, -1);

  // Calculate drawing origin
  const startX = bus.x - camX + bus.width - 470;
  const startY = 10;

  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(startX, startY + 40);
  ctx.lineTo(startX + 370, startY + 40);
  ctx.quadraticCurveTo(startX + 420, startY + 40, startX + 420, startY);
  ctx.lineTo(startX + 300, startY);
  ctx.lineTo(startX, startY);
  ctx.closePath();

  // === Fill style logic ===
  const useGradient = true; // 🔁 Change to false if you want solidColor

  if (useGradient) {
    const curveGradient = ctx.createLinearGradient(
      bus.x - camX,
      bus.y + bus.height,
      bus.x - camX + bus.width,
      bus.y
    );
    for (const stop of gradientStops) {
      curveGradient.addColorStop(stop.offset, stop.color);
    }
    ctx.fillStyle = curveGradient;
  } else {
    const solidColor = '#444'; //  Replace this if you want a different solid color
    ctx.fillStyle = solidColor;
  }

  ctx.fill();
  ctx.restore();
}
  for (const stop of gradientStops) {
    busGradient.addColorStop(stop.offset, stop.color);
  }

ctx.translate(bus.x - camX + bus.width / 2, bus.y + bus.height / 2);
ctx.rotate(tilt * Math.PI / 180);
ctx.translate(-(bus.x - camX + bus.width / 2), -(bus.y + bus.height / 2));

const leftX = bus.x - camX;
const rightX = leftX + bus.width;
const topY = bus.y;
const bottomY = bus.y + bus.height;
const curveStartY = topY + bus.height * 0.0;
const curveEndY = topY + bus.height * 0.59;
const ctrlOffset = 30;
if (currentBusIndex === 1) {

const flipY = bus.y + 20;
const startX = bus.x - camX + bus.width - 417;
const startY = 20;

ctx.save();

ctx.translate(0, flipY);
ctx.scale(1, -1); // Flip vertically

ctx.beginPath();

// Vertical line down (originally 60 px tall, now 42 px)
ctx.moveTo(startX - 50, startY);
ctx.lineTo(startX - 50, startY + 42);

// Adjusted horizontal line length and curve details
const totalHorizontalLength = 102.4 * 1.3; // 133 px

const lineStartX = startX - 50;
const lineY = startY + 42;

// Break down horizontal length into parts
const part1Length = totalHorizontalLength * 0.8;  // 40% straight
const part2Length = totalHorizontalLength * 0.2;  // 20% curved down 10 px
const part3Length = totalHorizontalLength * 0.8;  // 40% straight again

// Part 1: straight horizontal line (40%)
ctx.lineTo(lineStartX + part1Length, lineY);

// Part 2: curve down 10px with quadratic curve (20%)
const curveControlX = lineStartX + part1Length + 30;
const curveControlY = lineY + 10;
const curveEndX = lineStartX + part1Length + part2Length - 0;
const curveEndY = lineY + 10;

ctx.quadraticCurveTo(curveControlX, curveControlY, curveEndX, curveEndY);

// Part 3: straight horizontal line (40%) from curve end to total length, 10 px lower
ctx.lineTo(lineStartX + totalHorizontalLength, lineY + 10);

// Diagonal line \ with length scaled proportionally to vertical height

const angleDeg = 75;
const angleRad = angleDeg * Math.PI / 180;

// Original length was 30, scaled 1.5 = 45 px for 60 px height
// New length scales proportionally: 45 * (42 / 60) = 31.5 px approx
const length = 30 * 1.5 * (42 / 60); // ~31.5 px

const dx = Math.cos(angleRad) * length;
const dy = Math.sin(angleRad) * length;

ctx.lineTo(startX + dx, startY + 59 + dy);

// Close shape top, scale closing length horizontally
ctx.lineTo(startX + 170 * 1.1, startY); // 169 px
ctx.lineTo(startX, startY);

ctx.closePath();

ctx.fillStyle = 'rgba(211, 211, 211, 1)';
ctx.fill();

ctx.restore();
}
// Length of the bottom-right diagonal (studle)
const studleHeight = 10;
const studleAngleX = 45; // small inward angle

ctx.beginPath();
ctx.moveTo(leftX, topY);
ctx.lineTo(leftX, bottomY);

// Draw bottom edge to before studle
ctx.lineTo(rightX - studleAngleX + 40, bottomY);

// Add upward diagonal studle
ctx.lineTo(rightX, bottomY - studleHeight);

// Draw up-right curve
ctx.lineTo(rightX, curveEndY);
ctx.bezierCurveTo(
  rightX, curveStartY,
  rightX - ctrlOffset, topY,
  rightX - 65 - ctrlOffset, topY
);

// Flat roof back to front
ctx.lineTo(leftX, topY);
ctx.closePath();

ctx.fillStyle = busGradient;
ctx.fill();
ctx.restore();

  // --- Doors ---
  // === 1. UNIVERSAL DOOR GRADIENT DRAWING ===
ctx.save();

// Door gradient
const doorGradient = ctx.createLinearGradient(0, 0, 0, bus.doorSize.height);
doorGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
doorGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
ctx.fillStyle = doorGradient;

buses[currentBusIndex].doorPositions.forEach(doorX => {
  // Skip door 430 if it's bus 2 (we’ll draw that separately with curve)
  if (currentBusIndex === 2 && doorX === 430) return;

  const x = bus.x - camX + doorX;
  const y = bus.y + 40;
  const doorW = bus.doorSize.width;
  const doorH = bus.doorSize.height;

  ctx.fillRect(x, y, doorW, doorH);
});


ctx.restore();

// === 2. SPECIAL CURVED DOOR FOR BUS 2 ===
if (currentBusIndex === 2) {
  const doorX = 430;
  const x = bus.x - camX + doorX + 20;
  const y = bus.y + 40;
  const doorW = bus.doorSize.width - 20;
  const doorH = bus.doorSize.height;

  ctx.save();
  ctx.translate(0, y + doorH);
  ctx.scale(1, -1); // Flip over X-axis
  ctx.fillStyle = doorGradient; // use the same gradient

  ctx.beginPath();
  ctx.moveTo(x, 0);
  ctx.lineTo(x, doorH);
  ctx.lineTo(x + doorW - 10, doorH);
  ctx.quadraticCurveTo(
    x + doorW, doorH,
    x + doorW, doorH - 100
  );
  ctx.lineTo(x + doorW, 0);
  ctx.closePath();

  ctx.fill();


  ctx.restore();
}
if (currentBusIndex === 1) {{
const flipY = bus.y + 20;
ctx.translate(0, flipY);
ctx.scale(1, -1);

const startX = bus.x - camX + bus.width - 35;
const startY = -120;

ctx.beginPath();
ctx.moveTo(startX, startY);
ctx.lineTo(startX, startY + 100);

// Make horizontal segment shorter (e.g., 220px instead of 370)
ctx.lineTo(startX + 0, startY + 100);

// Adjust curve control point (was +440)
ctx.quadraticCurveTo(
  startX + 30, // control X
  startY + 100,  // control Y
  startX + 30, // end X
  startY + 0    // end Y
);

// Adjust closing top line (was +300)
ctx.lineTo(startX + 10, startY);
ctx.lineTo(startX, startY);
ctx.closePath();

ctx.fillStyle = 'rgba(30, 30, 30, 1)';
ctx.fill();

ctx.restore();
}
}

drawBackDoors(bus);
  // --- Windows ---
  function drawWindow(window) {
    ctx.save();
    const gradient = ctx.createLinearGradient(0, 0, 0, window.height);
    gradient.addColorStop(0, 'rgba(30, 30, 30, 1)');
    gradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
    ctx.fillStyle = gradient;
    ctx.fillRect(bus.x - camX + window.x, bus.y + window.y, window.width, window.height);
  }

  drawWindow(bus.window);
  drawWindow(bus.window2);



  // --- Fuel Pickups ---
  fuelPickups.forEach(pickup => {
    if (!pickup.collected) {
      ctx.fillStyle = 'orange';
      ctx.fillRect(pickup.x - bus.x + canvas.width / 2 - 10, 400, 20, 20);
    }
  });
ctx.restore();
  // --- Wheels ---
  const wheelOffsetY = tilt * 0.2;
  bus.wheelOffsets.forEach(offset => {
    ctx.save();
    const wheelX = bus.x - camX + offset;
    let wheelY = bus.y + bus.height + wheelOffsetY;
    if (driverLocked) {
      wheelY = wheelY - 10
    }
    ctx.translate(wheelX, wheelY);
    ctx.rotate(bus.wheelAngle);

    const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
    wheelGradient.addColorStop(0, '#393939');
    wheelGradient.addColorStop(0.5, '#242424');
    wheelGradient.addColorStop(1, '#101010');

    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.fillStyle = wheelGradient;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fillStyle = '#999';
    ctx.fill();

    ctx.save();
    ctx.translate(-8, -8);
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fill();
    ctx.restore();

    ctx.restore();
    drawTrainTrafficLights(ctx, camX, canvas.width);

  });

  for (const stop of stops) {
  if (stop.isStation && stop.x > bus.x - 2000) {
    drawTransitStation(ctx, stop.x, camX);
  }
}
for (const bridge of bridges) {
  const screenX = bridge.x - bus.x + canvas.width / 2;
  
  // Bridge columns and top rectangle
  ctx.fillStyle = '#CAB298'; // dark brown column
  ctx.fillRect(screenX - 55, 100, 100, 450);

  ctx.fillStyle = '#CAB298'; // dark brown column
  ctx.fillRect(screenX + 295, 100, 100, 450);

  ctx.fillStyle = '#CAB298'; // dark brown top rectangle
  ctx.fillRect(screenX - 125, 40, 590, 100);
}
// Full width brown bar at bottom, fixed to screen width

const barY = 550;
const barHeight = 100;
const barX = 0;
const barWidth = canvas.width;  // Full canvas width

ctx.fillStyle = '#999'; // dark brown bar color
ctx.fillRect(barX, barY, barWidth, barHeight);

// Labels and their glow colors
const labels = [
  { label: 'Stop Nearby', active: distance < 1000, glowColor: 'rgba(100, 150, 255, 0.7', circleColor: '#337BFF' },           
  {label: 'Stop Requested', active: pendingDropRequest, glowColor: 'rgba(255, 165, 0, 0.8)', circleColor: '#FFA500' },
  { label: 'Air Brakes', active: braking, glowColor: 'rgba(163, 217, 165, 0.8)', circleColor: '#A3D9A5' },
  { label: 'Stopped', active: vx === 0, glowColor: 'rgba(221, 0, 0, 0.7)', circleColor: '#DD0000' }                    
];

ctx.font = '10px Arial';
ctx.textAlign = 'center';

// Vertical positions for text (label above, status below)
const labelY = barY + 10;
const statusY = barY + 25;
const panelX = 35
const panelY = statusY + 85
// Horizontal spacing
const segmentWidth = barWidth / labels.length;

labels.forEach((item, i) => {
  const centerX = segmentWidth * i + segmentWidth / 2;

  // Label text (smaller, above)
  ctx.fillStyle = '#ccc';
  ctx.fillText(item.label, centerX, labelY);

  // Status indicator: circle with glow if active, gray if not
  ctx.save();
  if (item.active) {
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowColor = item.glowColor;
    ctx.shadowBlur = 18;
    ctx.fillStyle = item.circleColor;
  } else {
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#888'; // gray when off
  }

  ctx.beginPath();
  ctx.arc(centerX, statusY, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  // Reset font to default for next iteration
  ctx.font = '10px Arial';
});



  const now = performance.now();
  const deltaTime = now - lastDrawTime;
  
  lastDrawTime = now;
  drawTrainTrafficLights(ctx, camX, canvas.width);
  updateTrafficLights(deltaTime)
  updateTrainTrafficLights(deltaTime);
  drawTracks(ctx);
  xB = bus.x
  checkTrafficLightViolations(bus);
  drawTrafficLights(ctx, camX);  
// Call this every frame, passing deltaTime in milliseconds

// --- Draw Stops ---
for (const stop of stops) {
  if (!stop.collected) {
    const screenX = stop.x - camX;
    const stopY = window.innerHeight * 0.5;

    // Outer glow (different for special stops)
    ctx.beginPath();
    ctx.arc(screenX, stopY, STOP_RADIUS + 10, 0, Math.PI * 2);
    ctx.fillStyle = stop.special
      ? 'rgba(128, 128, 128, 0.4)'
      : 'rgba(100, 150, 255, 0.3)';
    ctx.fill();

    // Inner circle
    ctx.beginPath();
    ctx.arc(screenX, stopY, STOP_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = stop.special ? '#888' : '#337BFF';
    ctx.fill();
  }
}
for (const stop of stops) {
  if (!stop.collected && vx === 0 && Math.abs(bus.x - stop.x) < STOP_DETECTION_RANGE) {
    
    // Special stop check
    if (stop.special && !driverLocked) continue;

    stop.collected = true;

    // Passenger logic
    const newPassengers = Math.floor(Math.random() * 2 + 2); // 2–3
    const dropOff = Math.floor(Math.random() * 2 + 2);       // 2–3
    const basePoints = newPassengers;
    const multiplier = stop.special ? 3 : 1;
    const actualPoints = basePoints * multiplier;

    if (passengersOnBoard < 16) {
      passengersOnBoard += newPassengers;
      points += actualPoints;
      savePoints();
    } else {
      passengersOnBoard -= 6;
    }

    if (passengersOnBoard >= 4) {
      passengersOnBoard = Math.max(passengersOnBoard - dropOff, 0);
    }

    // Clear drop request
    if (nextStopRequest && stop.x >= bus.x) {
      pendingDropRequest = false;
      nextStopRequest = null;
    }

    // Save stop event to history
    saveStopHistoryEntry({
      x: (distance2) * 2,
      time: Date.now(),
      special: stop.special,
      passengersAdded: newPassengers,
      passengersDropped: dropOff,
      pointsGained: actualPoints
    });

    break;
  }
}
const stopNoticeDiv = document.getElementById('stopNotice');

for (const stop of stops) {
  if (!stop.collected && stop.x > bus.x) {
    distance = Math.floor((stop.x - bus.x) / 2);

    break;
  }
}


ctx.fillStyle = '#f0f0f0';
ctx.strokeStyle = '#333';
ctx.lineWidth = 2;
ctx.fillRect(panelX, panelY, 180, 190);
ctx.strokeRect(panelX, panelY, 180, 190);


labels.forEach((item, i) => {
  const boxY = panelY + 10 + i * 45;

  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;

  ctx.fillStyle = item.color;
  ctx.beginPath();
  ctx.moveTo(panelX + 16, boxY);
  ctx.lineTo(panelX + 34, boxY);
  ctx.quadraticCurveTo(panelX + 40, boxY, panelX + 40, boxY + 6);
  ctx.lineTo(panelX + 40, boxY + 18);
  ctx.quadraticCurveTo(panelX + 40, boxY + 24, panelX + 34, boxY + 24);
  ctx.lineTo(panelX + 16, boxY + 24);
  ctx.quadraticCurveTo(panelX + 10, boxY + 24, panelX + 10, boxY + 18);
  ctx.lineTo(panelX + 10, boxY + 6);
  ctx.quadraticCurveTo(panelX + 10, boxY, panelX + 16, boxY);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  ctx.fillStyle = 'black';
  ctx.font = '12px Arial';
  ctx.fillText(item.label, panelX + 60, boxY + 18);
});


// --- Request Drop at Future Stop ---
if (passengersOnBoard > 0 && !pendingDropRequest) {
  pendingDropRequest = true;
  nextStopRequest = stops.find(stop => stop.x > bus.x && !stop.collected);
}

// --- Highlight Requested Stop ---
if (pendingDropRequest && nextStopRequest) {
  const screenX = nextStopRequest.x - camX;
  ctx.beginPath();
  ctx.arc(screenX, window.innerHeight * 0.5, STOP_RADIUS + 10, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 220, 0, 0.6)';
  ctx.fill();
}

if (flashAlpha > 0) {
  ctx.save();
  ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  flashAlpha -= 0.1; // Decrease transparency
  if (flashAlpha < 0) flashAlpha = 0;
}

drawTrains(ctx);
  if (night && !spotlightOn) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.99)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
if (spotlightOn) {
  // Dark overlay over whole canvas (more opaque)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';  // dark shadow over everything
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Create a linear gradient for the spotlight light cone
  const busScreenX = bus.x - camX + canvas.width / 2 + 50; 
  const busScreenY = 430

  const coneLength = 500;
  const coneBaseWidth = 1200;
  const coneTipWidth = 10;

  // Create gradient along the cone's axis
  let gradient = ctx.createLinearGradient(busScreenX, busScreenY, busScreenX + coneLength, busScreenY);

  // Gradient stops - from almost transparent light to full shadow
  gradient.addColorStop(0, 'rgba(0,0,0,0)');    // fully transparent at the tip of bus
  gradient.addColorStop(0.2, 'rgba(127,127,127,0.1)');
  gradient.addColorStop(0.6, 'rgba(255,255,255,0.1)');
  gradient.addColorStop(1, 'rgba(127,127,127,0.1)');

  // Save current context and clip to cone shape
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(busScreenX, busScreenY - coneTipWidth / 2);
  ctx.lineTo(busScreenX + coneLength, busScreenY - coneBaseWidth / 2);
  ctx.lineTo(busScreenX + coneLength, busScreenY + coneBaseWidth / 2);
  ctx.lineTo(busScreenX, busScreenY + coneTipWidth / 2);
  ctx.closePath();

  ctx.clip();

  // Draw the gradient inside the cone shape
  ctx.fillStyle = gradient;
  ctx.fillRect(busScreenX, busScreenY - coneBaseWidth / 2, coneLength, coneBaseWidth);

  ctx.restore();

}
  drawTrafficLights(ctx, camX);  
  if (debugMode) {
  ctx.strokeStyle = 'lime';
  ctx.strokeRect(bus.x - camX, bus.y, bus.width, bus.height);
}
if (debugMode) {
  ctx.fillStyle = 'white';
  ctx.font = '14px monospace';
  ctx.fillText(`Bus X: ${bus.x.toFixed(0)}`, 10, 20);
  ctx.fillText(`Cam X: ${camX.toFixed(0)}`, 10, 40);
}
if (debugMode) {
  stops.forEach(stop => {
    ctx.fillStyle = stop.special ? 'yellow' : 'orange';
    ctx.fillRect(stop.x - camX, canvas.height - 110, 10, 10);
  });
}

}
drawBus()
  // Listen for keys to switch bus
  window.addEventListener('keydown', e => {
    if (e.key === '1') {
      currentBusIndex = 0;
      info.textContent = "Current: Gillig 29'";
      currentSystem === "A"
      acceleration = 0.011
      drawBus();
    } else if (e.key === '2') {
      currentBusIndex = 1;
      info.textContent = "Current: Gillig 40 HEV'";
      currentSystem === "C"
      acceleration = 0.1
      drawBus();
    } else if (e.key === '3') {
      currentBusIndex = 2;
      info.textContent = "Current: New Flyer Xcelsior 40'";
      currentSystem === "B"
      acceleration = 0.011
      drawBus();
    }
  });
  let highFriction = false;
function drawBackDoors(bus) {
  if (!bus.backDoorPositions) return;

  bus.backDoorPositions.forEach(doorX => {
    const x = bus.x - camX + doorX;
    const y = bus.y + 40;
    const doorW = bus.doorSize.width;
    const doorH = bus.doorSize.height;

    // Top Half: Black gradient
    const topHeight = doorH / 1.5;
    const topGradient = ctx.createLinearGradient(0, y, 0, y + topHeight);
    topGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
    topGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
    ctx.fillStyle = topGradient;
    ctx.fillRect(x, y, doorW, topHeight);

    // Bottom Half: Darker than bus body
    const busGradient = ctx.createLinearGradient(
      bus.x - camX,
      bus.y + bus.height,
      bus.x - camX + bus.width,
      bus.y
    );

    for (const stop of gradientStops) {
      busGradient.addColorStop(stop.offset, stop.color);
    }

    ctx.fillStyle = busGradient;
    ctx.fillRect(x, y + topHeight, doorW, doorH / 3);
  });


}// ==== GLOBALS ====

let lastTimestamp = performance.now();



// Signal signs globals

// ==== FUNCTIONS ====

// Traffic Lights Generation and Update (unchanged from before)

function drawTrafficLights(ctx, camX, canvasWidth) {
  const y = 520;

  trafficLights.forEach(light => {
    const x = light.x - camX;
    if (x < -100 || x > canvasWidth + 100) return;

    const color = lightColors[light.state] || "#00ff00";

    ctx.beginPath();
    ctx.arc(x, y, lightRadius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  });
}

// Signal signs generation and cleanup
function updateSignalSigns(bus, canvasWidth) {
  const busX = bus.x;

  // Remove signs far behind the bus
  for (let i = signalSigns.length - 1; i >= 0; i--) {
    if (signalSigns[i].x < busX - 300) {
      signalSigns.splice(i, 1);
    }
  }

  // Add new signs ahead if fewer than maxSigns
  while (signalSigns.length < maxSigns) {
    let nextLight = null;
    for (let light of trafficLights) {
      if (light.x > busX + 100) {
        const hasSign = signalSigns.some(sign => 
          Math.abs(sign.x - (light.x - 100)) < 10 || 
          Math.abs(sign.x - (light.x - 2000)) < 10
        );
        if (!hasSign) {
          nextLight = light;
          break;
        }
      }
    }
    if (!nextLight) break;

    const possibleOffsets = [500, 1000].filter(offset => 
      !signalSigns.some(sign => Math.abs(sign.x - (nextLight.x - offset)) < 10)
    );
    if (possibleOffsets.length === 0) break;

    const offset = possibleOffsets[Math.floor(Math.random() * possibleOffsets.length)];
    const signX = nextLight.x - offset;

    if (signX > busX - 1000) {
      signalSigns.push({ x: signX, distance: offset });
    } else {
      break;
    }
  }
}

// Draw signal signs on canvas
function drawSignalSigns(ctx, camX, canvasWidth) {
  const boxColor = "#1abf00";
  const textColor = "#fff";
  const boxWidth = 110;
  const boxHeight = 30;

  signalSigns.forEach(sign => {
    const x = sign.x - camX;
    const y = 150;

    if (x < -100 || x > canvasWidth + 100) return;


    // Sign box
    ctx.fillStyle = boxColor;
    ctx.fillRect(x - boxWidth / 2, y - boxHeight, boxWidth, boxHeight);

    // Text
    ctx.fillStyle = textColor;
    ctx.font = "bold 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("NEXT SIGNAL", x, y - boxHeight + 12);
    ctx.fillText(`${sign.distance}px`, x, y - boxHeight + 25);
  });
}
function showStopHistory() {
  const history = JSON.parse(localStorage.getItem("stopHistory") || "[]");
  const display = document.getElementById("stopHistoryDisplay");

  if (!history.length) {
    display.innerHTML = "<div class='entry empty'>No stop history yet.</div>";
    return;
  }

  display.innerHTML = history.map((entry, index) => {
    const date = new Date(entry.time).toLocaleString();
    return `
      <div class="entry">
        <div class="entry-header">#${index + 1} • ${entry.special ? "Kneeling" : "Standard"}</div>
        <div class="entry-body">
          <div><strong>Time:</strong> ${date}</div>
          <div><strong>Stop Position:</strong> ${entry.x}px</div>
          <div><strong>Passengers:</strong> +${entry.passengersAdded}, -${entry.passengersDropped}</div>
          <div><strong>Points:</strong> +${entry.pointsGained}</div>
        </div>
      </div>
    `;
  }).join('');
}

function checkTrafficLightViolations(bus) {
  for (let light of trafficLights) {
    if (light.state === 2) { // Red light
      const dx = bus.x - light.x;

      if (Math.abs(dx) < 100 && bus.vx > 0.1 && !light.violated) {
        points -= 10;
savePoints()
        console.log("Violation! -10 Points. Points now:", points);
        light.violated = true;

        // Trigger flash
        flashAlpha = 1;
        flashTimer = 10; // Frames to fade out
      }

      if (Math.abs(dx) > 200) {
        light.violated = false;
      }
    }
  }
}

function updateViolationMessage(deltaTime) {
  if (violationMessageTimer > 0) {
    violationMessageTimer -= deltaTime;
    if (violationMessageTimer < 0) violationMessageTimer = 0;
  }
}

function drawViolationMessage(ctx) {
  if (violationMessageTimer > 0) {
    ctx.fillStyle = "red";
    ctx.font = "bold 24px Arial";
    ctx.fillText("TRAFFIC VIOLATION!", 300, 50);
  }
}

function animate(timestamp) {
  const bus = buses[currentBusIndex];
  const deltaTime = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  if (!driverLocked) {
    if (accelerating) {
      vx += acceleration;
      if (vx > maxSpeed) vx = maxSpeed;
    } else {
      if (vx < 0.01) {
        vx = 0;
        braking = false;
        if (currentBusIndex === 1) {
          acceleration = 0.1
        } else {
          acceleration = 0.011
        }
      }
      if (braking) {
        vx *= 0.975;
      } else {
        vx *= 0.9999;
      }
    }
  } else {
    vx = 0;
  }
  if (vx > maxSpeed) vx = maxSpeed;

  bus.vx = vx;
  bus.x += bus.vx;
  bus.wheelAngle += bus.vx / 30;

  if (Math.abs(camFollowX - bus.x) > 100) {
    camX = bus.x - 100;
    delayTimer = 0;
  } else {
    delayTimer++;
    if (delayTimer > 120) {
      camFollowX = bus.x;
      camX += (camFollowX - camX) * 0.05;
    }
  }
checkTrainSpawn(bus);

const trainApproaching = trains.some(train =>
  trainTracks.some(track =>
    Math.abs(train.worldX - track.x) < 100
  )
);
generateTrainTrafficLights(bus.x);
updateTrainTrafficLights(deltaTime);

generateTracksUpTo(bus.x + 100000); // Generate tracks 100k ahead of bus
checkTrainSpawn(bus);

updateTrainTrafficLights(deltaTime);
if (isTrainLightBlocking(bus.x)) {
      vx = 0
          acceleration = 0
    accelerating = false
    acceleration = 0
    braking = true
    friction = 0.01
    vx = 0
}

  generateTrafficLights(bus.x);
  updateTrafficLights(deltaTime);
  updateSignalSigns(bus, ctx.canvas.width);
  drawMinimap(bus, camX);

  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  drawBus();
  drawTrafficLights(ctx, camX, ctx.canvas.width);
  drawSignalSigns(ctx, camX, ctx.canvas.width);

  checkTrafficLightViolations(bus);
  updateViolationMessage(deltaTime);
  drawViolationMessage(ctx);

  if (braking) {accelerating = false;
  }
  document.getElementById("pointsDisplay").innerText = "Points: " + points;

  requestAnimationFrame(animate);
}

// Start animation
animate();
</script>
