<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stopped Go Beta 3.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #111;
            font-family: 'Inter', sans-serif;
        }
        #gameCanvas {
            display: block;
            touch-action: none;
        }
        #audioOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body class="font-sans">

<canvas id="gameCanvas"></canvas>

<div id="audioOverlay">
    <button id="startButton" class="bg-blue-600 text-white p-4 rounded-xl shadow-xl text-2xl hover:bg-blue-500 transition-colors">
        Start Engine (Click to begin)
    </button>
</div>

<img id="busImage" src="2074.jpeg" alt="Bus Model XN40">
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; top: 10px; right: 65px; height: 50px; width: 50px; 
               background-color: #f87171; color: white; border: none; border-radius: 32px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);" 
        onclick="e()">E</button>
<button id="gasBtn" 
        style="position: fixed; z-index: 9999; bottom: 10px; right: 10px; height: 100px; width: 50px; 
               background-color: #121212; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);" 
        onclick="go()">[]</button>
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; bottom: 10px; right: 65px; height: 50px; width: 50px; 
               background-color: #121212; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);" 
        onclick="stop()">-</button>
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; top: 10px; right: 10px; height: 50px; width: 50px; 
               background-color: #08de70; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);" 
        onclick="c()">></button>
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; top: 10px; left: 65px; height: 50px; width: 50px; 
               background-color: #3a537e; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);" 
        onclick="one()">][</button>
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; top: 10px; left: 10px; height: 50px; width: 50px; 
               background-color: #08de70; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);" 
        onclick="z()"><</button>
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; bottom: 65px; left: 10px; height: 50px; width: 50px; 
               background-color: #00FFFF; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);" 
        onclick="d()">D</button>
<button id="engineToggleBtn" 
        style="position: fixed; z-index: 9999; bottom: 10px; left: 10px; height: 50px; width: 50px; 
               background-color: #9370DB; color: white; border: none; border-radius: 8px; 
               font-weight: bold; font-size: 20px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);" 
        onclick="n()">N</button>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const busImage = document.getElementById('busImage');
    
    let processedBusCanvas = null;

    let isAccelerating = false;
    let isBraking = false;
    let isGameRunning = false;
    
    let isEngineOn = false;
    let startSequenceTimer = 0;
    
    let isLeftBlinkerOn = false;
    let isRightBlinkerOn = false;
    let blinkerTimer = 0;
    const BLINK_RATE = 0.5;
    let isBusStopNear = false;
    const PROXIMITY_THRESHOLD = 15000;

    const TIME_PHASES = ['midnight', 'sunrise', 'morning', 'noon', 'afternoon', 'evening', 'sunset', 'night'];
    let timePhaseIndex = 0;
    let timePhaseTimer = 0;
    const TIME_PER_PHASE = 30;
    
    let currentWeather = 'clear';
    let weatherChangeTimer = 0;
    const WEATHER_DURATION = 180;
    
    let rainParticles = [];
    let snowParticles = [];
    const PARTICLE_COUNT = 150;
    let fogIntensity = 0;


    const ROAD_HEIGHT = 40; 
    const SHOULDER_HEIGHT = 20;
    const DASHBOARD_HEIGHT_RATIO = 0.3; 
    let ROAD_Y = 0; 

    const BUS_STOP_WIDTH = 20; 
    const BUS_STOP_HEIGHT = 10; 
    const BUS_STOP_SPAWN_RATE = 0.00065; 
    const STOP_DISTANCE_THRESHOLD = 15000; 
    const BASE_STOP_INTERVAL = 15000;
    const STOP_INTERVALS = [10000, 25000, 40000];
    let currentIntervalIndex = 0;
    let nextStopDistance = 15000;
    let score = 0;
    let passengersOnBus = 0;
    const MAX_PASSENGERS = 32;

    let stopRequested = false; 

    let bus = {
        width: 630, 
        height: 300, 
        x: 100, 
        y: 0, 
        speed: 0, 
        maxSpeed: 30.0, 
        acceleration: 0.025, 
        deceleration: 0.15, 
        friction: 0.005, 
        neutralFriction: 0.02, 
        gear: 'DRIVE' 
    };
let lastTime = 0;
let fps = 0;
let frameCount = 0;
let fpsTimer = 0;
    let lineXOffset = 0; 
    const TIRE_DOWN_SHIFT = 25; 
    let busStops = []; 
    let cruiseGainLevel = 0.005;
    let ctxB, engineOsc, engineGain, filter, delay, delayGain;
    let noiseGain, whiteNoise, vibrationOsc, vibrationGain;
    let cruiseToneOsc, cruiseToneOscGain;
    let idleLFO = null, idleLFOGain = null;
    let frequency = 160, gainLevel = 2;
    let vxTimer = 0, lastAccelTime = 0;
    let cruising = false; 
    const FREQ_MIN = 160, FREQ_MAX = 800;
    const GAIN_MIN = 0.1, GAIN_MAX = 0.5;
    let cfrequency = 900; 
    let speedTimer = 0;
    
    let airNoise, airGain, airFilter;
    const NEUTRAL_ENGINE_GAIN = 1.5;
    const NEUTRAL_NOISE_GAIN = 1.02;
    
    const VIB_FREQ_DRIVE = 1.5; 
    const VIB_FREQ_IDLE = 1.0;
    const VIB_FREQ_NEUTRAL = 5; 

    let brakePulseTimer = 0; 
    const PULSE_DURATION = 0.8; 
    const PULSE_COUNT = 4; 
    
    let tuneOsc, tuneGain; 
    
    let hornOsc, hornGain, hornFilter; 
    
    let isHorning = false;
    
    let blinkerOsc, blinkerGain;
    let lastBlinkTime = 0;
    let blinkerSoundPlaying = false; 

function n() {
    bus.gear = 'NEUTRAL'
}
function d() {
    bus.gear = 'DRIVE'
}
function z() {
    isLeftBlinkerOn = !isLeftBlinkerOn
}
function c() {
    isRightBlinkerOn = !isRightBlinkerOn
}
    const mapRange = (value, fromMin, fromMax, toMin, toMax) => {
        return (value - fromMin) * (toMax - toMin) / (fromMax - fromMin) + toMin;
    };
    
    function getPhaseDarkness(phase) {
        switch (phase) {
            case 'midnight':
                return 0.65;
            case 'sunrise':
                return 0.35;
            case 'morning':
                return 0.05; 
            case 'noon':
                return 2.6;
            case 'afternoon':
                return 3;
            case 'evening':
                return 1.3; 
            case 'sunset':
                return 0.5;
            case 'night':
                return 0.6;
            default:
                return 0.0;
        }
    }
    
    function processImageForTransparency() {
        if (busImage.naturalWidth === 0) {
            console.error("Image not loaded: naturalWidth is 0. Cannot process transparency.");
            return;
        }

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = busImage.naturalWidth;
        tempCanvas.height = busImage.naturalHeight;
        const tempCtx = tempCanvas.getContext('2d');

        tempCtx.drawImage(busImage, 0, 0);

        try {
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];     
                const g = data[i + 1]; 
                const b = data[i + 2]; 

                if (r > 240 && g > 240 && b > 240) {
                    data[i + 3] = 0;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);
            processedBusCanvas = tempCanvas;
            console.log("Bus image processed for transparency.");
        } catch (e) {
            console.warn("Could not process image for transparency (Security Taint/CORS issue). Falling back to direct image draw.", e.message);
            processedBusCanvas = tempCanvas; 
        }
    }
    
    function initWeatherParticles() {
        rainParticles = [];
        snowParticles = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            rainParticles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 1,
                speed: Math.random() * 5 + 10 
            });
            snowParticles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 3 + 1,
                speed: Math.random() * 0.5 + 2,
                drift: Math.random() * 0.5 - 0.25 
            });
        }
    }


    const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const dashY = canvas.height - (canvas.height * DASHBOARD_HEIGHT_RATIO);
        const positionOffset = 30; 
        
        ROAD_Y = dashY - ROAD_HEIGHT + positionOffset;

        bus.y = ROAD_Y - bus.height + TIRE_DOWN_SHIFT;
        
        initWeatherParticles();
    };
    window.addEventListener('resize', resizeCanvas);


function generateBusStop() {
        nextStopDistance -= bus.speed; 
        
        if (nextStopDistance <= 0 && bus.speed > 0.5) {
            busStops.push({
                x: canvas.width,
                width: BUS_STOP_WIDTH,
                height: BUS_STOP_HEIGHT,
                y: ROAD_Y + ROAD_HEIGHT + SHOULDER_HEIGHT - BUS_STOP_HEIGHT 
            });
            
            const nextInterval = STOP_INTERVALS[currentIntervalIndex];

            nextStopDistance = nextInterval + nextStopDistance;
            
            currentIntervalIndex = (currentIntervalIndex + 1) % STOP_INTERVALS.length;
            
            console.log(`New Bus Stop spawned. Next interval: ${nextInterval} units.`);
        }
    }
    function updateBusStops() {
        isBusStopNear = false;
        
        for (let i = busStops.length - 1; i >= 0; i--) {
            const stop = busStops[i];
            stop.x -= bus.speed; 
            
            const distance = stop.x - (bus.x + bus.width); 

            if (distance > -bus.width && distance < PROXIMITY_THRESHOLD) {
                isBusStopNear = true; 
            }

            if (stop.x < -stop.width) {
                busStops.splice(i, 1);
            }
        }
    }

    function drawBusStops() {
        ctx.fillStyle = '#10B981'; 
        
        busStops.forEach(stop => {
            ctx.fillRect(stop.x, stop.y, stop.width, stop.height);
            
            const circleX = stop.x + stop.width / 2;
            const circleY = stop.y - 40;
            const circleRadius = 12;

            ctx.beginPath();
            
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 15; 
            
            ctx.arc(circleX, circleY, circleRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 200, 255, 0.8)';
            ctx.fill();
            
            ctx.shadowBlur = 0; 
            ctx.shadowColor = 'transparent';

            ctx.fillStyle = 'white';
            ctx.font = 'bold 8px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BUS', circleX, circleY + 3);
        });
        
        ctx.shadowBlur = 0; 
        ctx.shadowColor = 'transparent';
    }


    function getSkyColor(phase) {
        switch (phase) {
            case 'midnight':
                return '#000000';
            case 'sunrise':
                return '#DDA260';
            case 'morning':
                return '#B9F2FF';
            case 'noon':
                return '#4BDEFF';
            case 'afternoon':
                return '#4BDEFF';
            case 'evening':
                return '#228CC1';
            case 'sunset':
                return '#C15F22';
            case 'night':
                return '#04263F';
            default:
                return '#66AAFF';
        }
    }
    
    function drawRoad() {
        const currentPhase = TIME_PHASES[timePhaseIndex];
        const nextPhase = TIME_PHASES[(timePhaseIndex + 1) % TIME_PHASES.length];
        
        const ratio = timePhaseTimer / TIME_PER_PHASE;
        
        const lerpColor = (startColor, endColor, ratio) => {
            const startRGB = parseInt(startColor.substring(1), 16);
            const endRGB = parseInt(endColor.substring(1), 16);
            
            const sr = (startRGB >> 16) & 0xFF;
            const sg = (startRGB >> 8) & 0xFF;
            const sb = startRGB & 0xFF;
            
            const er = (endRGB >> 16) & 0xFF;
            const eg = (endRGB >> 8) & 0xFF;
            const eb = endRGB & 0xFF;
            
            const r = Math.round(sr + (er - sr) * ratio);
            const g = Math.round(sg + (eg - sg) * ratio);
            const b = Math.round(sb + (eb - sb) * ratio);
            
            const color = (r << 16) | (g << 8) | b;
            return '#' + color.toString(16).padStart(6, '0');
        };

        const startColor = getSkyColor(currentPhase);
        const endColor = getSkyColor(nextPhase);
        const skyColor = lerpColor(startColor, endColor, ratio);

        ctx.fillStyle = skyColor; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#333';
        ctx.fillRect(0, ROAD_Y, canvas.width, ROAD_HEIGHT);

        ctx.fillStyle = '#555';
        ctx.fillRect(0, ROAD_Y + ROAD_HEIGHT, canvas.width, SHOULDER_HEIGHT); 
    }

    function drawLaneLines() {
        const centerLineY = ROAD_Y + ROAD_HEIGHT / 2; 
        const lineThickness = 10;
        
        ctx.fillStyle = '#EBEF34'; 
        ctx.fillRect(0, centerLineY - lineThickness / 2, canvas.width, lineThickness);
        
        const lineLength = 50;
        const lineGap = 40;
        const TILE_WIDTH = lineLength + lineGap;
        
        lineXOffset -= bus.speed; 
        
        if (lineXOffset < -TILE_WIDTH) {
            lineXOffset += TILE_WIDTH;
        }

        ctx.fillStyle = 'rgba(50, 50, 50, 0.5)'; 
        for (let x = lineXOffset - TILE_WIDTH; x < canvas.width; x += TILE_WIDTH) {
            ctx.fillRect(x, ROAD_Y, lineLength, ROAD_HEIGHT);
        }
    }

    function drawBus() {
        if (processedBusCanvas) {
            ctx.drawImage(processedBusCanvas, bus.x, bus.y + 10, bus.width, bus.height);
        } else {
            ctx.fillStyle = '#FFD700'; 
            ctx.fillRect(bus.x, bus.y, bus.width, bus.height); 
        }
    }
    
    function drawSceneDarkness() {
        const currentPhase = TIME_PHASES[timePhaseIndex];
        const nextPhase = TIME_PHASES[(timePhaseIndex + 1) % TIME_PHASES.length];
        
        const ratio = timePhaseTimer / TIME_PER_PHASE; 
        
        const startAlpha = getPhaseDarkness(currentPhase);
        const endAlpha = getPhaseDarkness(nextPhase);
        
        const darknessAlpha = startAlpha + (endAlpha - startAlpha) * ratio;

        if (darknessAlpha > 0.01) {
            ctx.fillStyle = `rgba(0, 0, 0, 0.3)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }
    
    function drawDashboard() {
        const dashHeight = canvas.height * DASHBOARD_HEIGHT_RATIO;
        const dashY = canvas.height - dashHeight;

        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(canvas.width, dashY + 50);
        ctx.quadraticCurveTo(canvas.width / 2, dashY, 0, dashY + 50);
        ctx.closePath();

        ctx.fillStyle = 'rgba(20, 20, 30, 0.95)'; 
        ctx.fill();
        ctx.strokeStyle = '#4A4E54';
        ctx.lineWidth = 3;
        ctx.stroke();

        const INDICATOR_SIZE = 25;
        const INDICATOR_SPACING = 25;
        
        const NUM_INDICATORS = 7; 
        const totalWidth = NUM_INDICATORS * INDICATOR_SIZE + (NUM_INDICATORS - 1) * INDICATOR_SPACING;
        const startX = canvas.width / 2 - totalWidth / 2;
        const indicatorY = dashY + 40; 

        const drawIndicator = (x, y, size, color, condition, label, isBlinker = false) => {
            const radius = size * 0.2;
            
            let showLight = condition;
            if (isBlinker) {
                showLight = condition && Math.floor(blinkerTimer / BLINK_RATE) % 2 === 0;
            }

            let fillColor = showLight ? color : 'rgba(50, 50, 50, 0.4)';
            
            if (showLight) {
                ctx.shadowColor = color;
                ctx.shadowBlur = isBlinker ? 20 : 15;
            } else {
                ctx.shadowBlur = 0; 
                ctx.shadowColor = 'transparent';
            }

            ctx.fillStyle = fillColor;
            
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + size - radius, y);
            ctx.arcTo(x + size, y, x + size, y + radius, radius);
            ctx.lineTo(x + size, y + size - radius);
            ctx.arcTo(x + size, y + size, x + size - radius, y + size, radius);
            ctx.lineTo(x + radius, y + size);
            ctx.arcTo(x, y + size, x, y + size - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0; 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = 'bold 10px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + size / 2, y + size + 15);
        };
        
        let currentX = startX;
        const LIME_GREEN = '#32CD32';

        drawIndicator(
            currentX,
            indicatorY,
            INDICATOR_SIZE,
            LIME_GREEN,
            isLeftBlinkerOn,
            '<',
            true
        );
        currentX += INDICATOR_SIZE + INDICATOR_SPACING;

        drawIndicator(
            currentX, 
            indicatorY, 
            INDICATOR_SIZE, 
            '#00BFFF',
            isBusStopNear,
            'CLOSE'
        );
        currentX += INDICATOR_SIZE + INDICATOR_SPACING;

        drawIndicator(
            currentX, 
            indicatorY, 
            INDICATOR_SIZE, 
            '#FF4136', 
            bus.speed === 0 && isEngineOn,
            'STOP'
        );
        currentX += INDICATOR_SIZE + INDICATOR_SPACING;


        drawIndicator(
            currentX, 
            indicatorY, 
            INDICATOR_SIZE, 
            '#32CD32', 
            isBraking,
            'BRAKE'
        );
        currentX += INDICATOR_SIZE + INDICATOR_SPACING;


        drawIndicator(
            currentX, 
            indicatorY, 
            INDICATOR_SIZE, 
            '#ADFF2F', 
            isEngineOn,
            'ENG'
        );
        currentX += INDICATOR_SIZE + INDICATOR_SPACING;


        const gearGlowColor = bus.gear === 'DRIVE' ? '#00FFFF' : '#9370DB'; 
        const gearCondition = bus.gear === 'NEUTRAL' || bus.gear === 'DRIVE'; 
        drawIndicator(
            currentX, 
            indicatorY, 
            INDICATOR_SIZE, 
            gearGlowColor, 
            isEngineOn && gearCondition, 
            bus.gear === 'DRIVE' ? 'DRIVE' : 'NEU'
        );
        currentX += INDICATOR_SIZE + INDICATOR_SPACING;
        
        
        drawIndicator(
            currentX,
            indicatorY,
            INDICATOR_SIZE,
            LIME_GREEN,
            isRightBlinkerOn,
            '>',
            true
        );

        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
        
        const gaugeX = canvas.width * 0.25;
        const gaugeY = canvas.height - dashHeight / 2;
        const gaugeRadius = dashHeight * 0.3;

        ctx.beginPath();
        ctx.arc(gaugeX, gaugeY, gaugeRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
        ctx.strokeStyle = '#555';
        ctx.stroke();

        const normalizedSpeed = bus.speed / bus.maxSpeed; 
        const startAngle = 1.5 * Math.PI; 
        const endAngle = 2.25 * Math.PI; 
        const angle = mapRange(normalizedSpeed, 0, 1, startAngle, endAngle);

        ctx.save();
        ctx.translate(gaugeX, gaugeY);
        ctx.rotate(angle);

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -gaugeRadius * 0.9);
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#EBEF34'; 
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(0, 0, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#EBEF34';
        ctx.fill();

        ctx.restore();

        ctx.fillStyle = '#EBEF34';
        ctx.font = '48px Consolas, monospace';
        ctx.textAlign = 'center';
        
        const actualSpeedVX = bus.speed * 10;
        const displaySpeed = Math.round(actualSpeedVX / 4);
        const center_Y_Position = canvas.height - dashHeight / 2 + 50 
        
        ctx.fillText(displaySpeed.toString().padStart(2, '0'), canvas.width / 2, center_Y_Position);
        
        ctx.font = '16px Inter, sans-serif';
        
        const infoX = canvas.width * 0.75;
        const infoY = canvas.height - dashHeight / 2 - 20;
        
        ctx.textAlign = 'left';
        
        ctx.fillStyle = passengersOnBus >= MAX_PASSENGERS ? '#FF4136' : 'white';
        ctx.font = '24px Consolas, monospace';
        ctx.fillText(`PAX: ${passengersOnBus.toString().padStart(2, '0')}/${MAX_PASSENGERS}`, infoX - 50, infoY);

        ctx.fillStyle = '#ADFF2F';
        ctx.font = '24px Consolas, monospace';
        ctx.fillText(`SCORE: ${score}`, infoX - 50, infoY + 30);
        
        if (stopRequested) {
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 18px Inter, sans-serif';
            ctx.fillText('STOP REQUESTED!', infoX - 50, infoY + 60);
        }
        
        ctx.fillStyle = fps < 30 ? '#FF4136' : '#ADFF2F'; 
        ctx.font = '24px Consolas, monospace';
        ctx.textAlign = 'right';
        
        const fpsY = canvas.height - dashHeight / 2 - 50; 
        ctx.fillText(`FPS: ${fps}`, canvas.width - 50, fpsY); 
        ctx.textAlign = 'left';
        
    }
    
    function updateWeatherParticles(FRAME_TIME) {
        if (currentWeather === 'rain') {
            for (let i = 0; i < rainParticles.length; i++) {
                const p = rainParticles[i];
                p.y += (p.speed + bus.speed * 0.5) * FRAME_TIME * 60;
                p.x -= bus.speed * 0.5;
                
                if (p.y > canvas.height) {
                    p.y = -p.size;
                    p.x = Math.random() * canvas.width;
                }
                if (p.x < 0) {
                    p.x = canvas.width + p.size;
                }
            }
        } else if (currentWeather === 'snow') {
            for (let i = 0; i < snowParticles.length; i++) {
                const p = snowParticles[i];
                p.y += p.speed * FRAME_TIME * 60;
                p.x += p.drift - (bus.speed * 0.1); 
                
                if (p.y > canvas.height) {
                    p.y = -p.size;
                    p.x = Math.random() * canvas.width;
                }
                if (p.x < 0) {
                    p.x = canvas.width + p.size;
                }
            }
        }

        if (fogIntensity > 0.01) {
            const fogColor = 'rgba(150, 150, 150, 0.15)'; 

            ctx.fillStyle = fogColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    function drawWeather() {
        if (currentWeather === 'rain') {
            ctx.fillStyle = 'rgba(173, 216, 230, 0.6)';
            rainParticles.forEach(p => {
                ctx.fillRect(p.x, p.y, 2, p.size * 3);
            });
        } else if (currentWeather === 'snow') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            snowParticles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        if (fogIntensity > 0.01) {
            const fogColor = 'rgba(150, 150, 150, 0.2)'; 

            ctx.fillStyle = fogColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        if (currentWeather !== 'clear' || fogIntensity > 0.1) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }
    
    function handleTimeAndWeather(FRAME_TIME) {
        timePhaseTimer += FRAME_TIME;
        weatherChangeTimer += FRAME_TIME;

        if (timePhaseTimer >= TIME_PER_PHASE) {
            timePhaseTimer -= TIME_PER_PHASE;
            timePhaseIndex = (timePhaseIndex + 1) % TIME_PHASES.length;

            if (TIME_PHASES[timePhaseIndex] === 'morning') {
                currentWeather = 'fog';
                weatherChangeTimer = 0; 
            }
        }

        if (weatherChangeTimer >= WEATHER_DURATION) {
            weatherChangeTimer = 0;
            const currentPhase = TIME_PHASES[timePhaseIndex];
            
            let newWeather = 'clear';
            const chance = Math.random();

            if (currentPhase === 'morning') {
                newWeather = 'fog';
            } else if (currentPhase === 'noon' && chance < 0.4) {
                newWeather = 'rain';
            } else if (['night', 'midnight'].includes(currentPhase) && chance < 0.2) {
                newWeather = 'snow';
            } else if (chance < 0.2) {
                newWeather = 'fog';
            }
            
            if (newWeather !== currentWeather) {
                 currentWeather = newWeather;
            }
        }
        
        if (TIME_PHASES[timePhaseIndex] === 'morning' && currentWeather !== 'fog') {
             currentWeather = 'fog';
        }
        
        if (['sunrise', 'noon', 'afternoon', 'evening'].includes(TIME_PHASES[timePhaseIndex]) && currentWeather === 'snow') {
             currentWeather = 'clear';
        }
        
        const TARGET_FOG_ALPHA = (currentWeather === 'fog') 
            ? (TIME_PHASES[timePhaseIndex] === 'morning' ? 0.5 : 0.3) 
            : 0;
            
        const FADE_RATE = 0.03 * FRAME_TIME; 

        if (fogIntensity < TARGET_FOG_ALPHA) {
            fogIntensity = Math.min(TARGET_FOG_ALPHA, fogIntensity + FADE_RATE);
        } else if (fogIntensity > TARGET_FOG_ALPHA) {
            fogIntensity = Math.max(TARGET_FOG_ALPHA, fogIntensity - FADE_RATE);
        }
    }


    function createWhiteNoiseB() {
      const buffer = ctxB.createBuffer(1, ctxB.sampleRate * 2, ctxB.sampleRate);
      const data = buffer.getChannelData(0);

      let lastValue = 0;
      for (let i = 0; i < data.length; i++) {
        const rand = Math.random() * 2 - 1;
        data[i] = (lastValue + rand * 0.05) / 1.25;
        lastValue = data[i];
      }

      const source = ctxB.createBufferSource();
      source.buffer = buffer;
      source.loop = true;
      return source;
    }

    function playAirReleaseSound() {
        if (!ctxB) return;
        const now = ctxB.currentTime;
        
        airFilter.frequency.setValueAtTime(4000, now);
        airFilter.Q.setValueAtTime(10, now);

        airGain.gain.cancelScheduledValues(now);
        airGain.gain.setValueAtTime(0, now);
        airGain.gain.linearRampToValueAtTime(2.3, now + 0.05);
        airGain.gain.linearRampToValueAtTime(0, now + 0.5);
    }
    
    function playBlinkerSound() {
        if (!ctxB || !isEngineOn) return;

        const isBlinkerActive = isLeftBlinkerOn || isRightBlinkerOn;

        if (isBlinkerActive) {
            const now = ctxB.currentTime;
            
            if (now - lastBlinkTime >= BLINK_RATE) {
                lastBlinkTime = now;
                
                blinkerOsc.frequency.setValueAtTime(5310, now);
                blinkerGain.gain.cancelScheduledValues(now);
                blinkerGain.gain.setValueAtTime(0.5, now);
                blinkerGain.gain.linearRampToValueAtTime(0.0001, now + 0.05);
            }
            
            if (!blinkerSoundPlaying) {
                 blinkerGain.gain.setTargetAtTime(0.0001, now, 0.01); 
                 blinkerSoundPlaying = true;
            }

        } else if (blinkerSoundPlaying) {
             blinkerSoundPlaying = false;
             lastBlinkTime = 0;
             blinkerGain.gain.cancelScheduledValues(ctxB.currentTime);
             blinkerGain.gain.setValueAtTime(0, ctxB.currentTime);
        }
    }

    function startHorn() {
        if (!ctxB || isHorning) return;
        isHorning = true;
        
        const now = ctxB.currentTime;
        const HORN_FREQ = 400;
        const HORN_GAIN = 0.6; 
        
        hornOsc.frequency.setValueAtTime(HORN_FREQ, now);
        
        hornGain.gain.cancelScheduledValues(now);
        hornGain.gain.setValueAtTime(0.0001, now);
        hornGain.gain.linearRampToValueAtTime(HORN_GAIN, now + 0.05);
    }

    function stopHorn() {
        if (!ctxB || !isHorning) return;
        isHorning = false;
        
        const now = ctxB.currentTime;
        
        hornGain.gain.cancelScheduledValues(now);
        hornGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2); 
    }

function initAudioB() {
      ctxB = new (window.AudioContext || window.webkitAudioContext)();

      engineOsc = ctxB.createOscillator();
      engineOsc.type = 'triangle';
      engineOsc.frequency.value = 0.1;

      engineGain = ctxB.createGain();
      engineGain.gain.value = 0.8;

      filter = ctxB.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 10;
      filter.Q.value = 1.5;

      delay = ctxB.createDelay();
      delay.delayTime.value = 0.00005;

      delayGain = ctxB.createGain();
      delayGain.gain.value = 1e-15; 

      whiteNoise = createWhiteNoiseB();
      noiseGain = ctxB.createGain();
      noiseGain.gain.value = 0.2;

      vibrationOsc = ctxB.createOscillator();
      vibrationOsc.frequency.value = 1;
      vibrationGain = ctxB.createGain();
      vibrationGain.gain.value = 0.8;

      cruiseToneOsc = ctxB.createOscillator();
      cruiseToneOsc.type = 'sine';
      cruiseToneOsc.frequency.value = 900;

      cruiseToneOscGain = ctxB.createGain();
      cruiseToneOscGain.gain.value = cruiseGainLevel; 

      airNoise = createWhiteNoiseB(); 
      airFilter = ctxB.createBiquadFilter();
      airFilter.type = 'highpass';
      airFilter.frequency.value = 4000;
      airFilter.Q.value = 10; 
      airGain = ctxB.createGain();
      airGain.gain.value = 0; 

      tuneOsc = ctxB.createOscillator();
      tuneOsc.type = 'sine';
      tuneOsc.frequency.value = 0;
      tuneGain = ctxB.createGain();
      tuneGain.gain.value = 0;
      
      hornOsc = ctxB.createOscillator();
      hornOsc.type = 'sine';
      hornOsc.frequency.value = 0;
      hornFilter = ctxB.createBiquadFilter();
      hornFilter.type = 'highpass'; 
      hornFilter.frequency.value = 1000;
      hornFilter.Q.value = 5; 
      hornGain = ctxB.createGain();
      hornGain.gain.value = 0; 
      
      blinkerOsc = ctxB.createOscillator();
      blinkerOsc.type = 'square';
      blinkerOsc.frequency.value = 300; 
      blinkerGain = ctxB.createGain();
      blinkerGain.gain.value = 0; 


      whiteNoise.connect(noiseGain).connect(ctxB.destination);
      airNoise.connect(airFilter).connect(airGain).connect(ctxB.destination);
      tuneOsc.connect(tuneGain).connect(ctxB.destination);
      hornOsc.connect(hornFilter).connect(hornGain).connect(ctxB.destination);
      blinkerOsc.connect(blinkerGain).connect(ctxB.destination);

      delay.connect(delayGain).connect(delay);
      vibrationOsc.connect(vibrationGain).connect(engineOsc.frequency);
      engineOsc.connect(filter).connect(engineGain).connect(delay).connect(ctxB.destination);
      engineGain.connect(ctxB.destination);
      cruiseToneOsc.connect(cruiseToneOscGain).connect(ctxB.destination);


      vibrationOsc.start();
      engineOsc.start();
      cruiseToneOsc.start();
      whiteNoise.start();
      airNoise.start(); 
      tuneOsc.start(); 
      hornOsc.start(); 
      blinkerOsc.start(); 
      
      console.log("Audio Initialized.");
      
      isEngineOn = false;
      isGameRunning = false; 
    }


    function updateEngineB() {
      const now = ctxB.currentTime;
      cruiseToneOsc.frequency.setTargetAtTime(cfrequency, now, 0.15);
      cruiseToneOscGain.gain.setTargetAtTime(cruiseGainLevel, now, 0.15);
      engineOsc.frequency.setTargetAtTime(frequency, now, 0.2);
      engineGain.gain.setTargetAtTime(gainLevel, now, 0.15);
      filter.frequency.setTargetAtTime(120 + (frequency - FREQ_MIN) * 0.8, now, 0.15);

    }
    
    function updateAudioPhysicsB() {
      if (!isEngineOn || !isGameRunning) return;
      
      const vx = bus.speed * 2.5;
      const now = ctxB.currentTime;
      const FRAME_TIME = 1 / 60;

      if (isAccelerating) {
        if (lastAccelTime === 0 || now - lastAccelTime > 0.5) {
          speedTimer = 0;
          
        }
        lastAccelTime = now;
        speedTimer += FRAME_TIME;
        if (speedTimer < 6) {
          frequency += 0.25;
          cfrequency += 1;
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 6.5) {
          frequency -= 4;
          cfrequency += 4;
          gainLevel -= 0.000000000000000000000000001;
        } else if (speedTimer < 11.5) {
          frequency += 0.2;
          cfrequency += 1;
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 12.51 && gainLevel >= 0.04) {
          gainLevel = 0.1
          cfrequency = 900
          delay.delayTime.value = 0.0000000000000000000001;
        }
      } else {
        if (now - lastAccelTime > 0.5) {
          speedTimer = 0;
          cruising = false;
        }
        frequency -= 1.5;
        gainLevel -= 0.001;
      }
      if (!isAccelerating) {
        speedTimer = 0
      }
      if (vx >= 20) {
      }
      if (bus.speed === 0) {
              if (bus.gear === 'NEUTRAL') {
        cfrequency = 340
        cfrequency -= 0.001
        gainLevel = 0.5
      } else {
        frequency = 110;
        gainLevel = 0.001;
        cfrequency = 900
      }
      }
      if (isBraking) {
        if (cfrequency <= 0) {
          cfrequency = 0
          cruiseGainLevel = 0.005
        }
        if (vx <15 && vx > 7) {
                      frequency += 4.25;
          cfrequency += 3;
        } else if (vx < 7) {
                      frequency -= 6.25;
          cfrequency -= 1;    
        }
        cruiseGainLevel += 0.00001
        speedTimer = 0
        cruising = false;
      }
      frequency = Math.max(FREQ_MIN, Math.min(frequency, FREQ_MAX));
      gainLevel = Math.max(GAIN_MIN, Math.min(gainLevel, GAIN_MAX));
      updateEngineB();

    }
let articulatedNodes = {};
let articulatedStarted = false;
let vibratoLFO = null;
let vibratoGain = null;
let vibratoActive = false;

function startArticulatedAudio() {
  if (articulatedStarted) return;
  articulatedStarted = true;

  const electricOsc = audioCtxC.createOscillator();
  const electricHarmOsc = audioCtxC.createOscillator();
  const electricGain = audioCtxC.createGain();
  const electricHarmGain = audioCtxC.createGain();

  electricOsc.type = "triangle";
  electricOsc.frequency.value = 30;
  electricHarmOsc.type = "triangle";
  electricHarmOsc.frequency.value = 120;

  electricGain.gain.value = 0;
  electricHarmGain.gain.value = 0;

  electricOsc.connect(electricGain).connect(audioCtxC.destination);
  electricHarmOsc.connect(electricHarmGain).connect(audioCtxC.destination);

  electricOsc.start();
  electricHarmOsc.start();

  const squeakLFO = audioCtxC.createOscillator();
  const squeakDepth = audioCtxC.createGain();

  squeakLFO.frequency.value = 1.2;
  squeakDepth.gain.value = 0;

  squeakLFO.connect(squeakDepth).connect(electricHarmGain.gain);
  squeakLFO.start();

  const bufferSize = 2 * audioCtxC.sampleRate;
  const noiseBuffer = audioCtxC.createBuffer(1, bufferSize, audioCtxC.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.12;
  }

  const dieselNoise = audioCtxC.createBufferSource();
  dieselNoise.buffer = noiseBuffer;
  dieselNoise.loop = true;

  const dieselGain = audioCtxC.createGain();
  dieselGain.gain.value = 0;

  const lowpass = audioCtxC.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 500;

  dieselNoise.connect(lowpass).connect(dieselGain).connect(audioCtxC.destination);

  dieselNoise.start();
vibratoLFO = audioCtxC.createOscillator();
vibratoGain = audioCtxC.createGain();
vibratoLFO.frequency.value = 3;
vibratoGain.gain.value = 1.1;

vibratoLFO.connect(vibratoGain).connect(electricHarmOsc.frequency);
vibratoLFO.start();
vibratoActive = true;

  articulatedNodes = {
    electricOsc,
    electricGain,
    electricHarmOsc,
    electricHarmGain,
    squeakLFO,
    squeakDepth,
    dieselNoise,
    dieselGain,
    lowpass,
    vibratoLFO,
    vibratoGain
  };
}

function updateArticulatedAudio() {
  const maxSpeed = 25;
  if (vx > maxSpeed) vx = maxSpeed;
  const norm = vx / 30;

  if (vx === 0) {
    articulatedNodes.electricGain.gain.setTargetAtTime(0.05, audioCtxC.currentTime, 0.2);
    articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.06, audioCtxC.currentTime, 0.2);
    articulatedNodes.squeakDepth.gain.setTargetAtTime(0.0, audioCtxC.currentTime, 0.3);
    articulatedNodes.dieselGain.gain.setTargetAtTime(0.6, audioCtxC.currentTime, 0.1);
    return;
  }
  if (vx >= 20) {
    articulatedNodes.electricGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.2);
    articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.2);
    articulatedNodes.squeakDepth.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.3);
    articulatedNodes.dieselGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.1);
  }

  articulatedNodes.electricOsc.frequency.setTargetAtTime(55 + norm * 28, audioCtxC.currentTime, 0.2);
  articulatedNodes.electricHarmOsc.frequency.setTargetAtTime(145 + norm * 40, audioCtxC.currentTime, 0.2);

  articulatedNodes.electricGain.gain.setTargetAtTime(0.1 + norm * 0.08, audioCtxC.currentTime, 0.3);
  articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.1 + norm * 0.07, audioCtxC.currentTime, 0.3);

  const squeakTarget = accelerating ? 0.12 : 0.06;
  articulatedNodes.squeakDepth.gain.setTargetAtTime(squeakTarget * norm, audioCtxC.currentTime, 0.4);

  articulatedNodes.dieselGain.gain.setTargetAtTime(0.3 + norm * 0.5, audioCtxC.currentTime, 0.4);
  const baseFreq = accelerating ? 550 : 350;
  articulatedNodes.lowpass.frequency.setTargetAtTime(baseFreq + norm * 600, audioCtxC.currentTime, 0.5);
}

    function turnEngineOff() {
        if (!ctxB) return;
        const now = ctxB.currentTime;
        
        isEngineOn = false;
        isGameRunning = false; 
        isAccelerating = false; 
        isLeftBlinkerOn = false;
        isRightBlinkerOn = false;
        blinkerSoundPlaying = false;
        blinkerGain.gain.setTargetAtTime(0, now, 0.01);

        engineGain.gain.setTargetAtTime(0, now, 0.5);
        noiseGain.gain.setTargetAtTime(0, now, 0.5);
        cruiseToneOscGain.gain.setTargetAtTime(0, now, 0.5);
        tuneGain.gain.setTargetAtTime(0, now, 0.1); 

        playAirReleaseSound();
        console.log("Engine Off: Audio Faded Out.");
    }
    
    function startEngineSequence() {
        if (!ctxB) return;
        
        isEngineOn = true;
        isGameRunning = false; 
        startSequenceTimer = 0.001; 
        
        console.log("Engine Start Sequence Initiated.");
    }

    function handleStartupSequence() {
        if (!isEngineOn || isGameRunning) return; 

        const now = ctxB.currentTime;
        const FRAME_TIME = 1/60;
        startSequenceTimer += FRAME_TIME;
        
        if (startSequenceTimer > 0 && startSequenceTimer <= 3) {
            tuneOsc.frequency.setTargetAtTime(2700, now, 0.1);
            tuneGain.gain.setTargetAtTime(0.05, now, 0.1); 
            
        } else if (startSequenceTimer > 3 && startSequenceTimer <= 3.5) {
            tuneGain.gain.setTargetAtTime(0, now, 0.1); 
        } else if (startSequenceTimer > 3.5 && startSequenceTimer <= 4) {
            engineOsc.frequency.setValueAtTime(FREQ_MIN - 20, now);
            engineOsc.frequency.linearRampToValueAtTime(FREQ_MAX/2, now + 0.5);
            engineOsc.frequency.linearRampToValueAtTime(FREQ_MIN, now + 1.0);
            
            engineGain.gain.setValueAtTime(0, now);
            engineGain.gain.linearRampToValueAtTime(GAIN_MAX * 0.7, now + 0.1);
            engineGain.gain.linearRampToValueAtTime(GAIN_MIN, now + 1.0);

            noiseGain.gain.setTargetAtTime(GAIN_MIN, now, 0.1);
            cruiseToneOscGain.gain.setTargetAtTime(cruiseGainLevel, now, 0.5);
            
        } else if (startSequenceTimer > 4 && startSequenceTimer <= 8 + FRAME_TIME) {
            isGameRunning = true; 
            startSequenceTimer = 8; 
            console.log("Engine Running: You can now drive.");
            
        } else if (startSequenceTimer > 15) {
            noiseGain.gain.setTargetAtTime(7.8, now, 0.01);
            noiseGain.gain.setTargetAtTime(GAIN_MIN, now + 2, 5);
            console.log("White Noise Burst (AC System Check)");

        }
    }


    function handlePassengerFlow() {
        if (!isGameRunning || bus.speed !== 0) return false; 

        let nearestStop = null;
        let minDistance = Infinity;

        busStops.forEach(stop => {
            const distance = stop.x - (bus.x + bus.width);
            
            if (distance >= -bus.width / 4 && distance <= STOP_DISTANCE_THRESHOLD) {
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestStop = stop;
                }
            }
        });

        if (nearestStop) {
            let paxChange = 0;
            
            if (stopRequested && passengersOnBus > 0) {
                const paxOff = Math.min(passengersOnBus, Math.ceil(Math.random() * 5)); 
                passengersOnBus -= paxOff;
                score += paxOff * 8;
                stopRequested = false;
                paxChange = -paxOff;
            }

            if (passengersOnBus < MAX_PASSENGERS) {
                const paxWaiting = Math.floor(Math.random() * 11); 
                const paxOn = Math.min(paxWaiting, MAX_PASSENGERS - passengersOnBus);
                
                passengersOnBus += paxOn;
                score += paxOn * 4;
                paxChange += paxOn;
                
                if (passengersOnBus > 5 && Math.random() < 0.20) {
                    stopRequested = true;
                }
            }
            
            if (paxChange !== 0) {
                playAirReleaseSound();
            }
            
            busStops.splice(busStops.indexOf(nearestStop), 1);
            
            console.log(`Pax On: ${paxChange > 0 ? paxChange : 0}, Pax Off: ${paxChange < 0 ? -paxChange : 0}. Total Pax: ${passengersOnBus}. Score: ${score}`);
            
            return true; 
        }
        return false; 
    }

    function randomStopRequestedCheck() {
        if (passengersOnBus > 0 && !stopRequested && Math.random() < 0.002) { 
            stopRequested = true;
            console.log("PASSENGER: Stop Requested!");
        }
    }

    function update() {
        const FRAME_TIME = 1 / 60;
        const isDriving = bus.gear === 'DRIVE';

        handleTimeAndWeather(FRAME_TIME);
        
        updateWeatherParticles(FRAME_TIME);

        if (isLeftBlinkerOn || isRightBlinkerOn) {
            blinkerTimer += FRAME_TIME;
            if (blinkerTimer >= BLINK_RATE * 2) {
                blinkerTimer = 0;
            }
        } else {
            blinkerTimer = 0;
        }

        playBlinkerSound();


        if (isGameRunning) {
            if (isDriving && isAccelerating) {
                bus.speed += bus.acceleration;
            } else if (isBraking) {
                bus.speed -= bus.deceleration; 
            } 
            
            if (isDriving && !isAccelerating) {
                bus.speed -= bus.friction;
            } else if (bus.gear === 'NEUTRAL' && bus.speed > 0) {
                bus.speed -= bus.neutralFriction; 
            }

            bus.speed = Math.max(0, bus.speed);
            bus.speed = Math.min(bus.speed, bus.maxSpeed);

            generateBusStop();
            updateBusStops();
        } else {
             if (bus.speed > 0) {
                 bus.speed -= 0.1;
                 bus.speed = Math.max(0, bus.speed);
             }
        }
        
        updateAudioPhysicsB();
        handleStartupSequence();
        
        randomStopRequestedCheck(); 
    }

    function gameLoop(timestamp) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (bus.speed >= 20) {
            bus.speed = 20
        }
        const deltaTime = (timestamp - lastTime) / 1000;
        frameCount++;
    fpsTimer += deltaTime;
    
    if (fpsTimer >= 0.25) { 
        fps = Math.round(frameCount / fpsTimer);
        frameCount = 0;
        fpsTimer = 0;
    }
        update();
        drawRoad();
        drawLaneLines();
        drawBusStops();
        drawBus();
        drawSceneDarkness();
        drawWeather();
        drawDashboard();
        requestAnimationFrame(gameLoop);
    }
    function one() {
                         handlePassengerFlow(); 
    }
    function go() {
                    if (bus.gear === 'DRIVE') {
                isAccelerating = !isAccelerating
            }
    }
    function stop() {
        isBraking = !isBraking
    }
function e() {
                if (ctxB) {
                if (isEngineOn) {
                    turnEngineOff();
                } else {
                    startEngineSequence();
                }
            }
}
    document.addEventListener('keydown', (e) => {
        if (e.key === 'e' || e.key === 'E') {
            if (ctxB) {
                if (isEngineOn) {
                    turnEngineOff();
                } else {
                    startEngineSequence();
                }
            }
            return; 
        }
        
        if (e.key === 'h' || e.key === 'H') {
            if (ctxB && isEngineOn) { 
                startHorn();
            }
        }
        
        if (e.key === '1') { 
             if (isGameRunning) {
                 handlePassengerFlow(); 
             }
        }
        
        if (e.key === 'z' || e.key === 'Z') {
             if (!isEngineOn) return;
             
             isLeftBlinkerOn = !isLeftBlinkerOn;
             
             if (isLeftBlinkerOn && !isRightBlinkerOn && (e.key !== 'x' && e.key !== 'X')) {
                 isRightBlinkerOn = false;
             }
        }
        if (e.key === 'c' || e.key === 'C') {
             if (!isEngineOn) return;
             
             isRightBlinkerOn = !isRightBlinkerOn;
             
             if (isRightBlinkerOn) {
                 isLeftBlinkerOn = false;
             }
        }
        if (e.key === 'x' || e.key === 'X') {
             if (!isEngineOn) return;
             
             if (isLeftBlinkerOn && isRightBlinkerOn) {
                 isLeftBlinkerOn = false;
                 isRightBlinkerOn = false;
             } else {
                 isLeftBlinkerOn = true;
                 isRightBlinkerOn = true;
             }
        }


        if (!isGameRunning) return;

        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            if (bus.gear === 'DRIVE') {
                isAccelerating = true;
            }
        }
        if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            if (!isBraking) {
            }
            isBraking = true;
        }
        if (e.key === 'n' || e.key === 'N') {
            const oldGear = bus.gear;
            bus.gear = (bus.gear === 'DRIVE') ? 'NEUTRAL' : 'DRIVE';
            isAccelerating = false; 
            
            if (oldGear !== bus.gear) {
                playAirReleaseSound();
            }
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            isAccelerating = false;
        }
        if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            isBraking = false;
        }
        if (e.key === 'h' || e.key === 'H') {
            stopHorn();
        }
    });


    const setupTouchControls = (btnId, stateVarName, isToggle = false) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            const startHandler = () => { 
                if (!isGameRunning) return; 

                if (isToggle) {
                    const oldGear = bus.gear; 
                    bus.gear = (bus.gear === 'DRIVE') ? 'NEUTRAL' : 'DRIVE';
                    isAccelerating = false;
                    
                    if (oldGear !== bus.gear) {
                        playAirReleaseSound();
                    }
                } else {
                    if (stateVarName === 'isBraking') {
                         if (!isBraking) {
                        }
                    }
                    if (window.hasOwnProperty(stateVarName)) {
                        window[stateVarName] = true; 
                    } else if (stateVarName.includes('.')) {
                    }
                    
                    if (stateVarName === 'isAccelerating' && bus.gear === 'NEUTRAL') {
                        window[stateVarName] = false;
                    }
                }
            };
            const endHandler = () => { 
                if (!isGameRunning) return;

                if (!isToggle) {
                    if (window.hasOwnProperty(stateVarName)) {
                        window[stateVarName] = false; 
                    }
                }
            };
            
            btn.addEventListener('touchstart', startHandler);
            btn.addEventListener('touchend', endHandler);
            btn.addEventListener('touchcancel', endHandler);
            btn.addEventListener('mousedown', startHandler);
            btn.addEventListener('mouseup', endHandler);
            btn.addEventListener('mouseleave', endHandler);
        }
    };

    setupTouchControls('accelerateBtn', 'isAccelerating');
    setupTouchControls('brakeBtn', 'isBraking');
    setupTouchControls('neutralBtn', 'bus.gear', true); 


    document.getElementById('startButton').addEventListener('click', () => {
        document.getElementById('audioOverlay').style.display = 'none';
        
        if (!ctxB) {
            initAudioB(); 
            requestAnimationFrame(gameLoop);
                }
        if (!isEngineOn) {
            startEngineSequence(); 
        }
    });


    window.onload = function () {
        resizeCanvas();
        
        const initializeBus = () => {
             processImageForTransparency();
        };

        if (busImage.complete && busImage.naturalWidth > 0) {
            initializeBus();
        } else {
            busImage.onload = initializeBus;
            busImage.onerror = () => {
                console.error("Failed to load bus image. Please ensure the file '2074.jpeg' is present.");
            };
        }
        
        initWeatherParticles();
    };

</script>
</body>
</html>
