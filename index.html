<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stopped Go 2.0</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(to bottom right, #dce1e9, #f2f4f7);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #app {
      transform: scale(0.67);
      transform-origin: center center;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    canvas {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      backdrop-filter: blur(20px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
      border: none;
    }

    #controls {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 20px;
    }

    #controls button,
    #info,
    #vxDisplay,
    #passengerCount,
    #speedDistance,
    #stopNotice,
    #pointsDisplay,
    #stopHistoryDisplay {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      border-radius: 16px;
      backdrop-filter: blur(18px);
      background: rgba(255, 255, 255, 0.2);
      color: #222;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      padding: 10px 14px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      user-select: none;
    }

    #speedDistance,
    #pointsDisplay,
    #stopNotice {
      background: rgba(255, 255, 255, 0.25);
      color: #000;
      font-weight: 600;
    }

    #info {
      font-size: 14px;
      color: #333;
      background: rgba(255,255,255,0.2);
    }

    button {
      cursor: pointer;
      transition: all 0.25s ease;
      border: none;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.35);
      transform: scale(1.05);
    }

    #controls button {
      font-size: 15px;
      font-weight: 600;
      padding: 10px 16px;
      color: #111;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(15px);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
      text-align: center;
      min-width: 180px;
    }

    #controls button:active {
      transform: scale(0.97);
      background: rgba(255, 255, 255, 0.3);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1) inset;
    }

    #stopHistoryDisplay {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 16px;
      font-family: 'Segoe UI', sans-serif;
      color: #111;
      font-size: 14px;
      line-height: 1.0;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      margin-top: 20px;
    }

    #minimap {
      backdrop-filter: blur(12px);
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.4);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

  #busRoutePanelWrapper {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10000;
    user-select: none;
    font-family: monospace;
    color: white;
  }

  #busRoutePanelToggle {
    background: #444;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
  }

  #busRoutePanel {
    margin-top: 8px;
    background: #222;
    padding: 12px 16px;
    border-radius: 8px;
    width: 220px;
    box-shadow: 0 0 10px #0008;
  }

  #busRoutePanel label {
    display: block;
    margin-top: 10px;
    margin-bottom: 4px;
    font-weight: bold;
  }

  #busRoutePanel input[type="text"] {
    font-size: 1.4em;
    width: 100%;
    padding: 6px;
    border-radius: 4px;
    border: none;
    background: #333;
    color: white;
    text-align: center;
    letter-spacing: 3px;
  }

  #busRoutePanel input[type="checkbox"] {
    transform: scale(1.3);
    margin-right: 8px;
    vertical-align: middle;
  }

  #busRoutePanel .color-slider {
    width: 100%;
  }

  #routePreviewWrapper {
    position: fixed;
    top: 60px; /* below toggle & panel */
    z-index: 10001;
    font-size: 2em;
    font-weight: bold;
    font-family: monospace;
    user-select: none;
    padding: 10px 16px;
    background: #d8d5d511;
    border-radius: 10px;
    min-width: 90px;
    text-align: center;
    color: rgba(255, 255, 255, 0.358);
  }

  #translationText {
    font-size: 1.1em;
    margin-top: 6px;
    text-align: center;
    font-style: italic;
    color: #0a7;
  }
    #gradientPopup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #gradientPopup.show {
      display: flex;
    }

    #gradientContent {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      padding: 30px 40px;
      color: white;
      text-align: center;
      backdrop-filter: blur(20px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    #gradientContent h3 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 20px;
      color: #fff;
    }

    #gradientContent button {
      margin-top: 10px;
      padding: 8px 14px;
      border-radius: 10px;
      border: none;
      background: rgba(255,255,255,0.25);
      cursor: pointer;
      font-weight: bold;
      color: white;
      transition: 0.25s;
    }

    #gradientContent button:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.05);
    }
#controls {
  position: fixed;       /* fix position on screen */
  top: 60px;             /* some space from top */
  left: -400px;            /* some space from left */
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 16px;
  width: 350px;          /* fixed width */
  padding: 10px 16px;
  background: rgba(255, 255, 255, 0.12);
  border-radius: 20px;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.1);
  z-index: 10000;        /* above other content */
  max-height: 150vh;  /* so it doesn’t overflow vertically */
  overflow-y: auto;      /* scroll if content is too tall */
}


#controls > div,
#controls > pre {
  width: 150px;
  padding: 10px 14px;
  background: rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: inset 0 1px 5px rgba(255,255,255,0.3);
  color: #222;
  font-weight: 600;
  font-size: 15px;
  user-select: none;
  line-height: 1.3;
}

#pointsDisplay,
#speedDistance {
  background: rgba(255, 255, 255, 0.25);
  color: #111;
  font-weight: 700;
  font-size: 17px;
  line-height: 1.4;
}

#info {
  background: rgba(255, 255, 255, 0.15);
  font-weight: 500;
  font-size: 14px;
  color: #333;
  user-select: text;
}

#vxDisplay {
  display: none; /* keep hidden unless needed */
}

button {
  width: 100px;
  padding: 12px 0;
  border-radius: 14px;
  font-weight: 600;
  font-size: 16px;
  background: rgba(255, 255, 255, 0.3);
  color: #222;
  border: none;
  cursor: pointer;
  box-shadow: 0 5px 12px rgba(0, 0, 0, 0.1);
  transition: background 0.3s ease, transform 0.2s ease;
}

button:hover {
  background: rgba(255, 255, 255, 0.45);
  transform: scale(1.04);
}

button:active {
  transform: scale(0.97);
  background: rgba(255, 255, 255, 0.35);
}

#stopHistoryDisplay {
  position: fixed;       /* fix position on screen */
  top: 60px;             /* some space from top */
  right: -400px;            /* some space from left */
  max-height: 220px;
  overflow-y: auto;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  background: rgba(255, 255, 255, 0.1);
  color: #222;
  padding: 14px;
  border-radius: 14px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
  white-space: pre-wrap;
  line-height: 1.25;
}
#quickKeyboard {
  position: fixed;
  bottom: -70px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 9999;
  padding: 14px 20px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(15px);
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

#quickKeyboard button {
  font-size: 15px;
  font-weight: 600;
  padding: 10px 16px;
  color: #111;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(15px);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
  text-align: center;
  min-width: 60px;
}
.row {
  margin-top: 8px;
}
#fuel-control {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
}

#fuel-bar-container {
  flex-grow: 1; /* Allows the bar to take up available space */
  height: 20px;
  background-color: #ccc;
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid #aaa;
}

#fuel-bar {
  height: 100%;
  width: 100%; /* Start at 100% width */
  background-color: #4CAF50; /* Green for full */
  transition: width 0.3s, background-color 0.3s;
}

#refuel-btn {
  padding: 5px 10px;
  cursor: pointer;
  background-color: #3f51b5;
  color: white;
  border: none;
  border-radius: 4px;
}
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <div id="fpsCounter">FPS: 0</div>
      <div id="pointsDisplay">Points: 0</div>
      <div id="speedDistance">Distance: 0 px<br>Speed: 0 px/s</div>
      <div id="vxDisplay" style="display: none">vx: 0</div>
    <div id="fuel-control">
      <label for="fuel-level">Fuel Level:</label>
      <div id="fuel-bar-container">
        <div id="fuel-bar"></div>
      </div>
      <span id="fuel-percent">100%</span>
      <button id="refuel-btn">Refuel (R)</button>
  </button></div>
      <button id="openGradientMenu">Customize Menu</button>
      <button onclick="showStopHistory()">View Stop History</button>

      <div style="display: none"id="info">Press 1, 2, or 3 to switch buses. Current: Gillig 29'</div>
      <canvas id="minimap" width="300" height="100"></canvas>
    </div>

    <div id="gradientPopup">
      <div id="gradientContent">
        <h3>Gradient Settings</h3>
        <label>
          Start Color:
          <input type="color" id="startColorPicker" value="#d3d3d3" />
        </label>
        <br /><br />
        <label>
          End Color:
          <input type="color" id="endColorPicker" value="#d3d3d3" />
        </label>
        <br /><br />
        <button onclick="exportGradient()">Export Gradient</button>
        <input type="file" id="importGradientFile" style="display:none" accept=".sg,.json" />
        <button onclick="document.getElementById('importGradientFile').click()">Import Gradient</button>
        <br /><br />
        <button id="closeGradientMenu">Close</button>
      </div>
    </div>

    <canvas id="busCanvas" width="800" height="600"></canvas>
          <pre id="stopHistoryDisplay"></pre>
          <div id="lateness-info" style="
  position: fixed;
  top: -90px; right: 10px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px 12px;
  font-family: monospace;
  font-size: 14px;
  border-radius: 8px;
  z-index: 1000;
  white-space: pre-line;
  pointer-events: none;
  user-select: none;
"></div>

<div id="quickKeyboard">
  <button data-key="1">1</button>
  <button data-key="2">2</button>
  <button data-key="3">3</button>
  <button data-key="ArrowRight">→</button>
  <button data-key="b">Brake</button>
  <button data-key="l">Kneel</button>

  <br>

  <button data-key="s">Light</button>
  <button data-key="n">Night</button>
  <button data-key="[">Door</button>
</div>

<pre id="lateness-info" style="white-space: pre-wrap; font-family: monospace;"></pre>

<div id="busRoutePanelWrapper">
  <button id="busRoutePanelToggle" aria-expanded="false" aria-controls="busRoutePanel" title="Toggle Bus Route Editor Panel">► Route Editor</button>
  <div id="busRoutePanel" hidden>
    <label for="routeNumber">Bus Route Number (0-999):</label>
    <input type="text" id="routeNumber" maxlength="3" pattern="\d*" inputmode="numeric" placeholder="Enter number" />

    <label>
      <input type="checkbox" id="translationCheck" />
      Translation (101-126 → A-Z)
    </label>

    <label for="rSlider">Red</label>
    <input type="range" id="rSlider" min="0" max="255" value="255" class="color-slider" />
    <label for="gSlider">Green</label>
    <input type="range" id="gSlider" min="0" max="255" value="255" class="color-slider" />
    <label for="bSlider">Blue</label>
    <input type="range" id="bSlider" min="0" max="255" value="255" class="color-slider" />

    <div id="translationText"></div>
  </div>
</div>

<div id="routePreviewWrapper">
  <div id="routePreview">---</div>
</div>

<div style="position: fixed; right: 0; top: 20px; background: #222; color: white; padding: 10px; font-family: monospace; width: 240px; z-index: 1000;">
  <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 8px;">
    <button id="leftArrow" style="font-size: 1.5em;">(-</button>
    <div id="bitDisplay" style="display: flex; gap: 5px; margin: 0 10px;">
      <!-- bits go here -->
    </div>
    <button id="rightArrow" style="font-size: 1.5em;">-)</button>
  </div>
  <button id="executeBtn" style="width: 100%; font-size: 1.2em;">Execute</button>
  <div id="status" style="margin-top: 10px; font-size: 0.9em;"></div>
</div>

  </div>

  <script>

  const keys = {};
  let fps = 0;
  let articulated = false
let lastFrameTime = performance.now();
let frames = 0;
let lastFpsUpdate = performance.now();
let debugMode = false;

  let accelerating = false;
  let braking = false;
  let friction = 0.9999;
 window.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (keys[key]) return;
    keys[key] = true;

    handleKeyPress(key);
  });

  window.addEventListener('keyup', e => {
    const key = e.key.toLowerCase();
    keys[key] = false;
  });
let spotlightOn = false
let night = false;  // toggle this to switch modes
  function handleKeyPress(key) {
    if (key === 'arrowright') {
      accelerating = !accelerating;
      braking = false;
      friction = 0.999;
      console.log('Accelerating:', accelerating);
    }

    if (key === 'b') {
      braking = true;
      console.log('Braking:', braking);
    }
    if (key === 't') {
      debugMode = !debugMode
    }
      if (key === 'n') {
      night = !night
    }
        if (key === 's') {
      if (night) {
        spotlightOn = !spotlightOn
      }
    }
  }
function simulateKeyPress(key) {
  // Create and dispatch a real keyboard event for the key
  const event = new KeyboardEvent('keydown', { key: key, bubbles: true });
  window.dispatchEvent(event);

  // Also dispatch keyup shortly after to mimic real press-release
  setTimeout(() => {
    const eventUp = new KeyboardEvent('keyup', { key: key, bubbles: true });
    window.dispatchEvent(eventUp);
  }, 100);
}

// Existing keys state and logic...
function bracket() {
    frontOpen = !frontOpen
}
document.querySelectorAll('#quickKeyboard button').forEach(button => {
  button.addEventListener('click', () => {
    const key = button.getAttribute('data-key').toLowerCase();

    // For numbers and 'l', simulate real keypress event
    if (key === '1' || key === '2' || key === '3' || key === 'l') {
      simulateKeyPress(key);
    } else if (key === '[') {
      bracket()
    } else {
      // For other keys, use previous logic:
      if (keys[key]) return;
      keys[key] = true;

      handleKeyPress(key);

      setTimeout(() => {
        keys[key] = false;
      }, 100);
    }
  });
});
const fpsDiv = document.getElementById('fpsCounter');

function gameLoop(timestamp) {
  const delta = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  frames++;

  if (timestamp - lastFpsUpdate >= 500) {
    fps = Math.round((frames * 1000) / (timestamp - lastFpsUpdate));
    frames = 0;
    lastFpsUpdate = timestamp;
    if (fpsDiv) fpsDiv.textContent = `FPS: ${fps}`;
  }
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

  // === Simulate virtual keypress from quick keyboard buttons ===
  document.querySelectorAll('#quickKeyboard button').forEach(button => {
    button.addEventListener('click', () => {
      const key = button.getAttribute('data-key').toLowerCase();
      if (keys[key]) return;
      keys[key] = true;

      handleKeyPress(key);

      setTimeout(() => {
        keys[key] = false;
      }, 100);
    });
  });

    // Basic toggle popup logic (feel free to extend)
    const popup = document.getElementById('gradientPopup');
    document.getElementById('openGradientMenu').onclick = () => popup.classList.add('show');
    document.getElementById('closeGradientMenu').onclick = () => popup.classList.remove('show');
  const gradientPopup = document.getElementById("gradientPopup");
  const openBtn = document.getElementById("openGradientMenu");
  const closeBtn = document.getElementById("closeGradientMenu");

  openBtn.onclick = () => gradientPopup.classList.add("show");
  closeBtn.onclick = () => gradientPopup.classList.remove("show");

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 't') {
    debugMode = !debugMode;
    console.log(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
  }
});

  // Optional: Close on background click
  gradientPopup.onclick = (e) => {
    if (e.target === gradientPopup) {
      gradientPopup.classList.remove("show");
    }
  };
let acceleration = 0.1;      // Acceleration rate
const almostOne = 1 - 1e-222     // Max speed
let camFollowX = 0;          // Camera follow target x
let delayTimer = 0;          // For 2s delay
let distance2 = 0;
const lightCount = 5;

// Only regenerate when the center light needs to shift
let lastCenterIndex = null;

  const canvas = document.getElementById('busCanvas');
  const info = document.getElementById('info');
  const ctx = canvas.getContext('2d');
const lightColors = {
  0: "#00ff00", // green
  1: "#ffff00", // yellow
  2: "#ff0000", // red
};

let sharedTimer = 0;
let sharedState = 2; // Start on red


let violationMessageTimer = 0;

// NEW: Road generation logic
const ROAD_BASE_Y = 500;
const roadBridges = [];
const bridgeLength = 2000;
const bridgeHeight = 150;

// Generate some bridges procedurally
let lastBridgeX = 5000;
for (let i = 0; i < 20; i++) {
    const start = lastBridgeX + 5000 + Math.random() * 5000;
    roadBridges.push({
        start: start,
        end: start + bridgeLength,
        y: ROAD_BASE_Y - bridgeHeight
    });
    lastBridgeX = start + bridgeLength;
}

function getBumpY(x) {
    // Combine sine waves for natural-looking bumps
    return ROAD_BASE_Y + Math.sin(x / 300) * 15 + Math.sin(x / 800) * 20;
}

function getRoadY(x) {
    for (const bridge of roadBridges) {
        const transition = 200; // How long the ramp is
        // Smooth transition onto the bridge
        if (x > bridge.start - transition && x < bridge.start) {
            const progress = (x - (bridge.start - transition)) / transition;
            const startY = getBumpY(bridge.start - transition);
            // Simple linear interpolation for the ramp
            return startY + (bridge.y - startY) * progress;
        }
        // Flat on the bridge
        if (x >= bridge.start && x <= bridge.end) {
            return bridge.y;
        }
        // Smooth transition off the bridge
        if (x > bridge.end && x < bridge.end + transition) {
            const progress = (x - bridge.end) / transition;
            const endY = getBumpY(bridge.end + transition);
            return bridge.y + (endY - bridge.y) * progress;
        }
    }
    // Default to bumpy road if not on a bridge
    return getBumpY(x);
}

function update(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const delta = (timestamp - lastTimestamp) / 1000; // seconds elapsed since last frame

  // Distance traveled increment (assuming vx is px per second)
  distance2 += Math.abs(vx * delta);


  // Update the display text, multiply by 2
  const speedDisplay = document.getElementById('speedDistance');
  speedDisplay.innerHTML = `Distance: ${(distance2 * 2).toFixed(0)} px<br>Speed: ${(vx * 2).toFixed(0)} px/s`;

  lastTimestamp = timestamp;
  requestAnimationFrame(update);
  
}

requestAnimationFrame(update);


window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();

  if (keys[key]) return; // Ignore repeat until released
  keys[key] = true;

  if (key === 'arrowright') {
    accelerating = !accelerating; // Toggle acceleration
    console.log('Accelerating:', accelerating);
    braking = false
    friction = 0.9993
  }

  if (key === 'b') {
    braking = true
    console.log('Braking:', braking);
  }
});

window.addEventListener('keyup', e => {
  const key = e.key.toLowerCase();
  keys[key] = false; // Allow toggling again on next key press
});

let audioCtxA = new (window.AudioContext || window.webkitAudioContext)();
let idleGain, jitterGain, driveGain, driveNoiseSource;
let currentState = "idle";

let currentSystem = "D";
let audioAStarted = false, audioBStarted = false;
let vx = 0;
const maxSpeed = 120;
let violationOccurred = false;
// === Ensure AudioContext ===
// === Engine Tone Buffer ===
function createEngineToneBuffer(freq = 60, duration = 2, volume = 0.2) {
  const buffer = audioCtxA.createBuffer(1, duration * audioCtxA.sampleRate, audioCtxA.sampleRate);
  const data = buffer.getChannelData(0);
  const sampleRate = audioCtxA.sampleRate;
  for (let i = 0; i < data.length; i++) {
    data[i] = Math.sin(5)
  }
  return buffer;
}

// === Source with Gain ===
function createLoopingSource(buffer, gainValue = 0.5) {
  const source = audioCtxA.createBufferSource();
  source.buffer = buffer;
  source.loop = true;

  const gain = audioCtxA.createGain();
  gain.gain.value = gainValue;

  source.connect(gain).connect(audioCtxA.destination);
  return { source, gain };
}
const MAX_FUEL = 100; // Total fuel capacity
  let currentFuel = 100;
  let fuelDepleted = false; // Flag to stop engine/movement

  // DOM element references
  const fuelBar = document.getElementById('fuel-bar');
  const fuelPercentSpan = document.getElementById('fuel-percent');
  const refuelBtn = document.getElementById('refuel-btn');

  // ===================================================================
  // NEW: Fuel System Functions
  // ===================================================================

  function updateFuel(deltaT, vx) {
    if (fuelDepleted) return;
    if (currentFuel === NaN) {
      currentFuel = 100
    }
    // Calculate consumption rate (more consumption when moving and accelerating)
    // Base consumption: 0.05 units per second (at idle)
    // Driving consumption: add 0.2 units per second * velocity magnitude
    let consumptionRate = 0.003 + (vx * 0.01034)
    let consumption = consumptionRate * 0.100105

    currentFuel -= consumption;

    // Check if fuel is depleted
    if (currentFuel <= 0) {
      currentFuel = 0;
      fuelDepleted = true;
      console.log("Fuel Depleted! Bus has stopped.");
    }

    // Update the visual gauge and color
    const percent = currentFuel;
    fuelPercentSpan.textContent = `${percent.toFixed(0)}%`;
    fuelBar.style.width = `${percent}%`;

    // Change color: Green (>50%), Yellow (20-50%), Red (<20%)
    if (percent > 50) {
      fuelBar.style.backgroundColor = '#4CAF50';
    } else if (percent > 20) {
      fuelBar.style.backgroundColor = '#FFC107';
    } else {
      fuelBar.style.backgroundColor = '#F44336';
    }
  }

  function refuel() {
    // Only refuel if the bus is stopped (optional, but good practice)
    if (vx !== 0) {
        console.log("Cannot refuel while moving!");
        return;
    }
    
    currentFuel = MAX_FUEL;
    fuelDepleted = false;
    updateFuel(0, 0); // Force a visual update
    console.log("Bus Refueled!");
  }

  // ===================================================================
  // NEW: Refueling Event Listeners
  // ===================================================================

  refuelBtn.addEventListener('click', refuel);

  document.addEventListener('keydown', (event) => {
    // Assuming 'R' is the refuel key
    if (event.code === 'KeyR') {
      refuel();
    }
    // Placeholder for other keys (e.g., 'W' for acceleration)
    if (event.code === 'KeyW' && !fuelDepleted) {
        isMoving = true;
    }
  });
  
  document.addEventListener('keyup', (event) => {
    if (event.code === 'KeyW') {
        isMoving = false;
    }
  });
const keysDown = new Set();
// === Start Audio A ===
let trainApproaching = false
const MAX_INT_32 = 2147483647;
let trainTrafficLights = [];
let trainFlashTimer = 0;
let trainFlashOn = true;
// === Update Audio Based on Speed ===
let jitterOscillator = null;
let jitterLFOGain = null;
let jitterOscActive = false;
// Global Variables for the new Retarder Spit feature
let retarderNoise, retarderSource, retarderGain;
let lastVX = 0; // Track previous speed for deceleration detection
// Set the target system to A for the new implementation
function step() {
  // Use the repurposed System A functions for the 16101 sound
  if (currentSystem === "A") {
    updateAudioSystemA(vx);
  } else if (currentSystem === "C") {
    if (!articulated) {
    updateAudioSystemC(vx)
    } else {
      updateArticulatedAudio(vx)
    }
  }
  // Store the current speed for the next step's deceleration check
  lastVX = vx;
}
step()
// === Audio Context ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// === Global Variables ===
// Renaming for clarity to match the sound components of the 16101 bus
let engineRumble, turboWhine; // Replaces idleNoise, jitterNoise
let engineSource, turboSource; 

let idleOsc, turboOsc, driveOsc; // idleOsc = deep engine hum
let idleOscGain, turboOscGain, driveOscGain;


// === Create White Noise Buffer ===
function createNoiseBuffer(duration = 2, volume = 0.5) {
  const sampleRate = audioCtx.sampleRate;
  const bufferSize = sampleRate * duration;
  const buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * volume; // White noise between -volume and +volume
  }
  return buffer;
}

// === Create Noise Source (BufferSource + Gain) ===
function createNoiseSource(buffer, gainValue = 0.5) {
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;

  const gain = audioCtx.createGain();
  gain.gain.value = gainValue;

  source.connect(gain).connect(audioCtx.destination);
  return { source, gain };
}

// === Create Raw Oscillator + Gain Node ===
function createOscillator(type = 'sine', freq = 60, gainVal = 0.2) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.value = gainVal;

  osc.connect(gain).connect(audioCtx.destination);
  osc.start();

  return { osc, gain };
}

// === Start Audio System A (Refactored for 16101) ===
function startAudioA() {
  // 1. ENGINE RUMBLE (DEEP LOW FREQUENCY NOISE)
  idleNoise = createNoiseBuffer(0.3, 0.4); // Deeper, more rumble
  
  // 2. TURBO WHINE (WHITE NOISE MIX)
  jitterNoise = createNoiseBuffer(0.4, 0.7); // High volume white noise for turbo sound
  
  // 3. DRIVE NOISE (Main Diesel Combustion)
  driveNoise = createNoiseBuffer(2, 0.6); // Louder combustion noise
  
  // 4. RETARDER SPIT (A short, loud burst of air)
  retarderNoise = createNoiseBuffer(0.05, 1.0); 

  // Create looping noise sources
  const idle = createNoiseSource(idleNoise, 0.3); // Initial idle rumble is prominent
  const jitter = createNoiseSource(jitterNoise, 0.0); // Now the main white noise whine source
  
  // Raw oscillators for tonal layers
  // DEEP ENGINE IDLE HUM (Cummins L9 is a deep straight-six)
  const idleTone = createOscillator('sine', 35, 0.15);     // Lower frequency for deeper sound
  // HIGH-PITCHED WHINE TONE (Mix with white noise for the 'mixed' whine sound)
  const jitterTone = createOscillator('sawtooth', 400, 0.0); // High frequency sawtooth
  // ENGINE BUZZ/DRIVE TONE
  const driveTone = createOscillator('square', 150, 0.0);   // slightly lower frequency

  idleOsc = idleTone.osc;
  idleOscGain = idleTone.gain;
  // Repurposing jitterOsc/Gain for the tonal part of the whine
  jitterOsc = jitterTone.osc;
  jitterOscGain = jitterTone.gain;

  driveOsc = driveTone.osc;
  driveOscGain = driveTone.gain;

  // Drive noise source with effects (Main Combustion Sound)
  driveNoiseSource = audioCtx.createBufferSource();
  driveNoiseSource.buffer = driveNoise;
  driveNoiseSource.loop = true;

  driveGain = audioCtx.createGain();
  driveGain.gain.value = 0.0;

  const filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 250; 
  filter.Q.value = 4; 

  driveNoiseSource.connect(filter);
  filter.connect(driveGain);
  driveGain.connect(audioCtx.destination);

  // Retarder Spit Source (Initial setup)
  retarderSource = audioCtx.createBufferSource();
  retarderSource.buffer = retarderNoise;
  retarderSource.loop = false;
  
  retarderGain = audioCtx.createGain();
  retarderGain.gain.value = 0.0; // Start muted
  retarderGain.connect(audioCtx.destination);

  // Start all looping sources
  idle.source.start();
  jitter.source.start();
  driveNoiseSource.start();

  idleGain = idle.gain;
  // Repurposing jitterGain for the white noise part of the whine
  jitterGain = jitter.gain;

  currentState = "idle";

  // Initial gain values for idle
  idleGain.gain.value = 0.35;
  idleOscGain.gain.value = 0.15;
}

// === Trigger Retarder Spit ===
function triggerRetarderSpit() {
    // 1. Create a new source for the single-shot sound
    const spitSource = audioCtx.createBufferSource();
    spitSource.buffer = retarderNoise; // Use the short, loud buffer
    spitSource.loop = false;

    // 2. Create a gain node for a quick fade-in/out
    const spitGain = audioCtx.createGain();
    spitGain.gain.value = 0.0;
    spitGain.connect(audioCtx.destination);

    // 3. Connect and schedule the gain
    spitSource.connect(spitGain);
    
    const now = audioCtx.currentTime;
    spitGain.gain.setValueAtTime(0.0, now);
    spitGain.gain.linearRampToValueAtTime(0.8, now + 0.01); // Quick attack to max volume
    spitGain.gain.linearRampToValueAtTime(0.0, now + 0.2);  // Quick decay
    
    // 4. Start and stop the source
    spitSource.start(now);
    spitSource.stop(now + 0.2); // Stop after the fade-out
}

// === Update Audio System A (Refactored for 16101) ===
function updateAudioSystemA() {
  const VX = vx;
  const maxSpeed = 12; // Retaining max speed from original code
  const speedNorm = Math.min(Math.abs(VX) / maxSpeed, 1);
  const now = audioCtx.currentTime;
  const fastRamp = 0.05;
  const slowRamp = 0.3;
  const accelRamp = 0.01; // Very fast attack for the initial grumble
  const levelOffRamp = 0.8; // Slower decay for leveling off
  
  // 0. CHECK FOR RETARDER SPIT
  const deceleration = lastVX - VX;
  // Trigger if moving AND decelerating strongly
  if (lastVX > 3.0 && deceleration > 0.5) {
      triggerRetarderSpit();
  }


  // Idle state (Standing Still)
  if (VX < 0.5 && currentState !== "idle") {
    currentState = "idle";
    
    // ENGINE RUMBLE (Prominent idle)
    idleGain.gain.setTargetAtTime(0.35, now, slowRamp);
    idleOsc.frequency.setTargetAtTime(35, now, slowRamp);
    idleOscGain.gain.setTargetAtTime(0.15, now, slowRamp);

    // DRIVE/COMBUSTION (Quiet at idle)
    driveGain.gain.setTargetAtTime(0.005, now, slowRamp);
    driveOscGain.gain.setTargetAtTime(0.0, now, slowRamp);

    // TURBO WHINE (Off at idle)
    jitterGain.gain.setTargetAtTime(0.0, now, slowRamp);
    jitterOscGain.gain.setTargetAtTime(0.0, now, slowRamp);
  }

  // Low Speed / Acceleration (The 1-second deep grumble and initial spool)
  else if (VX >= 0.5 && VX < 5) {
    if (currentState !== "low_drive") {
      currentState = "low_drive";

      // 1-SECOND DEEP GRUMBLE ATTACK
      idleGain.gain.setTargetAtTime(0.4, now, accelRamp);
      idleOscGain.gain.setTargetAtTime(0.25, now, accelRamp);
      // Decay from the grumble
      idleGain.gain.linearRampToValueAtTime(0.15, now + 1.0);
      idleOscGain.gain.linearRampToValueAtTime(0.05, now + 1.0);

      // DRIVE/COMBUSTION (Starting to pick up)
      driveGain.gain.setTargetAtTime(0.1, now, slowRamp);
      driveOscGain.gain.setTargetAtTime(0.1, now, slowRamp);

      // TURBO WHINE (Starts to spool - White Noise + Sawtooth)
      jitterGain.gain.setTargetAtTime(0.2, now, slowRamp);
      jitterOscGain.gain.setTargetAtTime(0.15, now, slowRamp);
      
      jitterOsc.frequency.setTargetAtTime(400, now, slowRamp); 
    }
    
    // Low-speed turbo and engine feedback modulation
    const speedRatio = (VX - 0.5) / 4.5; 
    
    // Turbo whine intensity (increases with speed)
    jitterGain.gain.setTargetAtTime(0.2 + 0.25 * speedRatio, now, fastRamp);
    jitterOscGain.gain.setTargetAtTime(0.15 + 0.1 * speedRatio, now, fastRamp);
  }

  // Drive state (Higher Speed / Cruising / Leveling)
  else if (VX >= 5) {
    if (currentState !== "drive") {
      currentState = "drive";

      // ENGINE RUMBLE (Fades to background low hum)
      idleGain.gain.setTargetAtTime(0.05, now, levelOffRamp);
      idleOscGain.gain.setTargetAtTime(0.0, now, levelOffRamp);

      // TURBO WHINE (Constant high whine)
      jitterGain.gain.setTargetAtTime(0.45, now, slowRamp);
      jitterOscGain.gain.setTargetAtTime(0.25, now, slowRamp);
    }

    // Dynamic updates based on speedNorm (0 to 1 over the full speed range)
    
    // DRIVE/COMBUSTION NOISE
    const driveGainVal = 0.25 + 0.45 * speedNorm;
    // Use the LEVEL OFF RAMP to simulate engine sustaining speed
    driveGain.gain.setTargetAtTime(driveGainVal, now, levelOffRamp);

    // DRIVE OSC (Higher pitch/buzz as engine strains)
    const driveOscGainVal = 0.2 + 0.5 * speedNorm;
    driveOscGain.gain.setTargetAtTime(driveOscGainVal, now, levelOffRamp);
    
    // ENGINE RPM/PITCH (Changes the frequency of the main drive tone)
    driveOsc.frequency.setTargetAtTime(150 + 70 * speedNorm, now, levelOffRamp);

    // NOISE RATE (Faster 'chatter' as speed increases)
    const rate = 1.0 + 1.0 * speedNorm;
    driveNoiseSource.playbackRate.setTargetAtTime(rate, now, levelOffRamp);
    
    // TURBO WHINE PITCH (Picks up significantly with speed)
    jitterOsc.frequency.setTargetAtTime(400 + 200 * speedNorm, now, levelOffRamp); 
  }

  // Cap max speed (retained from original logic)
  if (VX >= 12) {
    vx = 12;
    // Set fixed max volume at top speed
    driveGain.gain.setTargetAtTime(0.7, now, fastRamp);
    driveOscGain.gain.setTargetAtTime(0.7, now, fastRamp);
  }
}

// --- Door State and Animation Constants ---
let frontOpen = 0; // Current open distance (0 to 100)
const DOOR_SPEED = 4;
const DOOR_MAX_OPEN = 50; // Max opening distance in pixels

// --- Event Listeners to toggle the key state ---
window.addEventListener('keydown', e => {
  // Check for the '[' key
  if (e.key === '[') {
if (vx === 0) {
    frontOpen = !frontOpen
  } else return}
  // Include other key listeners here...
});

let flashAlpha = 0;
let flashTimer = 0;
    // ---------------- SYSTEM B ---------------- //
    let cruiseGainLevel = 0.005;
    const ctxB = new (window.AudioContext || window.webkitAudioContext)();
    let engineOsc, engineGain, filter, delay, delayGain;
    let noiseGain, whiteNoise, vibrationOsc, vibrationGain;
    let cruiseToneOsc, cruiseToneOscGain;
    let idleLFO = null, idleLFOGain = null;
    let frequency = 160, gainLevel = 0.1;
    let vxTimer = 0, lastAccelTime = 0;
    let cruising = false;
    const FREQ_MIN = 160, FREQ_MAX = 800;
    const GAIN_MIN = 0.1, GAIN_MAX = 0.5;
    const vxDisplay = document.getElementById('vxDisplay');
    const accelBtn = document.getElementById('accelBtn');

function createWhiteNoiseB() {
  const buffer = ctxB.createBuffer(1, ctxB.sampleRate * 2, ctxB.sampleRate);
  const data = buffer.getChannelData(0);

  // Generate slightly smoother noise (low-frequency emphasis)
  let lastValue = 0;
  for (let i = 0; i < data.length; i++) {
    // Apply slight smoothing between samples for wind-like texture
    const rand = Math.random() * 2 - 1;
    data[i] = (lastValue + rand * 0.05) / 1.25; // smooth blend
    lastValue = data[i];
  }

  const source = ctxB.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  return source;
}


function initAudioB() {
  engineOsc = ctxB.createOscillator();
  engineOsc.type = 'triangle';
  engineOsc.frequency.value = 0.1;

  engineGain = ctxB.createGain();
  engineGain.gain.value = 0.8;

  filter = ctxB.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 10;
  filter.Q.value = 1.5;

  delay = ctxB.createDelay();
  delay.delayTime.value = 0.00005;

  delayGain = ctxB.createGain();
  delayGain.gain.value = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001;

  whiteNoise = createWhiteNoiseB();
  noiseGain = ctxB.createGain();
  noiseGain.gain.value = 0.2;

  vibrationOsc = ctxB.createOscillator();
  vibrationOsc.frequency.value = 1;
  vibrationGain = ctxB.createGain();
  vibrationGain.gain.value = 0.8;

  cruiseToneOsc = ctxB.createOscillator();
  cruiseToneOsc.type = 'sine';
  cruiseToneOsc.frequency.value = 900;

  cruiseToneOscGain = ctxB.createGain();
  cruiseToneOscGain.gain.value = 0.005; // <-- Always audible alongside engine

  // Routing
  whiteNoise.connect(noiseGain).connect(ctxB.destination);
  delay.connect(delayGain).connect(delay);
  vibrationOsc.connect(vibrationGain).connect(engineOsc.frequency);
  engineOsc.connect(filter).connect(engineGain).connect(delay).connect(ctxB.destination);
  engineGain.connect(ctxB.destination);
cruiseToneOsc.connect(cruiseToneOscGain).connect(ctxB.destination);


  vibrationOsc.start();
  engineOsc.start();
  cruiseToneOsc.start();
  whiteNoise.start();
}


    function updateEngineB() {
      cruiseToneOsc.frequency.setTargetAtTime(cfrequency, ctxB.currentTime, 0.15);
      cruiseToneOscGain.gain.setTargetAtTime(cruiseGainLevel, ctxB.currentTime, 0.15);
      engineOsc.frequency.setTargetAtTime(frequency, ctxB.currentTime, 0.2);
      engineGain.gain.setTargetAtTime(gainLevel, ctxB.currentTime, 0.15);
      filter.frequency.setTargetAtTime(120 + (frequency - FREQ_MIN) * 0.8, ctxB.currentTime, 0.15);

    }
    let cfrequency = 900; // Cruise tone base frequency
let speedTimer = 0
    function simulationStepB() {
      const now = performance.now();
      if (accelerating) {
        if (lastAccelTime === 0 || now - lastAccelTime > 500) {
          speedTimer = 0;
          
        }
        lastAccelTime = now;
        speedTimer += 1 / 60;

        if (speedTimer < 13) {
          frequency += 0.25;
          cfrequency += 1;
          acceleration = 0.1
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 13.5) {
          frequency -= 4;
          cfrequency += 4;
          gainLevel -= 0.000000000000000000000000001;
        } else if (speedTimer < 17.5) {
          frequency += 0.2;
          cfrequency += 1;
          gainLevel += 0.0000000000000000000000001;
        } else if (speedTimer < 18.51 && gainLevel >= 0.04) {
          gainLevel = 0.00001
          cfrequency = 900
          delay.delayTime.value = 0.0000000000000000000001;
        }
      } else {
        if (now - lastAccelTime > 500) {
          speedTimer = 0;
          cruising = false;
          vibrationOffTime = null;
        }
        frequency -= 1.5;
        gainLevel -= 0.001;
      }
      if (!accelerating) {
        speedTimer = 0
      }
      if (vx >= 20) {
        vx = 20
      }
      if (vx === 0) {
        cfrequency = 900
      }
      if (braking) {
        frequency -= 3;
        gainLevel -= 0.1;
        cfrequency -= 10;
        if (cfrequency <= 0) {
          cfrequency = 0
          cruiseGainLevel = 0.005
        }
        cruiseGainLevel += 0.00001
        speedTimer = 0
        cruising = false;
        vibrationOffTime = null;
      }

      frequency = Math.max(FREQ_MIN, Math.min(frequency, FREQ_MAX));
      gainLevel = Math.max(GAIN_MIN, Math.min(gainLevel, GAIN_MAX));
      updateEngineB();

      requestAnimationFrame(simulationStepB);
    }

let electricOsc, electricGain, dieselNoise, dieselGain, lowpass;
const audioCtxC = new (window.AudioContext || window.webkitAudioContext)();
let audioCStarted = false;

// Track when electric started playing to stop after 5 seconds
let electricStartTime = null;

function startAudioC() {
  if (audioCStarted) return;
  audioCStarted = true;

  electricOsc = audioCtxC.createOscillator();
  electricGain = audioCtxC.createGain();
  electricOsc.type = "square";
  electricOsc.frequency.value = 100;
  electricGain.gain.value = 0.0; // start silent
  electricOsc.connect(electricGain).connect(audioCtxC.destination);

  const bufferSize = 2 * audioCtxC.sampleRate;
  const buffer = audioCtxC.createBuffer(1, bufferSize, audioCtxC.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

  dieselNoise = audioCtxC.createBufferSource();
  dieselNoise.buffer = buffer;
  dieselNoise.loop = true;

  dieselGain = audioCtxC.createGain();
  dieselGain.gain.value = 0.0;

  lowpass = audioCtxC.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 10;

  dieselNoise.connect(lowpass).connect(dieselGain).connect(audioCtxC.destination);

  electricOsc.start();
  dieselNoise.start();

  electricStartTime = audioCtxC.currentTime;
}
let articulatedNodes = {};
let articulatedStarted = false;
let vibratoLFO = null;
let vibratoGain = null;
let vibratoActive = false;

function startArticulatedAudio() {
  if (articulatedStarted) return;
  articulatedStarted = true;

  // Oscillators for electric humming, harmonic layers
  const electricOsc = audioCtxC.createOscillator();
  const electricHarmOsc = audioCtxC.createOscillator();
  const electricGain = audioCtxC.createGain();
  const electricHarmGain = audioCtxC.createGain();

  electricOsc.type = "triangle";
  electricOsc.frequency.value = 30; // base freq lower than regular
  electricHarmOsc.type = "triangle";
  electricHarmOsc.frequency.value = 120;

  electricGain.gain.value = 0;
  electricHarmGain.gain.value = 0;

  electricOsc.connect(electricGain).connect(audioCtxC.destination);
  electricHarmOsc.connect(electricHarmGain).connect(audioCtxC.destination);

  electricOsc.start();
  electricHarmOsc.start();

  // Squeak-like modulation for siren pulse
  const squeakLFO = audioCtxC.createOscillator();
  const squeakDepth = audioCtxC.createGain();

  squeakLFO.frequency.value = 1.2; // ~1.2Hz pulse for siren in/out
  squeakDepth.gain.value = 0;

  squeakLFO.connect(squeakDepth).connect(electricHarmGain.gain);
  squeakLFO.start();

  // Diesel noise layer setup
  const bufferSize = 2 * audioCtxC.sampleRate;
  const noiseBuffer = audioCtxC.createBuffer(1, bufferSize, audioCtxC.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.12;
  }

  const dieselNoise = audioCtxC.createBufferSource();
  dieselNoise.buffer = noiseBuffer;
  dieselNoise.loop = true;

  const dieselGain = audioCtxC.createGain();
  dieselGain.gain.value = 0;

  const lowpass = audioCtxC.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 500;

  dieselNoise.connect(lowpass).connect(dieselGain).connect(audioCtxC.destination);

  dieselNoise.start();
vibratoLFO = audioCtxC.createOscillator();
vibratoGain = audioCtxC.createGain();
vibratoLFO.frequency.value = 3;
vibratoGain.gain.value = 1.1;

vibratoLFO.connect(vibratoGain).connect(electricHarmOsc.frequency);
vibratoLFO.start();
vibratoActive = true;

  articulatedNodes = {
    electricOsc,
    electricGain,
    electricHarmOsc,
    electricHarmGain,
    squeakLFO,
    squeakDepth,
    dieselNoise,
    dieselGain,
    lowpass,
    vibratoLFO,
    vibratoGain
  };
}

function updateArticulatedAudio() {
  const maxSpeed = 25;
  if (vx > maxSpeed) vx = maxSpeed;
  const norm = vx / 30;

  if (vx === 0) {
    articulatedNodes.electricGain.gain.setTargetAtTime(0.05, audioCtxC.currentTime, 0.2);
    articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.06, audioCtxC.currentTime, 0.2);
    articulatedNodes.squeakDepth.gain.setTargetAtTime(0.0, audioCtxC.currentTime, 0.3);
    articulatedNodes.dieselGain.gain.setTargetAtTime(0.6, audioCtxC.currentTime, 0.1);
    return;
  }
  if (vx >= 20) {
    articulatedNodes.electricGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.2);
    articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.2);
    articulatedNodes.squeakDepth.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.3);
    articulatedNodes.dieselGain.gain.setTargetAtTime(0.9, audioCtxC.currentTime, 0.1);
  }

  // Base electric frequencies increase with speed
  articulatedNodes.electricOsc.frequency.setTargetAtTime(55 + norm * 28, audioCtxC.currentTime, 0.2);
  articulatedNodes.electricHarmOsc.frequency.setTargetAtTime(145 + norm * 40, audioCtxC.currentTime, 0.2);

  // Gain dynamics, harmonic and fundamental
  articulatedNodes.electricGain.gain.setTargetAtTime(0.1 + norm * 0.08, audioCtxC.currentTime, 0.3);
  articulatedNodes.electricHarmGain.gain.setTargetAtTime(0.1 + norm * 0.07, audioCtxC.currentTime, 0.3);

  // Squeak modulation pulses like siren coming in/out
  const squeakTarget = accelerating ? 0.12 : 0.06;
  articulatedNodes.squeakDepth.gain.setTargetAtTime(squeakTarget * norm, audioCtxC.currentTime, 0.4);

  // Diesel noise louder with speed, filter frequency changes on acceleration
  articulatedNodes.dieselGain.gain.setTargetAtTime(0.3 + norm * 0.5, audioCtxC.currentTime, 0.4);
  const baseFreq = accelerating ? 550 : 350;
  articulatedNodes.lowpass.frequency.setTargetAtTime(baseFreq + norm * 600, audioCtxC.currentTime, 0.5);
}

// Call this continuously (e.g. in animation frame loop)
function updateAudioSystemC() {
  const maxSpeed = 13.5;
  if (vx > maxSpeed) vx = maxSpeed;
  const speedNorm = vx / maxSpeed;

  if (vx === 0) {
    // Reset when idle
    electricOsc.frequency.setValueAtTime(100, audioCtxC.currentTime);
    electricGain.gain.setTargetAtTime(0.0, audioCtxC.currentTime, 0.1);

    dieselGain.gain.setTargetAtTime(6, audioCtxC.currentTime, 0.01);
    return;
  }

  // Electric motor frequency ramps with speed
  const electricFreq = 4 + speedNorm * 200;
  electricOsc.frequency.setTargetAtTime(electricFreq, audioCtxC.currentTime, 0.2);

  // Electric gain: slowly increase from 0 to 0.4 as vx goes from 0 to 2,
  // then hold at 0.4 while diesel fades in after vx > 2.
  let electricTargetGain = 0;
  if (vx <= 2) {
    electricTargetGain = 0.1 * (vx / 2);  // linear ramp 0 to 0.4
  } else {
    electricTargetGain = 0.1; // hold max electric gain once diesel starts
  }
  electricGain.gain.setTargetAtTime(electricTargetGain, audioCtxC.currentTime, 0.2);

  // Diesel gain: fade in starting from vx > 2 up to max at vx=12
  if (vx > 2) {
    const dieselNorm = (vx - 2) / (maxSpeed - 2);
    const dieselVol = 0.2 + 0.5 * dieselNorm;
    dieselGain.gain.setTargetAtTime(dieselVol, audioCtxC.currentTime, 0.3);

    // Adjust diesel tone based on acceleration
    const filterFreq = accelerating
      ? 200 + 1000 * dieselNorm  // Brighter when accelerating
      : 100 + 500 * dieselNorm; // Deeper when slowing
    lowpass.frequency.setTargetAtTime(filterFreq, audioCtxC.currentTime, 0.3);
  } else {
    dieselGain.gain.setTargetAtTime(5, audioCtxC.currentTime, 0.01);
  }
}
function updateTrafficLights(deltaTime) {
  trafficLights.forEach((light, index) => {
    const cycleTime = 3000;

    if (light.timer === undefined) {
      light.timer = (index * 1000) % cycleTime;
      if (light.timer < 1000) light.state = 0;
      else if (light.timer < 2000) light.state = 1;
      else light.state = 2;
    } else {
      light.timer += deltaTime;
    }

    switch (light.state) {
      case 0:
        if (light.timer >= 9000) {
          light.state = 1;
          light.timer = 0;
          console.log(`Light ${index} switched to YELLOW`);
        }
        break;
      case 1:
        if (light.timer >= 1000) {
          light.state = 2;
          light.timer = 0;
          console.log(`Light ${index} switched to RED`);
        }
        break;
      case 2:
        if (light.timer >= 10000) {
          light.state = 0;
          light.timer = 0;
          console.log(`Light ${index} switched to GREEN`);
        }
        break;
    }
  });
}


function animate2() {
  if (articulated) {
    updateArticulatedAudio()
  } else if (!articulated && audioCStarted) {
  updateAudioSystemC();
  } else if (audioAStarted) {
   updateAudioSystemA()
  }
  requestAnimationFrame(animate2);
}
animate2()
// --- Keyboard Controls ---
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (keysDown.has(key)) return; // Prevent repeat while held

  if (key === '3') {
    if (!audioBStarted) {
      initAudioB();
      simulationStepB();
      audioBStarted = true;
    }
    ctxB.resume();
    audioCtxA.suspend();
    audioCtxC.suspend?.();
    currentSystem = "B";
  } else if (key === '1') {
    if (!audioAStarted) {
      startAudioA();
      audioAStarted = true;
    }
    audioCtxA.resume();
    ctxB.suspend();
    audioCtxC.suspend?.();
    currentSystem = "A";
  } else if (key === '2') {
    if (!audioCStarted) {
      if (articulated) {
        startArticulatedAudio()
      } else {
      startAudioC();
    }}
    audioCtxC.resume();
    ctxB.suspend?.();
    audioCtxA.suspend();
    currentSystem = "C";
    animate2(); 
  }

  keysDown.add(key);
});

window.addEventListener('keyup', e => {
  keysDown.delete(e.key.toLowerCase());
});

// --- System Toggle Function ---
async function toggleSystems() {
  if (currentSystem === "A") {
    await audioCtxA.suspend();
  } else if (currentSystem === "B") {
    await ctxB.suspend();
  } else if (currentSystem === "C") {
    await audioCtxC.suspend?.();
  }

  systemIndex = (systemIndex + 1) % systemOrder.length;
  const nextSystem = systemOrder[systemIndex];

  if (nextSystem === "A") {
    if (!audioAStarted) {
      startAudioA();
    }
    await audioCtxA.resume();
  } else if (nextSystem === "B") {
    if (!audioBStarted) {
      initAudioB();
      simulationStepB();
      audioBStarted = true;
    }
    await ctxB.resume();
  } else if (nextSystem === "C") {
    if (!audioCStarted) {
      if (!articulated) {
      startAudioC();
      updateAudioSystemC()
    } else {
      startArticulatedAudio()
      updateArticulatedAudio()
    }}
    await audioCtxC.resume();
  }

  currentSystem = nextSystem;
}
let trafficLights = [];
const trafficLightSpacing = 20000;
const firstLightX = 1000;
const lightRadius = 12;

// --- Global Variables ---
const STOP_INTERVAL = 1250;
const STOP_SPAWN_LIMIT = 5000000;
const STOP_RADIUS = 20;
const STOP_COUNTER_TRIGGER = 1000;

let stops = [];
let passengersOnBoard = 0;
let nextStopRequest = null;
let pendingDropRequest = false;
let collectedDisplay = null;
let collectedDisplayTimeout = null;
let camX = 0;
// --- Call this ONCE on game start/reset ---
let showNotice = false;
let distance = 3000; // define outside loop

const STOP_SPACING_OPTIONS = [5000, 8000, 10000];
function generateStops() {
  stops = [];
  let x = -10000;
  let stopIndex = 0;

  while (x <= STOP_SPAWN_LIMIT) {
    const assignedBus = stopIndex % 6; // 0–5, where 5 is the player
    const isPlayerOnly = assignedBus === 5;

    const stop = {
      x,
      collected: false,
      regenTime: 0,
      special: Math.random() < 0.2,
      playerOnly: isPlayerOnly,
      assignedBus: assignedBus,
    };
    stops.push(stop);

    // 20% chance of double stop placed 500px after the current stop
    if (Math.random() < 0.2) {
      const doubleStop = {
        x: x + 500,
        collected: false,
        regenTime: 0,
        special: Math.random() < 0.2,
        playerOnly: isPlayerOnly,
        assignedBus: assignedBus,
      };
      stops.push(doubleStop);
    }

    const spacing = STOP_SPACING_OPTIONS[Math.floor(Math.random() * STOP_SPACING_OPTIONS.length)];
    x += spacing;
    stopIndex++;
  }
}
generateStops()
  let currentBusIndex = 0;

let startAudioCalled = false;
let amount = 0


  const tilt = 0;
function drawMinimap(bus, camX) {
  const minimap = document.getElementById('minimap');
  const ctx = minimap.getContext('2d');
  const w = minimap.width;
  const h = minimap.height;

  ctx.clearRect(0, 0, w, h);

  const RANGE = 20000; // Show ±10,000px from bus
  const ROAD_WIDTH = h / 3;
  const CENTER_Y = h / 2;
  const startX = bus.x - RANGE / 2;
  const endX = bus.x + RANGE / 2;

  // 1. DRAW ROAD BED (Darker color)
  ctx.fillStyle = "#3c434c"; // Dark grey asphalt color
  ctx.fillRect(0, CENTER_Y - ROAD_WIDTH / 2, w, ROAD_WIDTH);

  // 2. DRAW LANE MARKER (Single solid yellow line)
  ctx.strokeStyle = "#ffeb3b"; // Bright yellow
  ctx.lineWidth = 2;
  ctx.setLineDash([]); // Reset to solid line
  ctx.beginPath();
  ctx.moveTo(0, CENTER_Y);
  ctx.lineTo(w, CENTER_Y);
  ctx.stroke();

  // 3. DRAW CURBS/Shoulders (Lighter grey borders)
  ctx.fillStyle = "#a8b3c0"; // Light grey shoulder
  ctx.fillRect(0, CENTER_Y - ROAD_WIDTH / 2 - 2, w, 2);
  ctx.fillRect(0, CENTER_Y + ROAD_WIDTH / 2, w, 2);

  // 4. Draw BUS STOPS (Leave as circles, shifted to the side)
  for (const stop of stops) {
    if (stop.x >= startX && stop.x <= endX) {
      const percent = (stop.x - startX) / RANGE;
      const x = percent * w;
      const y = CENTER_Y;
      const color = stop.special ? "#f7c700" : "#007bff"; // Gold for special, blue for regular

      // Main stop circle
      ctx.beginPath();
      ctx.arc(x, y + ROAD_WIDTH * 0.35, 3.5, 0, Math.PI * 2); // Shift slightly off center to the 'side'
      ctx.fillStyle = stop.collected ? "rgba(100, 100, 100, 0.5)" : color;
      ctx.fill();

      // Player-only cyan indicator (optional)
      if (stop.playerOnly) {
        ctx.beginPath();
        ctx.arc(x, y + ROAD_WIDTH * 0.35, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = "cyan";
        ctx.fill();
      }
    }
  }

  // 5. Draw AI Buses (Rectangles)
  for (const aiBus of aiBuses) {
    if (aiBus.x >= startX && aiBus.x <= endX) {
      const percent = (aiBus.x - startX) / RANGE;
      const x = percent * w;
      ctx.fillStyle = "#4caf50"; // Green for AI buses
      
      // AI Bus rectangle shape
      ctx.fillRect(x - 4, CENTER_Y + 15 - ROAD_WIDTH * 0.3, 8, 7); 
    }
  }

  // 6. Draw PLAYER BUS (Rectangle)
  const playerX = (bus.x - startX) / RANGE * w;
  ctx.fillStyle = "#ff5722"; // Orange-Red for player bus
  
  // Player Bus rectangle shape
  ctx.fillRect(playerX - 5, CENTER_Y + 15 - ROAD_WIDTH * 0.3 - 1, 10, 9);
  
  // Add a small dot for direction
  ctx.fillStyle = "#eee";
  ctx.beginPath();
  ctx.arc(playerX + 2, CENTER_Y + 15 - ROAD_WIDTH * 0.3 + 3, 1.2, 0, Math.PI * 2);
  ctx.fill();


  // 7. Draw TRAIN Traffic Lights
  for (const light of trainTrafficLights) {
    if (light.x >= startX && light.x <= endX) {
      const percent = (light.x - startX) / RANGE;
      const x = percent * w;

      ctx.beginPath();
      ctx.arc(x, CENTER_Y - ROAD_WIDTH * 0.35, 3, 0, Math.PI * 2); // Placed above the road
      ctx.fillStyle = light.state === 1 ? "#ff0000" : "#222222"; // Red or Off
      ctx.fill();
    }
  }

  // 8. Viewport box based on screen size (approximation)
  const screenWidthPx = 800; 
  const percentCamStart = (camX - startX) / RANGE;
  const percentCamEnd = (camX + screenWidthPx - startX) / RANGE;
  const camStart = percentCamStart * w;
  const camEnd = percentCamEnd * w;

  ctx.strokeStyle = "#000000";
  ctx.lineWidth = 1;
  ctx.strokeRect(camStart, CENTER_Y - ROAD_WIDTH / 2 - 2, camEnd - camStart, ROAD_WIDTH + 4);
}

  const fuelPickups = [
    { x: 100, collected: false },
    { x: 300, collected: true },
    { x: 500, collected: false },
  ];
  // === GLOBAL STATE ===
const trainTracks = [];
const spawnedTracks = new Set();
const trains = [];


const trackSpacing = 50000;
const firstTrack = 5000;

// === GENERATE TRAIN TRACKS ===
function generateTracksUpTo(xLimit) {
  for (let x = firstTrack; x <= xLimit; x += trackSpacing) {
    if (!trainTracks.some(t => t.x === x)) {
      const isDouble = Math.random() < 0.9;
      trainTracks.push({ x, isDouble });
    }
  }
}

// === TRAIN SPAWNING ===
function spawnTrain(trackX) {
  trains.push({
    worldX: trackX,
    scale: 0.1,
    growthSpeed: 0.005,
    spawnTime: Date.now()
  });
}

function checkTrainSpawn(bus) {
  trainTracks.forEach(({ x }) => {
    if (bus.x >= x - 1000 && !spawnedTracks.has(x)) {
      spawnTrain(x);
      spawnedTracks.add(x);
    }
  });
}

// === TRAIN DRAWING ===
function drawTrains(ctx, camX) {
  const now = Date.now();
  for (let i = trains.length - 1; i >= 0; i--) {
    const train = trains[i];
    train.scale += train.growthSpeed;

    if (train.scale > 4 || now - train.spawnTime > 30000) {
      trains.splice(i, 1);
      continue;
    }

    const screenX = train.worldX - camX;
    const y = getRoadY(train.worldX);
    const width = 100 * train.scale;
    const height = 100 * train.scale;

    ctx.fillStyle = "#333";
    ctx.fillRect(screenX - width / 2, y - height, width, height);
    ctx.fillStyle = "#ccc";
    ctx.fillRect(screenX - width / 4, y - height + 10 * train.scale, width / 2, 12 * train.scale);
    ctx.fillStyle = "#222";
    ctx.beginPath();
    ctx.ellipse(screenX - width / 3, y - 10, 10 * train.scale, 5 * train.scale, 0, 0, Math.PI * 2);
    ctx.ellipse(screenX + width / 3, y - 10, 10 * train.scale, 5 * train.scale, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}
function drawTransitStation(ctx, x, camX) {
  const screenX = x - camX;
  const buildingWidth = 1000;
  const buildingHeight = 900;
  const baseY = canvas.height - buildingHeight + 1100;

  // Main building
  ctx.fillStyle = '#666';
  ctx.fillRect(screenX, baseY, buildingWidth, buildingHeight);

  // Dark gray brick base
  ctx.fillStyle = '#444';
  ctx.fillRect(screenX, baseY + buildingHeight - 30, buildingWidth, 30);

  // Optional: Add windows
  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
  for (let i = 0; i < 5; i++) {
    ctx.fillRect(screenX + 40 + i * 100, baseY + 20, 40, 60);
  }

  // Optional: Add sign
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 18px sans-serif';
  ctx.fillText('TRANSIT STATION', screenX + 20, baseY + 5);
}

// === TRACK DRAWING ===
function drawTracks(ctx, camX) {
  trainTracks.forEach(({ x }) => {
    const screenX = x - camX;
    const y = getRoadY(x); // Make tracks follow road Y
    ctx.strokeStyle = "#6B4C3B";
    ctx.lineWidth = 100;
    ctx.beginPath();
    ctx.moveTo(screenX - 160, y);
    ctx.lineTo(screenX + 160, y);
    ctx.stroke();
  });
}

// === TRAIN TRAFFIC LIGHTS ===
function generateTrainTrafficLights(busX) {
  trainTrafficLights = [];
  trainTracks.forEach(({ x }) => {
    if (Math.abs(busX - x) < 5000) {
      trainTrafficLights.push({ x, state: 0 });
    }
  });
}

function updateTrainTrafficLights(deltaTime) {
  if (trains.length > 0) {
    trainFlashTimer += deltaTime;
    if (trainFlashTimer >= 500) {
      trainFlashOn = !trainFlashOn;
      trainFlashTimer = 0;
    }
    trainTrafficLights.forEach(light => {
      light.state = trainFlashOn ? 1 : 0;
    });
  } else {
    trainFlashTimer = 0;
    trainFlashOn = true;
    trainTrafficLights.forEach(light => {
      light.state = 0;
    });
  }
}

function drawTrainTrafficLights(ctx, camX, canvasWidth) {
  trainTrafficLights.forEach(light => {
    const y = getRoadY(light.x) - 30; // Position above the road
    const x = light.x - camX;
    if (x < -100 || x > canvasWidth + 3000) return;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fillStyle = light.state === 1 ? "#ff0000" : "#000000";
    ctx.fill();


    // Draw railway rectangle 100px after the traffic light
    // Find traffic light x for this track (if any)
      const railX = (light.x + 290) - camX;  // 100 px after light
      const railY = getRoadY(light.x + 290);

      // Draw brown rectangle representing railway tie
      const rectWidth = 150;
      const rectHeight = 30;
      ctx.fillStyle = "#6B4C3B";
      ctx.fillRect(railX - rectWidth / 2, railY - 25, rectWidth, rectHeight);

      // Draw two small squares inside the rectangle
      const squareSize = 35;
      const gap = 30; // space between squares

      ctx.fillStyle = "#333"; // darker brown for squares

      // Left square
      ctx.fillRect(railX - gap - squareSize / 2, railY - 25, squareSize, squareSize);

      // Right square
      ctx.fillRect(railX + gap - squareSize / 2, railY - 25, squareSize, squareSize);
    
  });
}

function isTrainLightBlocking(busX) {
  return trainTrafficLights.some(light =>
    Math.abs(busX - light.x) < 500 && light.state === 1
  
  );
}

  // Bus data for each type
  const buses = [
    {
      name: "Gillig 29'",
      x: 200,
      y: 330,
      width: 450,   // slightly shorter than before (was 400)
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [300, 340], // relative to bus.x
      doorSize: {width: 40, height: 130},
      window: { x: 30, y: 40, width: 250, height: 93.33},
      wheelOffsets: [125, 260],
      window2: { x: 380, y: 45, width: 0, height: 0 },
      bodyBezierOffset: 63,
    },
    {
      name: "Gillig 40'",
      x: 200,
      y: 330,
      width: 470,
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [350, 390], // doors moved further back for longer bus
      backDoorPositions: [140, 180],
      doorSize: {width: 40, height: 130},
      window: { x: 0, y: 40, width: 140, height: 87.33},
      wheelOffsets: [100, 300],
      window2: { x: 220, y: 40, width: 130, height: 87.33 },
      bodyBezierOffset: 70,
    },
    {
      name: "New Flyer Xcelsior 40'",
      x: 200,
      y: 330,
      width: 500,
      height: 180,
      wheelAngle: 0.1,
      doorPositions: [405, 430], // doors moved further back for longer bus
      doorSize: {width: 50, height: 130},
      backDoorPositions: [160, 205],
      window: { x: 55, y: 40, width: 105, height: 80.33},
      wheelOffsets: [125, 360],
      window2: { x: 255, y: 40, width: 150, height: 93.33 },
      bodyBezierOffset: 70,
    }
  ];
  // Control flags
let driverLocked = false;
let isLowered = false;
let xB = 0
// Kneeling amount
const LOWER_OFFSET = 10;// Default gradient stops
let gradientStops = [
  { offset: 0, color: '#d3d3d3' },
  { offset: 1, color: '#d3d3d3' }
];
let points = parseInt(localStorage.getItem('playerPoints')) || 1;
// Save to localStorage
function savePoints() {
  localStorage.setItem('playerPoints', points);
}

// Load from localStorage or fallback
function loadGradientStops() {
  const saved = localStorage.getItem('busGradientStops');
  if (saved) {
    gradientStops = JSON.parse(saved);
  }
}
loadGradientStops();
let stopHistory = JSON.parse(localStorage.getItem("stopHistory") || "[]");

function savePoints() {
  localStorage.setItem("points", points);
}

function saveStopHistoryEntry(entry) {
  stopHistory.push(entry);
  localStorage.setItem('stopHistory', JSON.stringify(stopHistory));
}

// Update the color pickers with loaded colors
const startColorPicker = document.getElementById('endColorPicker');
const endColorPicker = document.getElementById('startColorPicker');

startColorPicker.value = gradientStops[0].color;
endColorPicker.value = gradientStops[1].color;

// Save function
function saveGradientStops() {
  localStorage.setItem('busGradientStops', JSON.stringify(gradientStops));
}

// Set gradient colors and save
function setBusGradientColors(startColor, endColor) {
  gradientStops = [
    { offset: 0, color: startColor },
    { offset: 1, color: endColor }
  ];
  saveGradientStops();
}

// Listen for changes on the color pickers
startColorPicker.addEventListener('input', (e) => {
  setBusGradientColors(e.target.value, gradientStops[1].color);
});

endColorPicker.addEventListener('input', (e) => {
  setBusGradientColors(gradientStops[0].color, e.target.value);
});

// In your draw function, use gradientStops like this:

function generateTrafficLights(busX, intersection = null) {
  let centerX;

  if (intersection && typeof intersection.x === 'number') {
    centerX = intersection.x;
  } else if (typeof busX === 'number') {
    centerX = busX;
  } else {
    // fallback or error handling
    console.warn('generateTrafficLights: invalid busX and no intersection given');
    return;
  }

  // Calculate centerIndex as integer grid index based on position
  const centerIndex = Math.floor(centerX / trafficLightSpacing);

  if (centerIndex === lastCenterIndex) return;
  lastCenterIndex = centerIndex;

  const newLights = [];
  for (let i = -Math.floor(lightCount / 2); i <= Math.floor(lightCount / 2); i++) {
    const lightX = (centerIndex + i) * trafficLightSpacing;
    let existingLight = trafficLights.find(l => l.x === lightX);

    if (!existingLight) {
      existingLight = {
        x: lightX,
        state: 0,
        timer: 0,
        violated: false
      };
    }
    newLights.push(existingLight);
  }
  trafficLights = newLights;
}


window.addEventListener('keydown', e => {
  if ((e.key === 'l' || e.key === 'l') && vx === 0) {
    driverLocked = !driverLocked
    isLowered = !isLowered;
    console.log(isLowered ? "⬇ Bus lowered (kneeling)." : "⬆ Bus raised.");
  }
});
function saveGradient(stops) {
  if (!Array.isArray(stops)) return;

  try {
    localStorage.setItem('busGradient', JSON.stringify(stops));
  } catch (e) {
    console.error('Failed to save gradient:', e);
  }
}

let lastDrawTime = performance.now();
const signalSigns = [];
const maxSigns = 5;
function exportGradient() {
  const blob = new Blob([JSON.stringify(gradientStops, null, 2)], {
    type: 'application/json',
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'bus-gradient.sg';
  a.click();
  URL.revokeObjectURL(url);
}
document.getElementById('importGradientFile').addEventListener('change', function (event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const imported = JSON.parse(e.target.result);
      if (Array.isArray(imported)) {
        gradientStops = imported;
        saveGradientStops()
        alert("Gradient imported successfully!");
      } else {
        alert("Invalid gradient format.");
      }
    } catch (err) {
      alert("Failed to load gradient: " + err.message);
      saveGradientStops()
    }
  };
  reader.readAsText(file);
});
saveGradientStops()
const backgroundLayers = [
  { speed: 0.1, objects: [], type: 'cloud' },
  { speed: 0.2, objects: [], type: 'building' },
  { speed: 0.4, objects: [], type: 'tree' },
  { speed: 0.8, objects: [], type: 'car' }
];

const brightBackdropColors = [
  '#FF3B3B', '#FF9B00', '#FFEB3B', '#8BC34A', '#00BCD4', '#3F51B5', '#9C27B0', '#E91E63',
  '#FFC107', '#4CAF50', '#00E5FF', '#673AB7', '#F44336', '#CDDC39', '#2196F3', '#FF9800'
];

// Named buildings limited to 20 with 5 variants each
const namedBuildings = [
  'Post Office', 'Library', 'Supermarket', 'Bakery', 'Cafe', 'Cinema', 'Museum', 'Clinic',
  'Gym', 'Fire Station', 'Police Station', 'Bank', 'Fast Food', 'Pharmacy', 'Bookstore',
  'Hotel', 'Apartments', 'Office Tower', 'Gas Station', 'Court House'
];

// Fonts for each building name type (change as needed)
const buildingFonts = {
  'Post Office': 'italic 18px serif',
  'Library': 'bold 18px "Georgia", serif',
  'Supermarket': 'bold 16px "Arial Black", sans-serif',
  'Bakery': 'italic 16px "Comic Sans MS", cursive',
  'Cafe': 'bold 16px "Lucida Handwriting", cursive',
  'Cinema': 'bold 18px "Impact", sans-serif',
  'Museum': 'italic 18px "Times New Roman", serif',
  'Clinic': 'bold 18px "Trebuchet MS", sans-serif',
  'Gym': 'bold 20px "Verdana", sans-serif',
  'Fire Station': 'bold 18px "Tahoma", sans-serif',
  'Police Station': 'bold 18px "Courier New", monospace',
  'Bank': 'bold 20px "Georgia", serif',
  'Fast Food': 'bold 18px "Arial Black", sans-serif',
  'Pharmacy': 'italic 16px "Palatino", serif',
  'Bookstore': 'italic 18px "Georgia", serif',
  'Hotel': 'bold 18px "Lucida Bright", serif',
  'Apartments': 'bold 16px "Arial", sans-serif',
  'Office Tower': 'bold 18px "Helvetica", sans-serif',
  'Gas Station': 'bold 18px "Verdana", sans-serif',
  'Court House': 'bold 20px "Times New Roman", serif',
};

// Utility function to draw pillars (used for Court House, Bank, etc.)
function drawPillars(ctx, x, y, width, height, count) {
  const pillarWidth = width / (count * 2);
  const pillarHeight = height * 0.7;
  ctx.fillStyle = '#CCC';
  for (let i = 0; i < count; i++) {
    const px = x + i * pillarWidth * 2 + pillarWidth / 2;
    ctx.fillRect(px, y + height - pillarHeight, pillarWidth, pillarHeight);
    // Pillar top
    ctx.fillRect(px - 5, y + height - pillarHeight - 10, pillarWidth + 10, 10);
  }
}

// Icon drawing for specific building types (simple vector shapes)

function drawBookIcon(ctx, x, y, size) {
  ctx.fillStyle = '#7B3F00';
  ctx.fillRect(x, y, size * 0.7, size);
  ctx.fillStyle = '#A0522D';
  ctx.fillRect(x + size * 0.7, y + size * 0.1, size * 0.1, size * 0.8);
}

function drawBakeryDisplay(ctx, x, y, width, height) {
  ctx.fillStyle = '#FFDAB9';
  ctx.fillRect(x, y + height * 0.7, width, height * 0.3);
  ctx.fillStyle = '#F4A460';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.ellipse(x + width * (0.2 + i * 0.3), y + height * 0.85, width * 0.07, height * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawPillarRoof(ctx, x, y, width) {
  ctx.fillStyle = '#BBB';
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + width / 2, y - 30);
  ctx.lineTo(x + width, y);
  ctx.closePath();
  ctx.fill();
}

function drawBuildingName(ctx, name, x, y, width, align = 'center') {
  ctx.fillStyle = '#FFF';
  ctx.textBaseline = 'top';
  ctx.font = buildingFonts[name] || '16px sans-serif';
  ctx.textAlign = align;
  if (align === 'center') {
    ctx.fillText(name, x + width / 2, y);
  } else if (align === 'left') {
    ctx.fillText(name, x + 5, y);
  }
}

// Now the main drawing function for buildings including variants and decorations

function drawNamedBuilding(ctx, obj, time) {
  const { x, y, width, height, name, variant } = obj;
  const screenX = x - camX * 0.2;

  // Base colors & gradients for variants (adjust to taste)
  const baseColors = [
    '#2C3E50', '#34495E', '#7F8C8D', '#95A5A6', '#BDC3C7'
  ];
  const baseColor = baseColors[variant % baseColors.length];

  // Draw building base
  const grad = ctx.createLinearGradient(0, y, 0, y + height);
  grad.addColorStop(0, baseColor);
  grad.addColorStop(1, '#000');
  ctx.fillStyle = grad;
  ctx.fillRect(screenX, y, width, height);

  // Mono large window if applicable (some buildings have no windows)
  const windowMargin = 20;
  const windowWidth = width - windowMargin * 2;
  const windowHeight = height * 0.6;
  const windowY = y + height * 0.25;

  // Draw windows only on specific types
  if (['Library', 'Supermarket', 'Bakery', 'Cafe', 'Cinema', 'Museum', 'Clinic', 'Gym', 'Bank', 'Bookstore', 'Hotel', 'Office Tower'].includes(name)) {
    // Mono window with gradient
    const windowGrad = ctx.createLinearGradient(0, windowY, 0, windowY + windowHeight);
    windowGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
    windowGrad.addColorStop(1, 'rgba(200, 200, 255, 0.1)');
    ctx.fillStyle = windowGrad;
    ctx.fillRect(screenX + windowMargin, windowY, windowWidth, windowHeight);
  }

  // Draw building specific decoration by name and variant
  switch (name) {
    case 'Library':
      // Draw a book icon on wall
      drawBookIcon(ctx, screenX + width / 2 - 20, y + height * 0.15, 40);
      drawBuildingName(ctx, name, screenX, y + 5, width, 'center');
      break;

    case 'Bakery':
      drawBakeryDisplay(ctx, screenX + 10, y + height * 0.65, width * 0.8, height * 0.25);
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;

    case 'Court House':
      drawPillars(ctx, screenX + width * 0.15, y, width * 0.7, height, 6);
      drawPillarRoof(ctx, y, y, width);
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;

    case 'Bank':
      drawPillars(ctx, screenX + width * 0.1, y + height * 0.1, width * 0.8, height * 0.7, 4);
      drawBuildingName(ctx, name, screenX + width / 2, y + 5, width, 'center');
      break;

    case 'Post Office':
      // Use a stripe for the post office
      ctx.fillStyle = '#003366';
      ctx.fillRect(screenX, y + height * 0.1, width, height * 0.15);
      drawBuildingName(ctx, name, screenX + width / 2, y + 5, width, 'center');
      break;

    default:
      // Just building name top-left for others
      drawBuildingName(ctx, name, screenX + 5, y + 5, width, 'left');
      break;
  }
}
const intersections = [];
const canvasWidth = 800; // example, adjust as needed
const canvasHeight = 600;
const mainRoadY = canvasHeight - 100;

// Generate intersections up to some max distance (e.g. 100000 px)
const maxDistance = 100000;
let lastX = 0;
while (lastX < maxDistance) {
  const gap = 2000 + Math.random() * 3000; // 2000-5000 px gap
  lastX += gap;
  intersections.push({
    x: lastX,
    hasTrafficLight: Math.random() < 0.2, // 20% chance
  });
}

function drawIntersection(ctx, camX, intersection) {
  const screenX = intersection.x - camX + canvasWidth / 2;

  // Only draw if on screen (roughly)
  if (screenX < -200 || screenX > canvasWidth + 200) return;

  const buildingWidth = 120;
  const buildingHeight = 200;

  // Draw perpendicular street (vertical road)
  ctx.fillStyle = '#444'; // dark asphalt
  ctx.fillRect(screenX - 50, 0, 100, canvasHeight);

  // Draw building at NE corner (right of vertical road, above main road)
  const buildingX = screenX + 50;
  const buildingY = mainRoadY - buildingHeight;
  ctx.fillStyle = '#a0522d';
  ctx.fillRect(buildingX, buildingY, buildingWidth, buildingHeight);

  // Windows on building
  ctx.fillStyle = '#555';
  const windowSize = 20;
  for(let y = buildingY + 10; y < buildingY + buildingHeight - 10; y += 40) {
    for(let x = buildingX + 10; x < buildingX + buildingWidth - 10; x += 40) {
      ctx.fillRect(x, y, windowSize, windowSize);
    }
  }

  // Draw traffic light if this intersection has one
  if (intersection.hasTrafficLight) {
    const lightX = buildingX - 40;
    const lightY = mainRoadY - 70;

    // Pole
    ctx.fillStyle = '#222';
    ctx.fillRect(lightX + 12, lightY, 6, 50);

    // Traffic light box
    ctx.fillStyle = '#000';
    ctx.fillRect(lightX, lightY - 30, 30, 60);

    // Lights: red, yellow, green
    const lightRadius = 8;
    const lightSpacing = 20;
    const colors = ['red', 'yellow', 'green'];
    for(let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.fillStyle = colors[i];
      ctx.arc(lightX + 15, lightY - 20 + i * lightSpacing, lightRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
  }
}
function drawAllIntersections(ctx, camX) {
  const roadWidth = 350;
  const mainRoadTop = canvas.height - 140;   // top edge of sidewalk
  const mainRoadHeight = 140;                // sidewalk + main road total height
  const sidewalkWidth = 15;
  const buildingWidth = 80;
  const buildingHeight = 140;

  // Remove traffic lights for intersections too far from camX (>500px)
  trafficLights = trafficLights.filter(light => {
    // Find corresponding intersection
    const intersection = intersections.find(i => i.x === light.x);
    if (!intersection) return false; // no intersection found => remove light
    const dist = Math.abs(intersection.x - camX);
    return dist <= 500;
  });

  for (const intersection of intersections) {
    // Calculate screen position relative to camera
    const screenX = intersection.x - camX + canvas.width / 2;

    // Draw perpendicular road - vertical rectangle cutting main road + sidewalk
    ctx.fillStyle = '#333';  // same as main road color
    ctx.fillRect(screenX - roadWidth / 2, mainRoadTop, roadWidth, mainRoadHeight);

  }
}
// Helper function to draw a traffic light at (x, y)
function drawTrafficLight(ctx, x, y) {
  const lightWidth = 20;
  const lightHeight = 60;
  ctx.fillStyle = '#222';
  ctx.fillRect(x - lightWidth / 2, y - lightHeight, lightWidth, lightHeight);

  // Lights: red, yellow, green circles
  const radius = 6;
  const spacing = 20;
  const colors = ['red', 'yellow', 'green'];
  for (let i = 0; i < colors.length; i++) {
    ctx.beginPath();
    ctx.fillStyle = colors[i];
    ctx.arc(x, y - lightHeight + spacing * (i + 1), radius, 0, Math.PI * 2);
    ctx.fill();
  }
}
let freeCam = false;
let freeCamX = 0;

// Inside key listener:
window.addEventListener('keydown', e => {
  if (e.key === 'f') freeCam = !freeCam;
});
// Modified main draw function to include named buildings variants
// Array to hold AI buses
const aiBuses = [];
let aiBusSpawned = false; // Prevent multiple spawns
const aiCars = []; // All dumb cars
const STUCK_CAR_PROBABILITY = 0.2; // 20% chance it's a stuck car
const MAX_CAR_SPEED = 7.5;
const bridges = []
function spawnAICar(x, y) {
  const stuck = Math.random() < STUCK_CAR_PROBABILITY;
  const hateBuses = Math.random() < 0.5;

  aiCars.push({
    x,
    y: getRoadY(x), // Set initial y correctly
    speed: stuck ? 0 : 3 + Math.random() * (MAX_CAR_SPEED - 3),
    stuck,
    hateBuses,
    slowdownTimer: 0,
  });
}

const BUS_SPACING_SEC = 30;      // 20 seconds between buses schedule offsets
const IDEAL_SPEED = 200;         // px per second (5000 px in 25 seconds)

function updateAICars(bus) {
  for (let i = aiCars.length - 1; i >= 0; i--) {
    const car = aiCars[i];
    
    // NEW: Update car's Y position to follow the road
    car.y = getRoadY(car.x);

    if (car.stuck) continue;

    // Despawn if car is far behind the bus
    if (car.x < bus.x - 800) {
      aiCars.splice(i, 1); // Remove car
      continue;
    }

    // Initialize slowdown timer if missing
    car.slowdownTimer ??= 0;

    const distToBus = Math.abs(car.x - bus.x);

    if (car.hateBuses && distToBus < 200) {
      // Trigger slowdown
      car.slowdownTimer++;
      if (car.slowdownTimer < 60) {
        car.speed = Math.max(1, car.speed - 0.1); // Gradual slowdown
      } else {
        car.slowdownTimer = 0;
        car.speed = 3 + Math.random() * (MAX_CAR_SPEED - 3); // Resume speed
      }
    } else {
      car.slowdownTimer = 0;
    }

    car.x -= car.speed;
  }
}


let raceMode = false;
let raceTimer = 0;

// Config Constants
const MAX_AI_SPEED = 11;
const RANDOM_STOP_PROBABILITY = 0.002;
const RANDOM_STOP_DURATION = 300;

const BUS_INTERVAL_PX = 2000;
const PASS_INTERVAL_MS = 25000; // 25 sec per 5000px
const PASS_TOLERANCE_MS = 5000;

// Ideal speed = px/ms (distance over time)

const SPEED_PX_PER_MS = IDEAL_SPEED; // alias for clarity



// Map to store each bus's schedule offset (in ms)
const scheduleOffsets = new Map();

/**
 * Assign schedule offsets:
 * - Player bus = 0 offset (base schedule)
 * - AI buses staggered ahead and behind by 20s intervals
 * e.g. first AI bus 20s behind, second 20s ahead,
 * third 40s behind, fourth 40s ahead, etc.
 * @param {Object} playerBus
 * @param {Array} aiBuses
 */
/**
 * Dynamically assign schedule offsets based on buses' current positions
 * relative to the playerBus.x
 * @param {Object} playerBus
 * @param {Array} aiBuses
 */
// Global constants

let lastLogTime = 0;


// Create AI Bus object
function createAIBus(startX = 0) {
  return {
    x: startX,
    y: 330,
    speed: 0,
    maxSpeed: 13,
    waiting: false,
    waitTimer: 0,
    width: 470,
    height: 180,
    wheelAngle: 0.1,
    doorPositions: [350, 390],
    backDoorPositions: [140, 180],
    doorSize: { width: 40, height: 130 },
    window: { x: 0, y: 40, width: 140, height: 87.33 },
    window2: { x: 220, y: 40, width: 130, height: 87.33 },
    wheelOffsets: [100, 300],
    bodyBezierOffset: 70,
    typeIndex: 1,
    beepTimer: 0,
    state: "follow",
    bypassProgress: 0,
    randomStopTimer: 0,
  };
}

// Play honk sound
function playHonkSound() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(440, ctx.currentTime);
  gain.gain.setValueAtTime(0.15, ctx.currentTime);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.4);
}

// Assign schedule offsets based on player bus position
function assignScheduleOffsetsByPosition(playerBus, aiBuses) {
  scheduleOffsets.clear();
  scheduleOffsets.set(playerBus, 0);

  const busesAhead = [];
  const busesBehind = [];

  for (const bus of aiBuses) {
    if (bus.x > playerBus.x) {
      busesAhead.push(bus);
    } else if (bus.x < playerBus.x) {
      busesBehind.push(bus);
    } else {
      busesAhead.push(bus); // treat equal position as ahead
    }
  }

  busesAhead.sort((a, b) => a.x - b.x);
  busesBehind.sort((a, b) => b.x - a.x);

  busesAhead.forEach((bus, i) => {
    scheduleOffsets.set(bus, (i + 1) * BUS_SPACING_SEC * 1000);
  });

  busesBehind.forEach((bus, i) => {
    scheduleOffsets.set(bus, -(i + 1) * BUS_SPACING_SEC * 1000);
  });
}

// Get ideal X position of a bus based on elapsed time and schedule offset
function getIdealPosition(bus, elapsedTime) {
  const offsetMs = scheduleOffsets.get(bus) ?? 0;
  const idealElapsed = elapsedTime - offsetMs;
  return idealElapsed > 0 ? idealElapsed * IDEAL_SPEED : 0;
}

function getLateness(bus, elapsedTime) {
  const offsetMs = scheduleOffsets.get(bus) ?? 0;
  const idealX = IDEAL_SPEED * ((elapsedTime - offsetMs) / 1000);  // Correct offset use
  return bus.x - idealX;
}

// Get nearest AI buses ahead and behind playerX
function getNearestAIBuses(playerX) {
  let behind = null, ahead = null;
  let minBehindDist = Infinity, minAheadDist = Infinity;

  for (const bus of aiBuses) {
    const dx = bus.x - playerX;
    if (dx < 0 && Math.abs(dx) < minBehindDist) {
      behind = bus;
      minBehindDist = Math.abs(dx);
    } else if (dx > 0 && dx < minAheadDist) {
      ahead = bus;
      minAheadDist = dx;
    }
  }
  return { behind, ahead };
}
// === Constants ===
const IDEAL_SPACING = 7000; // px between ideal points of buses
const MAX_CATCHUP_SPEED_BOOST = 7;
const SAFE_FOLLOW_DISTANCE = 200; // px
const PATIENCE_FRAMES = 30;
const MAX_BUS_SPEED = 300;

const aiBusCount = 4; // example count excluding player

// Player bus ideal is 0px at start, moves at IDEAL_SPEED
// AI buses ideal points spaced +/- 7000 px from 0 (player bus ideal)
const aiBusSpawnPositions = [










































































];

// Calculate schedule offsets for AI buses based on their ideal positions
const idealSpeedPerMs = IDEAL_SPEED / 1000;
const aiBusScheduleOffsetsMs = aiBusSpawnPositions.map(
  pos => -pos / idealSpeedPerMs
);

// Spawn AI buses with custom start positions and schedule offsets
aiBuses.length = 0;
scheduleOffsets.clear();

for (let i = 0; i < aiBusSpawnPositions.length; i++) {
  const startX = aiBusSpawnPositions[i];
  const offsetMs = aiBusScheduleOffsetsMs[i];

  const aiBus = createAIBus(startX);
  aiBus.maxSpeed = MAX_BUS_SPEED;
  aiBus.state = "follow";
  aiBus.bypassProgress = 0;
  aiBus.beepTimer = 0;
  aiBus.lingerTimer = 0;
  aiBus.vx = 0;
  aiBus.x = startX;
  aiBus.personality = null;

  aiBuses.push(aiBus);
  scheduleOffsets.set(aiBus, offsetMs);
}

// === Main AI Bus Update Loop ===
// New constants for smarter control

const MAX_LATE_SPEED_BOOST = 15;
const MAX_SPEED_BUFFER = 5;
const MAX_ACCELERATION = 3;
const STOP_WAIT_SEC = 5; // seconds
const EARLY_OFFSET_SEC = 10;
// Global variable to track which bus has the forced slow hold turn
// --- REQUIRED GLOBAL CONSTANTS ---
const MAX_ACCEL = 4;                // px/s per second
const MAX_BRAKE = 1.5;                // px/s per second
const MIN_FOLLOW_DIST = 400;          // px
const CRITICAL_STOP_DIST = 100;       // px
const STOP_WAIT_TIME = 8.0;           // seconds
const SCHEDULE_TOLERANCE_SEC = 2.0;   // seconds
const MIN_BUS_SPEED = 18.0;            // px/s
const BEEP_INTERVAL = 30;             // frames
const MIN_DISTANCE = 100;             // px (collision distance to player)
const GO_AROUND_SPEED = 18;           // px/s
const GO_AROUND_DISTANCE = 500;       // px
const STOP_DETECTION_RANGE = 20;      // px
let forcedEarlyStopTurn = 0;
// --- CRITICAL GLOBAL CONSTANTS ---
// IDEAL_SPEED must be defined elsewhere globally (px/second)
// =================================================================
// === CONFIGURATION CONSTANTS =====================================
// =================================================================
const IDEAL_BUS_SPEED = (typeof IDEAL_SPEED !== 'undefined' && isFinite(IDEAL_SPEED) && IDEAL_SPEED > 0) ? IDEAL_SPEED : 20;


// NOTE: these accelerations are px/sec^2 — increased so buses actually accelerate noticeably.
const ACCELERATION    = 200.0;   // px/s^2  (much snappier acceleration)
const DECELERATION    = 500.0;   // px/s^2  (strong braking)
const STOP_WAIT_TIME_SEC = 5.0;  // seconds dwell at stop
const STOP_SLOW_DISTANCE  = 400; // pixels start braking
const FALLBACK_DELTA_TIME = 0.033; // seconds (~30 FPS)

// --- Schedule / randomness
const SCHEDULE_P_FACTOR_CORRECTED = 0.015; // proportional gain for lateness
const MAX_SPEED_VARIATION = 0.20;         // random cruising speed diversity (slightly larger)
const TOLERANCE_SEC = 5;                  // "on time" band
const STOP_TOLERANCE = 5;                 // px accuracy for stopping

// global storage (define before running update loops)
// example: scheduleOffsets.set(bus, randomOffsetMs);

// =================================================================
// === HELPER FUNCTIONS ============================================
// =================================================================

/**
 * Ideal position minus actual position.
 * > 0  => late (behind schedule)
 * < 0  => early (ahead of schedule)
 */
function getLateness(bus, elapsedTime) {
    const offsetMs = scheduleOffsets.get(bus) ?? 0;
    const idealX   = IDEAL_BUS_SPEED * ((elapsedTime - offsetMs) / 1000);
    return idealX - (bus.x || 0);
}

/**
 * Find the closest AI buses behind and ahead of the player.
 */
function getNearestAIBuses(playerX) {
    let behind = null, ahead = null;
    let minBehindDist = Infinity, minAheadDist = Infinity;

    for (const bus of aiBuses) {
        const dx = bus.x - playerX;
        if (dx < 0 && Math.abs(dx) < minBehindDist) {
            behind = bus;
            minBehindDist = Math.abs(dx);
        } else if (dx > 0 && dx < minAheadDist) {
            ahead = bus;
            minAheadDist = dx;
        }
    }
    return { behind, ahead };
}

/**
 * Add natural randomness to make buses imperfect.
 * Small ± value is added to speed every frame.
 */
function randomSpeedJitter() {
    // jitter as a small fraction of ideal speed (± ~2.5% of IDEAL_BUS_SPEED)
    return (Math.random() - 0.5) * IDEAL_BUS_SPEED * 0.05;
}

// =================================================================
// === MAIN UPDATE LOOP ============================================
// =================================================================
function updateAIBuses(deltaTime, playerBus) {
    // Robust deltaTime handling:
    // - Accepts deltaTime in ms (typical) OR in seconds (some callers pass seconds).
    // - If deltaTime looks like seconds (< 0.5), treat as seconds directly.
    let safeDeltaTime;
    if (!isFinite(deltaTime) || deltaTime <= 0) {
        safeDeltaTime = FALLBACK_DELTA_TIME;
    } else {
        // if deltaTime < 0.5 assume seconds already; otherwise assume ms and convert
        safeDeltaTime = (deltaTime > 0 && deltaTime < 0.5) ? deltaTime : (deltaTime / 1000);
        // clamp small/large values
        safeDeltaTime = Math.max(1e-4, Math.min(0.2, safeDeltaTime));
    }

    const elapsedTime = isFinite(performance.now()) ? performance.now() : 0;

    for (let i = 0; i < aiBuses.length; i++) {
        const bus = aiBuses[i];
        let targetSpeed = IDEAL_BUS_SPEED;

        // ----- Initialization -----
        if (!bus.initialized) {
            // ensure numeric positions
            bus.x           = isFinite(bus.x) ? bus.x : 0;
            bus.vx          = isFinite(bus.vx) ? bus.vx : 0;
            bus.lingerTimer = bus.lingerTimer || 0;

            // a slightly larger persistent cruising variation + random seed for jitter
            const speedFactor = 1 + (Math.random() * MAX_SPEED_VARIATION * 2) - MAX_SPEED_VARIATION;
            bus.cruisingSpeed = IDEAL_BUS_SPEED * speedFactor;

            // give initial forward momentum so they actually move immediately
            bus.vx = Math.max(0, bus.cruisingSpeed * 0.6);

            bus.initialized   = true;
        }

        // ----- Service Dwell -----
        if (bus.lingerTimer > 0) {
            bus.vx = 0;
            bus.lingerTimer -= safeDeltaTime;
            if (bus.lingerTimer < 0) bus.lingerTimer = 0;
            continue;
        }

        // ----- Schedule Correction -----
        const latenessPx = getLateness(bus, elapsedTime);
        let scheduleCorrection = latenessPx * SCHEDULE_P_FACTOR_CORRECTED;
        const maxCorrection = IDEAL_BUS_SPEED * 0.5;
        scheduleCorrection = Math.max(-maxCorrection, Math.min(maxCorrection, scheduleCorrection));

        targetSpeed = bus.cruisingSpeed + scheduleCorrection + randomSpeedJitter();

        // ----- Stop Handling -----
        let nearestStopDist = Infinity;
        let stopFound = null;

        for (const stop of stops) {
            if (!stop.collected && isFinite(stop.x)) {
                const dist = stop.x - bus.x;
                if (dist > 0 && dist < nearestStopDist) {
                    nearestStopDist = dist;
                    stopFound = stop;
                }
            }
        }

        if (stopFound) {
            if (nearestStopDist < STOP_TOLERANCE) {
                if (latenessPx < 0) {
                    // Early arrival → hold briefly to allow schedule to catch up
                    // give a gentle early hold (not infinite)
                    bus.lingerTimer = Math.max(bus.lingerTimer, Math.min(STOP_WAIT_TIME_SEC, Math.abs(latenessPx) / Math.max(1, IDEAL_BUS_SPEED) ));
                    targetSpeed = 0;
                } else {
                    // On time / late → service dwell
                    stopFound.collected = true;
                    bus.lingerTimer = STOP_WAIT_TIME_SEC;
                    targetSpeed = 0;
                }
            } else if (nearestStopDist < STOP_SLOW_DISTANCE) {
                // braking: scale down strongly as we approach
                const brakingFactor = Math.max(0.05, nearestStopDist / STOP_SLOW_DISTANCE);
                const brakingTarget = IDEAL_BUS_SPEED * brakingFactor * 0.6; // somewhat conservative braking target
                targetSpeed = Math.min(targetSpeed, brakingTarget);
            }
        }

        // ----- Smooth Accel / Brake -----
        targetSpeed = Math.max(0, Math.min(MAX_BUS_SPEED, targetSpeed));
        const speedDiff = targetSpeed - bus.vx;
        const accel = speedDiff > 0
            ? Math.min(speedDiff, ACCELERATION * safeDeltaTime)
            : Math.max(speedDiff, -DECELERATION * safeDeltaTime);
        bus.vx += accel;

        // Hard safety cap
        bus.vx = Math.max(0, Math.min(MAX_BUS_SPEED, bus.vx));

        // ----- Position Update -----
        bus.x += bus.vx * safeDeltaTime;

        // Failsafe against NaN or runaway values
        if (!isFinite(bus.x) || !isFinite(bus.vx) || Math.abs(bus.x) > 1e9) {
            console.error(`Bus ${i} critical error → reset`);
            const offsetMs = scheduleOffsets.get(bus) ?? 0;
            const idealX   = IDEAL_BUS_SPEED * Math.max(0, (elapsedTime - offsetMs) / 1000);
            bus.x = idealX;
            bus.vx = Math.max(0, bus.cruisingSpeed || IDEAL_BUS_SPEED * 0.6);
            bus.lingerTimer = 0;
        }
    }
}
let velx = vx
// =================================================================
// === UI: Lateness Display ========================================
// =================================================================
function updateLatenessUI(playerBus) {
    const elapsedTime = performance.now();
    const playerLatenessPx = getLateness(playerBus, elapsedTime);
    const playerLatenessSec = playerLatenessPx / IDEAL_BUS_SPEED;

    const { behind, ahead } = getNearestAIBuses(playerBus.x);

    function latenessToSec(bus) {
        if (!bus) return null;
        return getLateness(bus, elapsedTime) / IDEAL_BUS_SPEED;
    }

    function status(seconds) {
        if (seconds === null) return "N/A";
        if (Math.abs(seconds) <= TOLERANCE_SEC) return "ON TIME";
        return seconds > 0 ? "Late" : "Early";
    }

    function format(seconds) {
        if (seconds === null) return "N/A";
        return `${Math.abs(seconds).toFixed(1)}s (${status(seconds)})`;
    }

    const lines = [
        `Player: ${format(playerLatenessSec)}`,
        `AI Behind: ${format(latenessToSec(behind))}`,
        `AI Ahead : ${format(latenessToSec(ahead))}`
    ];

    const elem = document.getElementById('lateness-info');
    if (elem) elem.textContent = lines.join('\n');
}


function updateStops(deltaTime) {
  const now = performance.now();
  for (let stop of stops) {
    if (stop.collected && now >= stop.regenTime) {
      stop.collected = false;
      stop.special = Math.random() < 0.2;
      // You can randomize isStation if desired, or keep it fixed
    }
  }
}

let spawnIndex = 0;
let spawning = false;
// Draw a single AI bus
function drawAIBuses(bus) {
  // Constants needed for road angle calculation
  const LOOKAHEAD_DISTANCE = 50; 
    const ctrlOffset = 30; 
  

  // --- ROAD ALIGNMENT CALCULATION ---
  // 1. Find the road Y position at the center of the bus
  const busCenterXWorld = bus.x + bus.width / 2;
  const roadYBusCenter = getRoadY(busCenterXWorld); 
  
  // 2. Find the road Y position slightly ahead to determine the slope (angle)
  const roadYAhead = getRoadY(busCenterXWorld + LOOKAHEAD_DISTANCE);
  
  // 3. Calculate the slope and angle
  const roadSlope = (roadYBusCenter - roadYAhead) / LOOKAHEAD_DISTANCE;
  const roadAngleRad = Math.atan(roadSlope);
  
  // 4. Determine the new top-Y coordinate so the bus bottom rests on the road surface
  const adjustedBusTopY = roadYBusCenter - bus.height;

  // The on-screen center point for the rotation transformation
  const rotationCenterX = bus.x - camX + bus.width / 2;
  const rotationCenterY = adjustedBusTopY + bus.height / 2;
  
  // Local drawing variables, now aligned to the road
  const leftX = bus.x - camX;
  const rightX = leftX + bus.width;
  const topY = adjustedBusTopY; 
  const bottomY = topY + bus.height;
  // ------------------------------------

  const typeIndex = bus.typeIndex;

  // Optional green path for type 1 or 2


  ctx.save();

  // --- ROTATION TRANSFORMATION: Tilt the bus to match the road angle ---
  ctx.translate(rotationCenterX, rotationCenterY);
  ctx.rotate(-roadAngleRad); // Rotate against the slope
  ctx.translate(-rotationCenterX, -rotationCenterY);

  // Bus gradient
  const x0 = bus.x - camX;
  const y0 = bottomY; // Use road-aligned bottom Y
  const x1 = bus.x - camX + bus.width;
  const y1 = topY; // Use road-aligned top Y

  const busGradient = ctx.createLinearGradient(x0, y0, x1, y1);
  busGradient.addColorStop(0, '#555');
  busGradient.addColorStop(1, '#222');

  // Type-specific shapes
  if (typeIndex === 2) {
    ctx.save();
    // Corrected Y translation from bus.y + 20 to topY + 20
    ctx.translate(0, topY + 20); 
    ctx.scale(1, -1);
    const startX = leftX;
    const startY = 10;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(startX, startY + 40);
    ctx.lineTo(startX + 370, startY + 40);
    ctx.quadraticCurveTo(startX + 420, startY + 40, startX + 420, startY);
    ctx.lineTo(startX + 300, startY);
    ctx.closePath();
    const curveGradient = ctx.createLinearGradient(x0, y0, x1, y1);
    curveGradient.addColorStop(0, '#555');
    curveGradient.addColorStop(1, '#222');
    ctx.fillStyle = curveGradient;
    ctx.fill();
    ctx.restore();
  }

  if (typeIndex === 1) {
    ctx.save();
    // Corrected Y translation from bus.y + 20 to topY + 20
    ctx.translate(0, topY + 20);
    ctx.scale(1, -1);
    const startX = leftX + 53;
    const startY = 20;
    ctx.beginPath();
    ctx.moveTo(startX - 50, startY);
    ctx.lineTo(startX - 50, startY + 42);
    const totalLen = 133;
    ctx.lineTo(startX + totalLen * 0.8 - 50, startY + 42);
    const curveEndX = startX + totalLen - 50;
    ctx.quadraticCurveTo(curveEndX + 30, startY + 52, curveEndX, startY + 52);
    ctx.lineTo(curveEndX, startY + 52);
    const dx = Math.cos(Math.PI * 75 / 180) * 31.5;
    const dy = Math.sin(Math.PI * 75 / 180) * 31.5;
    ctx.lineTo(startX + dx, startY + 59 + dy);
    ctx.lineTo(startX + 187, startY);
    ctx.closePath();
    ctx.fillStyle = 'rgba(211, 211, 211, 1)';
    ctx.fill();
    ctx.restore();
  }

  // Main body shape
  ctx.beginPath();
  ctx.moveTo(leftX, topY);
  ctx.lineTo(leftX, bottomY);
  ctx.lineTo(rightX - 5, bottomY);
  ctx.lineTo(rightX, bottomY - 10);
  ctx.lineTo(rightX, topY + bus.height * 0.59);
  ctx.bezierCurveTo(rightX, topY, rightX - ctrlOffset, topY, rightX - 65 - ctrlOffset, topY);
  ctx.lineTo(leftX, topY);
  ctx.closePath();
  ctx.fillStyle = busGradient;
  ctx.fill();

  // Doors
  ctx.save();
  const doorGradient = ctx.createLinearGradient(0, 0, 0, bus.doorSize.height);
  doorGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
  doorGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
  ctx.fillStyle = doorGradient;

  bus.doorPositions.forEach(doorX => {
    if (typeIndex === 2 && doorX === 430) return; // skip special case
    const x = bus.x - camX + doorX;
    const y = topY + 40; // Corrected Y reference
    ctx.fillRect(x, y, bus.doorSize.width, bus.doorSize.height);
  });
  ctx.restore();

  // Special door for type 2
  if (typeIndex === 2) {
    const doorX = bus.x - camX + 450;
    const y = topY + 40; // Corrected Y reference
    ctx.save();
    ctx.translate(0, y + bus.doorSize.height);
    ctx.scale(1, -1);
    ctx.beginPath();
    ctx.moveTo(doorX, 0);
    ctx.lineTo(doorX, bus.doorSize.height);
    ctx.lineTo(doorX + 10, bus.doorSize.height);
    ctx.quadraticCurveTo(doorX + 30, bus.doorSize.height, doorX + 30, bus.doorSize.height - 100);
    ctx.lineTo(doorX + 30, 0);
    ctx.closePath();
    ctx.fillStyle = doorGradient;
    ctx.fill();
    ctx.restore();
  }

  // Back doors
  if (bus.backDoorPositions) {
    bus.backDoorPositions.forEach(doorX => {
      const x = bus.x - camX + doorX;
      const y = topY + 40; // Corrected Y reference
      const doorW = bus.doorSize.width;
      const doorH = bus.doorSize.height;

      // Top half: black gradient
      const topHeight = doorH / 1.5;
      const topGradient = ctx.createLinearGradient(0, y, 0, y + topHeight);
      topGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
      topGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
      ctx.fillStyle = topGradient;
      ctx.fillRect(x, y, doorW, topHeight);

      // Bottom half: darker bus body
      const busGradient = ctx.createLinearGradient(
        bus.x - camX,
        bottomY, // Use road-aligned bottom Y
        bus.x - camX + bus.width,
        topY // Use road-aligned top Y
      );
      // NOTE: gradientStops variable is undefined in this snippet, using a default setup here.
      busGradient.addColorStop(0, '#555');
      busGradient.addColorStop(1, '#222');
      ctx.fillStyle = busGradient;
      ctx.fillRect(x, y + topHeight, doorW, doorH / 3);
    });
  }

  // Windows helper
  function drawWindow(win, baseTopY) { // Added baseTopY parameter
    ctx.save();
    const gradient = ctx.createLinearGradient(0, 0, 0, win.height);
    gradient.addColorStop(0, 'rgba(30, 30, 30, 1)');
    gradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
    ctx.fillStyle = gradient;
    // Use baseTopY instead of bus.y
    ctx.fillRect(bus.x - camX + win.x, baseTopY + win.y, win.width, win.height); 
    ctx.restore();
  }

  drawWindow(bus.window, topY); // Pass the road-aligned topY
  drawWindow(bus.window2, topY); // Pass the road-aligned topY

  // Wheels
  bus.wheelOffsets.forEach(offset => {
    ctx.save();
    const wheelX = bus.x - camX + offset;
    const wheelY = bottomY; // Corrected Y reference (wheels sit on the bottom)
    ctx.translate(wheelX, wheelY);
    ctx.rotate(bus.wheelAngle);

    const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
    wheelGradient.addColorStop(0, '#393939');
    wheelGradient.addColorStop(0.5, '#242424');
    wheelGradient.addColorStop(1, '#101010');

    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.fillStyle = wheelGradient;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fillStyle = '#999';
    ctx.fill();

    ctx.beginPath();
    ctx.arc(-8, -8, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fill();

    ctx.restore();
  });

  ctx.restore();
}
function drawParallaxLayers(ctx, camX, time = 0) {
  backgroundLayers.forEach(layer => {
    layer.objects.forEach(obj => {
      const screenX = obj.x - camX * layer.speed;
      if (screenX + obj.width < -500 || screenX > canvas.width + 500) return;

      const fogOpacity = 0.1 + layer.speed * 0.3;

      if (obj.type === 'cloud') {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(screenX, obj.y, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      if (obj.type === 'building') {
        if (obj.name) {
          drawNamedBuilding(ctx, obj, time);
        } else if (obj.bType === 'fullGlass') {
          const bg = brightBackdropColors[obj.variant % brightBackdropColors.length];
          ctx.fillStyle = bg;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);

          ctx.fillStyle = `rgba(255,255,255,0.5)`;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
        } else if (obj.bType === 'brand') {
          ctx.fillStyle = '#654321';
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
          ctx.fillStyle = '#00FFFF';
          ctx.fillRect(screenX, obj.y + obj.height / 2 - 10, obj.width, 20);
        } else {
          // Generic building gradient
          const grad = ctx.createLinearGradient(0, obj.y, 0, obj.y + obj.height);
          grad.addColorStop(0, '#222');
          grad.addColorStop(1, '#111');
          ctx.fillStyle = grad;
          ctx.fillRect(screenX, obj.y, obj.width, obj.height);
        }

        // Universal shadow overlay for depth
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(screenX + obj.width * 0.1, obj.y + obj.height * 0.1, obj.width * 0.8, obj.height * 0.8);

        // Optional building name for unnamed types - skipped here

        ctx.fillStyle = `rgba(255,255,255,${fogOpacity})`;
        ctx.fillRect(screenX, obj.y, obj.width, obj.height);
      }

      if (obj.type === 'tree') {
        ctx.fillStyle = '#5A3A1E';
        ctx.fillRect(screenX + obj.width / 2 - 24, 320, 40, 150);
        const foliageColor = obj.variant === 'special' ? '#66FFC4' : '#3FA';
        ctx.fillStyle = foliageColor;
        ctx.beginPath();
        ctx.arc(screenX + obj.width / 2, 330, obj.width * 0.90, 0, Math.PI * 2);
        ctx.fill();
      }

      if (obj.type === 'car') {
        ctx.fillStyle = '#222';
        ctx.fillRect(screenX, obj.y, obj.width, 20);
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(screenX + 10, obj.y + 20, 5, 0, Math.PI * 2);
        ctx.arc(screenX + obj.width - 10, obj.y + 20, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  });
}
let isLeftSignalOn, isHazardOn, isRightSignalOn, isFlashing = false
   const LEFT_SIGNAL_CENTER = { x: 0, y: 0 };
    const HAZARD_CENTER = { x: 0, y: 0 };
    const RIGHT_SIGNAL_CENTER = { x: 0, y: 0 };

// Generate objects remains mostly the same, with named buildings assigned
function generateParallaxObjects() {
  const groundY = canvas.height - 160;

  backgroundLayers.forEach(layer => {
    layer.objects = [];

    for (let i = 0; i < 100; i++) {
      const x = i * 600 + Math.random() * 200;
      let y = 0, width = 0, height = 0, variant = 0, name = '', type = 'normal';

      if (layer.type === 'building') {
        variant = i;
        width = 100 + Math.random() * 300;
        height = 180 + Math.random() * 320;
        y = getRoadY(x) - height - 20; // Position buildings relative to road

        if (Math.random() < 0.15) {  // Reduced chance for named buildings
          name = namedBuildings[Math.floor(Math.random() * namedBuildings.length)];
        }
        if (Math.random() < 0.2) type = 'fullGlass';
        if (Math.random() < 0.1) type = 'brand';

        layer.objects.push({ x, y, width, height, type: layer.type, variant, bType: type, name });
        continue;
      }

      if (layer.type === 'tree') {
        variant = i % 20 === 0 ? 'special' : Math.floor(Math.random() * 6);
        width = 100 + Math.random() * 30;
        height = 180 + Math.random() * 40;
        y = getRoadY(x) - height; // Position trees on the road level
      }

      if (layer.type === 'car') {
        width = 70 + Math.random() * 40;
        height = 25;
        y = getRoadY(x) - height;
      }

      if (layer.type === 'cloud') {
        
        width = 120 + Math.random() * 100;
        height = 50;
        y = Math.random() * 200 + 40;
      }

      layer.objects.push({ x, y, width, height, type: layer.type, variant });
    }
  });
}
const busPath = [];

generateParallaxObjects();
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'n') {
    night = !night;
  }
});
function drawAICars(ctx) {
  const scale = 1; // scale up the wheels & car body for proportion
    for (const car of aiCars) {
  const baseX = car.x
  const baseY = car.y + 150;

  // --- Draw car body ---
  ctx.save();
  ctx.translate(baseX, baseY);

  // Body outline path inspired by Tesla Model S shape simplified
  ctx.beginPath();

  // Start bottom front curve
  ctx.moveTo(-60 * scale, 0);
  ctx.quadraticCurveTo(-50 * scale, -20 * scale, -30 * scale, -30 * scale); // front curve
  ctx.lineTo(20 * scale, -30 * scale); // flat front bottom to cabin base
  ctx.lineTo(30 * scale, -70 * scale); // rise up to cabin roof start
  ctx.quadraticCurveTo(40 * scale, -90 * scale, 60 * scale, -70 * scale); // cabin roof curve
  ctx.lineTo(80 * scale, -70 * scale); // roof flat top
  ctx.quadraticCurveTo(90 * scale, -70 * scale, 90 * scale, -60 * scale); // roof to rear curve start
  ctx.lineTo(90 * scale, -10 * scale); // down rear
  ctx.quadraticCurveTo(80 * scale, 0, 60 * scale, 0); // rear curve
  ctx.closePath();

  // Fill car body
  const bodyGradient = ctx.createLinearGradient(0, -70 * scale, 0, 0);
  bodyGradient.addColorStop(0, '#0072CE'); // Tesla blue-ish
  bodyGradient.addColorStop(1, '#004A8F'); // Darker shade
  ctx.fillStyle = bodyGradient;
  ctx.fill();

  // --- Draw cabin windows ---
  ctx.beginPath();
  ctx.moveTo(30 * scale, -70 * scale);
  ctx.quadraticCurveTo(40 * scale, -80 * scale, 60 * scale, -70 * scale);
  ctx.lineTo(50 * scale, -40 * scale);
  ctx.lineTo(30 * scale, -40 * scale);
  ctx.closePath();

  ctx.fillStyle = 'rgba(200, 230, 255, 0.7)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(180, 210, 235, 0.9)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // --- Draw wheels ---
  const wheelRadius = 30 * scale;
  const wheelOffsets = [-50 * scale, 70 * scale]; // front and rear wheels x offset relative to car center
  const wheelY = 0;

  wheelOffsets.forEach(offsetX => {
    ctx.save();
    ctx.translate(offsetX, wheelY);

    // Draw wheel outer circle gradient
    const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, wheelRadius);
    wheelGradient.addColorStop(0, '#393939');
    wheelGradient.addColorStop(0.5, '#242424');
    wheelGradient.addColorStop(1, '#101010');
    ctx.beginPath();
    ctx.arc(0, 0, wheelRadius, 0, Math.PI * 2);
    ctx.fillStyle = wheelGradient;
    ctx.fill();

    // Inner wheel circle
    ctx.beginPath();
    ctx.arc(0, 0, wheelRadius * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = '#999';
    ctx.fill();

    // Highlight circle
    ctx.beginPath();
    ctx.arc(-wheelRadius * 0.27, -wheelRadius * 0.27, wheelRadius * 0.2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fill();

    ctx.restore();
  });

  ctx.restore();
}
}


// Toggle spotlight on/off when pressing 'S'
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 's') {
    if (night) {
    spotlightOn = !spotlightOn;
  }}
});
let canSwitchLane = true;

// =====================================================================
// !! PLACE THIS CODE OUTSIDE THE drawBus FUNCTION !!
// =====================================================================
const BUS_HEIGHT_OFFSET = 180; // Distance from bus top to the road surface
const LOOKAHEAD_DISTANCE = 50; // Distance to sample road for slope calculation (in px)

// A simple pseudorandom number generator for deterministic terrain based on x.
function seededRandom(seed) {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

// This function calculates the screen Y coordinate of the road surface at a world X coordinate.
function getRoadY(x) {
    // Assuming 'canvas', 'bridges', and 'canvasHeight' are globally accessible
    const canvas = document.getElementById('busCanvas');
    const BASE_ROAD_Y = canvas.height - 100; // Y for the flat road base
    
    let totalOffset = 0;

    // --- 1. Gentle, Long-Wavelength Curves (Primary Terrain Shape) ---
    // These waves create the main, smooth rolling hills.
    
    // Component A: Very long, very shallow wave for a subtle overall rise/fall (Max Amplitude 30)
    const curveOffsetA = Math.sin(x * 0.0002) * 30; 
    
    // Component B: Medium-length, smooth curve (Max Amplitude 45)
    const curveOffsetB = Math.sin(x * 0.0006 + 2) * 45; 
    
    // Component C: A slight, choppy wave for just a bit of texture (Max Amplitude 10)
    const curveOffsetC = Math.sin(x * 0.003) * 10;
    
    let combinedHills = curveOffsetA + curveOffsetB + curveOffsetC;

    // --- Enforce Flatter/Above Surface Bias ---
    // This shifts the lowest point of the combined wave upward, 
    // ensuring the road rarely dips significantly below the BASE_ROAD_Y.
    combinedHills += 10; // Guarantees a slight elevation bias.
    
    totalOffset += combinedHills;

    // --- 2. Smoothed Random Noise (Controlled Randomness) ---
    // Adds small, non-repeating variations, but keeps it very smooth.
    const segmentSize = 800; // Large segments for smooth transitions
    const maxRandomElevation = 15; // Low max elevation for gentle bumps
    
    const segmentIndex = Math.floor(x / segmentSize);
    const localX = x % segmentSize;
    const nextSegmentIndex = segmentIndex + 1;

    const randomElevation = (seededRandom(segmentIndex * 123.45) * 2 - 1) * maxRandomElevation;
    const nextElevation = (seededRandom(nextSegmentIndex * 123.45) * 2 - 1) * maxRandomElevation;
    
    // Cosine interpolation for extremely smooth transition
    const alpha = (1 - Math.cos(Math.PI * (localX / segmentSize))) / 2; 
    
    const interpolatedElevation = randomElevation * (1 - alpha) + nextElevation * alpha;

    totalOffset += interpolatedElevation * 0.15; // Apply only 15% of the noise strength

    // --- 3. Bridge Elevation (High Priority) ---
    // Retains the bridge structure, overriding the smooth terrain below.
    let bridgeOffset = 0;
    for (const bridge of bridges) {
        const liftSpan = 2000; 
        const maxLift = 100; 
        if (x >= bridge.x - liftSpan / 2 && x <= bridge.x + liftSpan / 2) {
            const relativeX = x - bridge.x;
            const normalizedX = relativeX / (liftSpan / 2); 
            const parabolicLift = maxLift * (1 - normalizedX * normalizedX);
            bridgeOffset = -parabolicLift; 
            
            // If we are on a bridge, the bridge dictates the height completely.
            return BASE_ROAD_Y + bridgeOffset; 
        }
    }
    
    // Final road height is the base Y plus the terrain offset.
    return BASE_ROAD_Y + totalOffset;
}
window.onkeydown = (e) => {
    // Prevents the function from running multiple times if a key is held down
    if (e.repeat) return; 
    
    const key = e.key.toUpperCase();

    if (key === 'Y') { // Left Signal
        // If hazards are on, turn them off and start the left signal
        if (isHazardOn) {
            isHazardOn = false;
            isLeftSignalOn = true;
            isRightSignalOn = false;
        } else if (isLeftSignalOn) {
            // If already on, turn off
            isLeftSignalOn = false;
        } else {
            // Turn on left signal and ensure right is off
            isLeftSignalOn = true;
            isRightSignalOn = false;
        }
    } else if (key === 'R') { // Right Signal
        // If hazards are on, turn them off and start the right signal
        if (isHazardOn) {
            isHazardOn = false;
            isRightSignalOn = true;
            isLeftSignalOn = false;
        } else if (isRightSignalOn) {
            // If already on, turn off
            isRightSignalOn = false;
        } else {
            // Turn on right signal and ensure left is off
            isRightSignalOn = true;
            isLeftSignalOn = false;
        }
    } else if (key === 'T') { // Hazard
        // Toggle hazard state
        isHazardOn = !isHazardOn;
        // Hazards take priority: if hazards are turned on, turn off both signals
        if (isHazardOn) {
            isLeftSignalOn = false;
            isRightSignalOn = false;
        }
    }
};
// =====================================================================
function drawBus() {
  const skygradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
  if (night) {
    skygradient.addColorStop(0, '#0b0c17');  
    skygradient.addColorStop(1, '#000000');  
  } else {
    skygradient.addColorStop(0, '#87ceeb');  
    skygradient.addColorStop(1, '#b0e0e6');  
  }


  const baseBus = buses[currentBusIndex];
  const bus = { ...baseBus };
  
  // =======================================================
  // ** DYNAMIC HILL/BRIDGE Y-LOGIC **
  // =======================================================
  
  const roadYCenter = getRoadY(camX); 
  const roadYAhead = getRoadY(camX + LOOKAHEAD_DISTANCE);
  
  const roadSlope = (roadYCenter - roadYAhead) / LOOKAHEAD_DISTANCE;
  const roadAngleRad = Math.atan(roadSlope);
  
  let playerBusTopY = roadYCenter - BUS_HEIGHT_OFFSET;
  
  if (vx === 0) {
    playerBusTopY += isLowered ? LOWER_OFFSET : 0;
  }
  
  bus.y = playerBusTopY; 
  
  // =======================================================
  
  
  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "w" && blockedByCar && canSwitchLane) {
      bus.y += 10;
      canSwitchLane = false;
      setTimeout(() => (canSwitchLane = true), 300); 
    }
  });

  ctx.clearRect(0, 0, canvas.width, canvas.height);

ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
ctx.shadowBlur = 12;

  // Sky
  ctx.fillStyle = skygradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Parallax Background
  drawParallaxLayers(ctx, camX);

// 1., 2., 3. Fixed road drawing removed here.

// =================================================================
// ** NEW: DRAW DYNAMIC CURVED ROAD SURFACE AND SIDEWALK **
// =================================================================
const roadDrawingStep = 10;
const roadDrawingWidth = canvas.width + 200;
// Calculate the world coordinates visible on screen plus a buffer
const roadStartWorld = camX - canvas.width / 2;
const roadEndWorld = camX + canvas.width / 2 + roadDrawingWidth; 
const roadBottomY = canvas.height; // Road fills down to the canvas bottom

// --- 3. Draw Road Bed (The main black surface) ---
ctx.fillStyle = '#333';
ctx.beginPath();
ctx.moveTo(0, roadBottomY); // Start at bottom-left of screen

// Trace the top of the road curve (road surface Y)
for (let x = roadStartWorld; x < roadEndWorld; x += roadDrawingStep) {
    const screenX = x - camX + canvas.width / 2;
    const roadSurfaceY = getRoadY(x); // This is the curved top line
    ctx.lineTo(screenX, roadSurfaceY - 80);
}

ctx.lineTo(canvas.width, roadBottomY); // Move to bottom-right of screen
ctx.closePath();
ctx.fill();

// --- 1. Draw Sidewalk (On top of the road surface curve, opposite side) ---
const sidewalkHeight = 10;
const sidewalkColor = '#bbb';
const sidewalkOffsetFromRoad = 45; 

ctx.fillStyle = sidewalkColor;
ctx.beginPath();

// Trace the top of the sidewalk (40px above the road surface curve)
for (let x = roadStartWorld; x < roadEndWorld; x += roadDrawingStep) {
    const screenX = x - camX + canvas.width / 2;
    const sidewalkTopY = getRoadY(x) - sidewalkOffsetFromRoad - sidewalkHeight; 
    
    if (x === roadStartWorld) {
        ctx.moveTo(screenX, sidewalkTopY - 30);
    } else {
        ctx.lineTo(screenX, sidewalkTopY - 30);
    }
}

// Now trace the bottom of the sidewalk (along the road curve)
for (let x = roadEndWorld - roadDrawingStep; x >= roadStartWorld; x -= roadDrawingStep) {
    const screenX = x - camX + canvas.width / 2;
    const sidewalkBottomY = getRoadY(x) - sidewalkOffsetFromRoad; 
    ctx.lineTo(screenX, sidewalkBottomY);
}

ctx.closePath();
ctx.fill();
// =================================================================


// =================================================================
// ** DRAW DYNAMIC ROAD CURVE (Center Line) **
// =================================================================
ctx.strokeStyle = '#FFD700'; // Gold color
ctx.lineWidth = 4;
ctx.beginPath();
const roadLineWidth = canvas.width + 200; 
const roadStep = 10; 
const roadCenterLineOffset = 15; // Still offsets the yellow line slightly from the very top surface

for (let x = camX - canvas.width / 2; x < camX + canvas.width / 2 + roadLineWidth; x += roadStep) {
    const screenX = x - camX + canvas.width / 2;
    const roadSurfaceY = getRoadY(x) - roadCenterLineOffset; 
    
    if (x === camX - canvas.width / 2) {
        ctx.moveTo(screenX, roadSurfaceY);
    } else {
        ctx.lineTo(screenX, roadSurfaceY);
    }
}
ctx.stroke();
// =================================================================

// Parameters for highway curve
const highway = {
  baseY: canvas.height - 600,  // vertical position of highway deck
  width: 300,                  // bridge width
  deckHeight: 50,
  baseColor: '#008B8B',        // dark cyan base under road
  deckColor: '#D6BDA3',        // lighter brown deck top
  pillarWidth: 20,
  pillarHeight: 150,
  pillarSpacing: 120,          // distance between pillars along highway
  curveAmplitude: 100,         // horizontal curve amplitude
  curveFrequency: 0.0025,      // curve frequency
  zLayers: 3                   // number of layered decks
};

// Draw highway function, called after drawing bus to overlay it
function drawCurvingHighway(ctx, busX, time) {
  // We'll draw 3 decks stacked with vertical offsets
  for (let layer = 0; layer < highway.zLayers; layer++) {
    const verticalOffset = layer * (highway.deckHeight + 20); // space between decks

    // Draw bridge deck (top)
    // Curve horizontally using sine wave for smooth left-right
    const curveX = x => x + Math.sin(x * highway.curveFrequency + time * 0.002 + layer) * highway.curveAmplitude;

    // Draw highway segments spaced horizontally, centered on bus
    // We draw a range around busX so highway covers canvas width + margin
    const startX = busX - canvas.width / 2 - 500;
    const endX = busX + canvas.width / 2 + 500;

    // Draw base and deck in segments for smooth curve
    for (let x = startX; x < endX; x += highway.width) {
      const cx = curveX(x);

      // Base under road (dark cyan)
      ctx.fillStyle = highway.baseColor;
      ctx.fillRect(cx - highway.width / 2, highway.baseY - verticalOffset, highway.width, 30);

      // Deck (lighter brown)
      ctx.fillStyle = highway.deckColor;
      ctx.fillRect(cx - highway.width / 2 - 10, highway.baseY - verticalOffset - highway.deckHeight, highway.width + 20, highway.deckHeight);

      // Draw pillars under deck
      const pillarCount = Math.floor(highway.width / highway.pillarSpacing) + 1;
      ctx.fillStyle = '#654321'; // dark brown pillars
      for (let p = 0; p < pillarCount; p++) {
        const pillarX = cx - highway.width / 2 + p * highway.pillarSpacing;
        ctx.fillRect(pillarX, highway.baseY - verticalOffset + 30, highway.pillarWidth, highway.pillarHeight);
      }
    }
  }
}

  // Draw signal signs
  drawSignalSigns(ctx, camX, canvas.width);
// Draw bridge columns and bridge structure
for (const bridge of bridges) {
  const screenX = bridge.x - bus.x + canvas.width / 2;

  // Wide dark cyan base under the road
  ctx.fillStyle = '#008B8B'; // dark cyan
  ctx.fillRect(screenX - 160, canvas.height - 585, 300, 30);

  // Layered 2D "z-style" deck (brown, sits on top)
  ctx.fillStyle = '#D6BDA3'; // lighter brown bridge top
  ctx.fillRect(screenX - 170, canvas.height - 625, 320, 50);

  // Wide dark cyan base under the road
  ctx.fillStyle = '#008B8B'; // dark cyan
  ctx.fillRect(screenX + 190, canvas.height - 585, 300, 30);

  // Layered 2D "z-style" deck (brown, sits on top)
  ctx.fillStyle = '#D6BDA3'; // lighter brown bridge top
  ctx.fillRect(screenX + 180, canvas.height - 625, 320, 50);

}

// =======================================================
// ** START: MAIN BUS ROTATION BLOCK **
// This applies the tilt to the entire bus, body, and all features.
// =======================================================
ctx.save();

// Calculate the center point for rotation
const busCenterX = bus.x - camX + bus.width / 2;
const busCenterY = bus.y + bus.height / 2;

// Apply rotation
ctx.translate(busCenterX, busCenterY);
ctx.rotate(-roadAngleRad); // Use the calculated road angle for tilt
ctx.translate(-busCenterX, -busCenterY);

// --- Gradient for Bus Body ---
const busGradient = ctx.createLinearGradient(
  bus.x - camX,
  bus.y + bus.height,
  bus.x - camX + bus.width,
  bus.y
);
for (const stop of gradientStops) {
    busGradient.addColorStop(stop.offset, stop.color);
}


// --- 1. Bus Type 2 Specific Piece (Inverted Draw) ---
if (currentBusIndex === 2) {
  ctx.save();
  const flipY = bus.y + 20;
  ctx.translate(0, flipY);
  ctx.scale(1, -1);

  const startX = bus.x - camX + bus.width - 470;
  const startY = 10;

  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(startX, startY + 40);
  ctx.lineTo(startX + 370, startY + 40);
  ctx.quadraticCurveTo(startX + 420, startY + 40, startX + 420, startY);
  ctx.lineTo(startX + 300, startY);
  ctx.lineTo(startX, startY);
  ctx.closePath();

  const useGradient = true; 
  if (useGradient) {
    const curveGradient = ctx.createLinearGradient(
      bus.x - camX,
      bus.y + bus.height,
      bus.x - camX + bus.width,
      bus.y
    );
    for (const stop of gradientStops) {
      curveGradient.addColorStop(stop.offset, stop.color);
    }
    ctx.fillStyle = curveGradient;
  } else {
    ctx.fillStyle = '#444';
  }

  ctx.fill();
  ctx.restore();
}

// --- 2. Bus Type 1 Large Light Gray Flipped Piece (RESTORED) ---
if (currentBusIndex === 1) {
    ctx.save();
    
    // Apply local flip transform. Coordinates must be relative to the rotated canvas space.
    const flipY = bus.y + 20;
    ctx.translate(0, flipY);
    ctx.scale(1, -1); // Flip vertically

    // Use absolute screen coordinates for drawing the flipped shape
    const startX = bus.x - camX + bus.width - 417; 
    const startY = 20;

    ctx.beginPath();
    
    // Vertical line down (originally 60 px tall, now 42 px)
    ctx.moveTo(startX - 50, startY);
    ctx.lineTo(startX - 50, startY + 42);

    // Adjusted horizontal line length and curve details
    const totalHorizontalLength = 102.4 * 1.3; 
    const lineStartX = startX - 50;
    const lineY = startY + 42;

    // Part 1: straight horizontal line
    const part1Length = totalHorizontalLength * 0.4; 
    ctx.lineTo(lineStartX + part1Length, lineY);

    // Part 2: curve down 10px with quadratic curve
    const part2Length = totalHorizontalLength * 0.2;
    const curveControlX = lineStartX + part1Length + part2Length/2; 
    const curveControlY = lineY + 10;
    const curveEndX = lineStartX + part1Length + part2Length;
    const curveEndY = lineY + 10;
    
    ctx.quadraticCurveTo(curveControlX, curveControlY, curveEndX, curveEndY);

    // Part 3: straight horizontal line
    ctx.lineTo(lineStartX + totalHorizontalLength, lineY + 10);

    // Diagonal line \ 
    const angleDeg = 75;
    const angleRad = angleDeg * Math.PI / 180;
    const length = 30 * 1.5 * (42 / 60); 

    const dx = Math.cos(angleRad) * length;
    const dy = Math.sin(angleRad) * length;

    ctx.lineTo(startX + dx, startY + 59 + dy); 

    // Close shape top, scale closing length horizontally
    ctx.lineTo(startX + 170 * 1.1, startY); 
    ctx.lineTo(startX, startY);

    ctx.closePath();

    ctx.fillStyle = 'rgba(211, 211, 211, 1)'; // Light Gray
    ctx.fill();

    ctx.restore(); // Restore local flip transform
}

// --- 3. Bus Type 1 Small Dark Flipped Piece ---
if (currentBusIndex === 1) {
    ctx.save();
    
    // Apply local flip transform.
    const anchorX = bus.x - camX + bus.width - 35;
    const anchorY = bus.y + 20; 
    
    ctx.translate(anchorX, anchorY);
    ctx.scale(1, -1); 

    const startY = -120; 
    
    ctx.beginPath();
    ctx.moveTo(0, startY);
    ctx.lineTo(0, startY + 100);
    ctx.lineTo(0, startY + 100); 
    
    ctx.quadraticCurveTo(
      30, 
      startY + 100,  
      30, 
      startY + 0    
    );
    
    ctx.lineTo(10, startY);
    ctx.lineTo(0, startY);
    ctx.closePath();
    
    ctx.fillStyle = 'rgba(30, 30, 30, 1)'; 
    ctx.fill();

    ctx.restore(); 
}


// --- 4. Bus Body (Main Shape - includes studle) ---
const leftX = bus.x - camX;
const rightX = leftX + bus.width;
const topY = bus.y;
const bottomY = bus.y + bus.height;
const curveStartY = topY + bus.height * 0.0;
const curveEndY = topY + bus.height * 0.59;
const ctrlOffset = 30;

// Length of the bottom-right diagonal (studle)
const studleHeight = 10;
const studleAngleX = 45; 

ctx.beginPath();
ctx.moveTo(leftX, topY);
ctx.lineTo(leftX, bottomY);

// Draw bottom edge to before studle
ctx.lineTo(rightX - studleAngleX + 40, bottomY);

// Add upward diagonal studle
ctx.lineTo(rightX, bottomY - studleHeight);

// Draw up-right curve
ctx.lineTo(rightX, curveEndY);
ctx.bezierCurveTo(
  rightX, curveStartY,
  rightX - ctrlOffset, topY,
  rightX - 65 - ctrlOffset, topY
);

// Flat roof back to front
ctx.lineTo(leftX, topY);
ctx.closePath();

ctx.fillStyle = busGradient;
ctx.fill();


ctx.save();
let doorWellX, doorWellWidth;
const doorWellY = bus.y + 40;
const doorWellHeight = bus.doorSize.height;
if (currentBusIndex !== 2) {
    // Standard Bus (Bus 0, 1) - Based on the first door position, covering two panels and a small gap.
    const frontDoorStart = buses[currentBusIndex].doorPositions[0] - 0;
    doorWellX = bus.x - camX + frontDoorStart;
    // Assuming the front door opening is roughly two standard door panels wide
    doorWellWidth = (bus.doorSize.width * 2) - 5; 

} else {
    // Bus 2 (Curved Door) - Based on the location of the curved door mechanism (starting near 430).
    // Covering the left panel (width 20) + curved area.
    const curvedDoorStart = 405;
    doorWellX = bus.x - camX + curvedDoorStart;
    doorWellWidth = bus.doorSize.width + 10;
}

// Draw the solid black box behind where the doors open
ctx.fillStyle = "#000000"; // Black color for the interior
ctx.fillRect(doorWellX, doorWellY, doorWellWidth, doorWellHeight);

const doorGradient = ctx.createLinearGradient(0, 0, 0, bus.doorSize.height);
doorGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
doorGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
ctx.fillStyle = doorGradient;

const doorOffset = frontOpen; // Animation value from the update loop (0 to 100)

// Standard dimensions
const doorTotalW = bus.doorSize.width;
const doorH = bus.doorSize.height;
const y = bus.y + 40;
const halfDoorW = doorTotalW;

// The X position of the front door system's left edge (first item in doorPositions)
// This is used as the common reference point for the door system.
const frontDoorSystemX = buses[currentBusIndex].doorPositions[0];

// Panel calculations for shrinking
const openingWidth = doorOffset; // The width of the gap to be revealed (frontOpen)
let currentPanelW = Math.max(0, halfDoorW - openingWidth / 2); // Shrinking width of each panel
if (frontOpen) {
    currentPanelW = 10
}
let more = 0
if (frontOpen) {more = 30}
// === Standard Bus Doors (Bus 0, 1, etc.) - Two Rectangular Panels ===
if (currentBusIndex !== 2) {
    
    // Only handle the front door system
    buses[currentBusIndex].doorPositions.forEach((doorX, index) => {
        if (index > 0) return; // Skip back doors for now (assuming index 0 is the front door system)

        // --- 1. Left Panel (Rectangular) - Shrinks from the right ---
        let x_left = bus.x - camX + doorX;
        ctx.fillRect(x_left, y, currentPanelW, doorH);

        // --- 2. Right Panel (Rectangular) - Shifts right and shrinks from the left ---
        // New X starts after the left panel's original half width plus the gap (openingWidth / 2)
        let x_right = bus.x - camX + doorX + halfDoorW + more;
        ctx.fillRect(x_right, y, currentPanelW, doorH);
    });

} else {
    // === Bus 2 Special Door - Rectangular Left + Curved Right ===
    
    // --- 1. Left Panel (Rectangular) - Always the same width/shrink as the standard left panel ---
    let x_left = bus.x - camX + frontDoorSystemX;
    ctx.fillRect(x_left, y, currentPanelW, doorH);
    
    // --- 2. Right Panel (Curved) ---
    
    // Calculate the start X for the curved door (Right edge of the gap)
    // This position is the frontDoorSystemX + (Left Half Door W) + (Gap Width)
    const curved_x_start = bus.x - camX + frontDoorSystemX + halfDoorW + more + 20
    
    // Calculate how much the right panel has shrunk from its original width
    const panelShrinkAmount = (halfDoorW - currentPanelW); 

    // The curved door's shape starts at original doorX + 20 (relative to the bus)
    const doorX_original_pos = 430; 
    
    // This calculates the starting X for the drawing logic, now based on the calculated gap position
    const x = curved_x_start + 20 - halfDoorW; // Corrected starting point based on geometry
    
    ctx.save();
    ctx.translate(0, y + doorH);
    ctx.scale(1, -1); 
    ctx.fillStyle = doorGradient; 
    
    ctx.beginPath();
    ctx.moveTo(x, 0); // Start position after the gap
    ctx.lineTo(x, doorH);
    
    // The end X point needs to move left by the total amount the panel has shrunk (panelShrinkAmount)
    const doorW_bus2 = bus.doorSize.width - 20; // Original width of the Bus 2 shape before shrinkage
    const endX = x + doorW_bus2 - panelShrinkAmount; 
    
    ctx.lineTo(endX - 10, doorH); 
    ctx.quadraticCurveTo(
        endX, doorH,
        endX, doorH - 100
    );
    ctx.lineTo(endX, 0);
    ctx.closePath();

    ctx.fill();
    ctx.restore();
}

ctx.restore();

drawBackDoors(bus);


// --- 6. Windows ---
function drawWindow(window) {
  ctx.save();
  const gradient = ctx.createLinearGradient(0, 0, 0, window.height);
  gradient.addColorStop(0, 'rgba(30, 30, 30, 1)');
  gradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
  ctx.fillStyle = gradient;
  ctx.fillRect(bus.x - camX + window.x, bus.y + window.y, window.width, window.height);
  ctx.restore();
}
drawWindow(bus.window);
drawWindow(bus.window2);


// --- 7. Wheels ---
bus.wheelOffsets.forEach(offset => {
  ctx.save();
  const wheelX = bus.x - camX + offset;
  let wheelY = bus.y + bus.height; 

  if (driverLocked) {
    wheelY = wheelY - 10
  }
  
  // The hill rotation is already active. Only apply wheel spin here.
  ctx.translate(wheelX, wheelY);
  ctx.rotate(bus.wheelAngle); // Wheel spin animation

  const wheelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
  wheelGradient.addColorStop(0, '#393939');
  wheelGradient.addColorStop(0.5, '#242424');
  wheelGradient.addColorStop(1, '#101010');

  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI * 2);
  ctx.fillStyle = wheelGradient;
  ctx.fill();

  ctx.beginPath();
  ctx.arc(0, 0, 18, 0, Math.PI * 2);
  ctx.fillStyle = '#999';
  ctx.fill();

  ctx.save();
  ctx.translate(-8, -8);
  ctx.beginPath();
  ctx.arc(0, 0, 6, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.fill();
  ctx.restore();

  ctx.restore();

});
// ** END OF MAIN BUS ROTATION BLOCK **
ctx.restore(); 


// --- Fuel Pickups --- (Drawn outside rotation as they are world objects)
fuelPickups.forEach(pickup => {
  if (!pickup.collected) {
    ctx.fillStyle = 'orange';
    ctx.fillRect(pickup.x - bus.x + canvas.width / 2 - 10, 400, 20, 20); 
  }
});


aiBuses.forEach(aiBus => drawAIBuses(aiBus, aiBus.typeIndex));
// ... (rest of the non-bus drawing logic, UI, and debug info) ...

window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'v' && !spawning) {
    spawnIndex = 0;
    spawning = true;

    const interval = setInterval(() => {
      spawnAICar(spawnIndex * 600 + bus.x + 1000, bus.y);
      spawnIndex++;

      if (spawnIndex >= 10) {
        clearInterval(interval);
        spawning = false;
      }
    }, 300); // Adjust delay between spawns (milliseconds)
  }
});


for (const stop of stops) {
  if (stop.isStation && stop.x > bus.x - 2000) {
    drawTransitStation(ctx, stop.x, camX);
  }
}
for (const bridge of bridges) {
  const screenX = bridge.x - bus.x + canvas.width / 2;
  
  // Bridge columns and top rectangle
  ctx.fillStyle = '#CAB298'; // dark brown column
  ctx.fillRect(screenX - 55, 100, 100, 450);

  ctx.fillStyle = '#CAB298'; // dark brown column
  ctx.fillRect(screenX + 295, 100, 100, 450);

  ctx.fillStyle = '#CAB298'; // dark brown top rectangle
  ctx.fillRect(screenX - 125, 40, 590, 100);
}
// --- DRAW INDICATOR HELPER FUNCTION ---
// NOTE: This must be defined globally or before the main drawing logic.
function drawSquareIndicator(x, y, config, isFlashing) {
    const isActive = config.active;
    // Check if the light is one of the interactive signals (which must blink)
    const isInteractive = !!config.type; 
    
    // Light is ON if it's active AND (it's not interactive OR the global flasher is currently ON)
    const isLit = isActive && (isInteractive ? isFlashing : true);
    
    ctx.save();
    
    if (isLit) {
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowColor = config.glowColor;
        ctx.shadowBlur = 15;
        ctx.fillStyle = config.baseColor;
    } else {
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#404040'; // Darker gray when off
    }

    ctx.fillRect(x, y, LIGHT_SIZE, LIGHT_SIZE);
    ctx.restore();
}

// --- Dashboard Geometry Constants (Half-Circle) ---
const DASH_CENTER_X = canvas.width / 2;
const DASH_CENTER_Y = 650; 
const DASH_RADIUS = 180; 

const LIGHT_SIZE = 12; 
const LIGHT_PADDING = 8; 

// --- Dashboard Background (Half-Circle) ---
ctx.save();
ctx.beginPath();
ctx.arc(DASH_CENTER_X, DASH_CENTER_Y, DASH_RADIUS, Math.PI, 2 * Math.PI, false);
ctx.closePath();
ctx.fillStyle = '#1e1e1e'; 
ctx.fill();
ctx.restore();

// --- LIGHT CONFIGURATION ---
// These rely on global variables: vx, distance, braking, pendingDropRequest
  // VELOCITY METER CONSTANTS (Defined locally for clarity)
  const METER_RADIUS = DASH_RADIUS - 30; 
  const MAX_VELOCITY = 50; // Max speed for the gauge 
  const MIN_ANGLE = Math.PI + (Math.PI / 8); 
  const MAX_ANGLE = 2 * Math.PI - (Math.PI / 8); 
  const ANGLE_RANGE = MAX_ANGLE - MIN_ANGLE;

  // 1. Draw Meter Track (The background arc)
  ctx.save();
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 15;
  ctx.beginPath();
  ctx.arc(DASH_CENTER_X, DASH_CENTER_Y, METER_RADIUS, MIN_ANGLE, MAX_ANGLE, false);
  ctx.stroke();

  // 2. Draw Velocity Ticks and Labels
  ctx.font = '12px Arial';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';

  for (let i = 0; i <= MAX_VELOCITY; i += 10) {
      const angle = MIN_ANGLE + (i / MAX_VELOCITY) * ANGLE_RANGE;
      const x = DASH_CENTER_X + METER_RADIUS * Math.cos(angle);
      const y = DASH_CENTER_Y + METER_RADIUS * Math.sin(angle);
      
      // Draw the label
      ctx.fillText(i, x, y + 5); 

      // Draw a small tick mark
      const tickOuterX = DASH_CENTER_X + (METER_RADIUS - 10) * Math.cos(angle);
      const tickOuterY = DASH_CENTER_Y + (METER_RADIUS - 10) * Math.sin(angle);
      
      ctx.beginPath();
      ctx.moveTo(tickOuterX, tickOuterY);
      ctx.lineTo(x, y);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();
  }

  // 3. Draw Needle
  ctx.save();


// Local variable for drawing speed
const velx = vx * 2; // Use the global velocity variable

// --- VELOCITY METER CONSTANTS ---
const LINE_WIDTH = 15; // Width of the meter track

// --- 1. Draw Static Meter Track (Full Arc) ---
ctx.save();
ctx.lineWidth = LINE_WIDTH;

// Create the color gradient that spans the entire arc
const gradient = ctx.createLinearGradient(
    DASH_CENTER_X - METER_RADIUS, DASH_CENTER_Y,
    DASH_CENTER_X + METER_RADIUS, DASH_CENTER_Y
);

// Map the color stops from green (MIN) to red (MAX)
gradient.addColorStop(0.0, '#00FF00');     // Start (Green - Slow/Safe)
gradient.addColorStop(0.5, '#FFFF00');     // Mid-point (Yellow - Medium)
gradient.addColorStop(1.0, '#FF0000');     // End (Red - Fast/Warning)

// Draw the full, color-graded background track
ctx.strokeStyle = gradient;
ctx.beginPath();
ctx.arc(DASH_CENTER_X, DASH_CENTER_Y, METER_RADIUS, MIN_ANGLE, MAX_ANGLE, false);
ctx.stroke();


for (let i = 0; i <= MAX_VELOCITY; i += 10) {
    const angle = MIN_ANGLE + (i / MAX_VELOCITY) * ANGLE_RANGE;
    const x = DASH_CENTER_X + METER_RADIUS * Math.cos(angle);
    const y = DASH_CENTER_Y + METER_RADIUS * Math.sin(angle);
    
    // Draw the label
    ctx.fillText(i, x, y + 5); 
    ctx.strokeStyle = '#000000'; // Set border color to black
    ctx.lineWidth = 3;           // Set border thickness
    ctx.strokeText(i, x, y + 5); // Draw the black outline first
    
    // Draw a small tick mark
    const tickOuterX = DASH_CENTER_X + (METER_RADIUS - 10) * Math.cos(angle);
    const tickOuterY = DASH_CENTER_Y + (METER_RADIUS - 10) * Math.sin(angle);
    
    ctx.beginPath();
    ctx.moveTo(tickOuterX, tickOuterY);
    ctx.lineTo(x, y);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();
        
    // Draw the label
    ctx.fillText(i, x, y + 5); 
    ctx.strokeStyle = '#000000'; // Set border color to black
    ctx.lineWidth = 3;           // Set border thickness
    ctx.strokeText(i, x, y + 5); // Draw the black outline first
        
    // Draw the label (fill)
    ctx.fillStyle = '#fff';      // Set fill color to white
    ctx.fillText(i, x, y + 5); 

}

// --- 3. Draw Cover Arc (Grey Out the Unused Portion) ---
// This technique draws the full color track first, and then overlays a dark grey arc
// from the current speed up to the maximum, effectively "filling" the meter.

const currentVel = Math.min(Math.max(velx, 0), MAX_VELOCITY);
const velocityRatio = currentVel / MAX_VELOCITY;
const currentAngle = MIN_ANGLE + (velocityRatio * ANGLE_RANGE);

// Draw a dark grey arc from the current speed up to the max speed
ctx.strokeStyle = '#404040'; // Dark grey to cover the unused part
ctx.lineWidth = LINE_WIDTH;
ctx.beginPath();
ctx.arc(DASH_CENTER_X, DASH_CENTER_Y, METER_RADIUS, currentAngle, MAX_ANGLE, false);
ctx.stroke();

ctx.restore(); // Restore context

// --- 4. Display Current Speed Text (Kept for clarity) ---
ctx.font = '24px Arial';
ctx.fillStyle = '#FFD700';
ctx.textAlign = 'center';
ctx.fillText(`${Math.round(currentVel)}`, DASH_CENTER_X, DASH_CENTER_Y - 20);
// These rely on global variables: isLeftSignalOn, isRightSignalOn, isHazardOn
const interactiveLights = [
  { active: isLeftSignalOn || isHazardOn, glowColor: 'rgba(0, 255, 0, 0.7)', baseColor: '#00FF00', type: 'LEFT_SIGNAL' },
  { active: isHazardOn, glowColor: 'rgba(255, 255, 0, 0.7)', baseColor: '#FFFF00', type: 'HAZARD' },
  { active: isRightSignalOn || isHazardOn, glowColor: 'rgba(0, 255, 0, 0.7)', baseColor: '#00FF00', type: 'RIGHT_SIGNAL' }
];
const coreLights = [
  { active: distance < 1000, glowColor: 'rgba(100, 150, 255, 0.7)', baseColor: '#337BFF' },
  { active: pendingDropRequest, glowColor: 'rgba(255, 165, 0, 0.8)', baseColor: '#FFA500' },
  { active: braking, glowColor: 'rgba(163, 217, 165, 0.8)', baseColor: '#A3D9A5' },
  { active: vx === 0, glowColor: 'rgba(221, 0, 0, 0.7)', baseColor: '#DD0000' }
];

// 1. Draw Core Status Lights (Top Row)
const CORE_LIGHT_Y = DASH_CENTER_Y - DASH_RADIUS + 70;
let coreX = DASH_CENTER_X - ((coreLights.length * LIGHT_SIZE) + ((coreLights.length - 1) * LIGHT_PADDING)) / 2;

coreLights.forEach((light) => {
    drawSquareIndicator(coreX, CORE_LIGHT_Y, light, isFlashing);
    coreX += LIGHT_SIZE + LIGHT_PADDING;
});

// 2. Draw Interactive Signal Lights (Bottom Row)
const INTERACTIVE_LIGHT_Y = CORE_LIGHT_Y + LIGHT_SIZE + LIGHT_PADDING * 1.5;
let interactiveX = DASH_CENTER_X - ((interactiveLights.length * LIGHT_SIZE) + ((interactiveLights.length - 1) * LIGHT_PADDING)) / 2;

interactiveLights.forEach((light) => {
    const x = interactiveX;
    const y = INTERACTIVE_LIGHT_Y;

    drawSquareIndicator(x, y, light, isFlashing);
    
    // CRUCIAL: UPDATE COORDINATES FOR CLICK HANDLER (Needed for canvas.onclick)
    const lightCenterY = y + LIGHT_SIZE / 2;
    const lightCenterX = x + LIGHT_SIZE / 2;
    
    if (light.type === 'LEFT_SIGNAL') { LEFT_SIGNAL_CENTER.x = lightCenterX; LEFT_SIGNAL_CENTER.y = lightCenterY; }
    if (light.type === 'HAZARD') { HAZARD_CENTER.x = lightCenterX; HAZARD_CENTER.y = lightCenterY; }
    if (light.type === 'RIGHT_SIGNAL') { RIGHT_SIGNAL_CENTER.x = lightCenterX; RIGHT_SIGNAL_CENTER.y = lightCenterY; }

    interactiveX += LIGHT_SIZE + LIGHT_PADDING;
});

ctx.font = '14px Arial';

  const now = performance.now();
  const deltaTime = now - lastDrawTime;
  
  lastDrawTime = now;
  drawTrainTrafficLights(ctx, camX, canvas.width);
  updateTrafficLights(deltaTime)
  updateTrainTrafficLights(deltaTime);
  drawTracks(ctx);
  xB = bus.x

  checkTrafficLightViolations(bus);
  drawTrafficLights(ctx, camX);  
// Call this every frame, passing deltaTime in milliseconds

// --- Draw Stops ---
for (const stop of stops) {
  if (!stop.collected) {
    const screenX = stop.x - camX;
    const stopY = window.innerHeight * 0.5;

    // Outer glow (different for special stops)
    ctx.beginPath();
    ctx.arc(screenX, stopY, STOP_RADIUS + 10, 0, Math.PI * 2);
    ctx.fillStyle = stop.special
      ? 'rgba(128, 128, 128, 0.4)'
      : 'rgba(100, 150, 255, 0.3)';
    ctx.fill();

    // Inner circle
    ctx.beginPath();
    ctx.arc(screenX, stopY, STOP_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = stop.special ? '#888' : '#337BFF';
    ctx.fill();
  }
}
for (const stop of stops) {
  if (!stop.collected && vx === 0 && Math.abs(bus.x - stop.x) < 500 && frontOpen) {
    
    // Special stop check
    if (stop.special && !driverLocked) continue;

    stop.collected = true;

    // Passenger logic
    const newPassengers = Math.floor(Math.random() * 2 + 2); // 2–3
    const dropOff = Math.floor(Math.random() * 2 + 2);       // 2–3
    const basePoints = newPassengers;
    const multiplier = stop.special ? 3 : 1;
    const actualPoints = basePoints * multiplier;
      points += actualPoints;
    if (passengersOnBoard < 16) {
      passengersOnBoard += newPassengers;
    } else {
      passengersOnBoard -= 6;
    }
      savePoints();
    if (passengersOnBoard >= 4) {
      passengersOnBoard = Math.max(passengersOnBoard - dropOff, 0);
      points = dropOff * 3 + points
    }

    // Clear drop request
    if (nextStopRequest && stop.x >= bus.x) {
      pendingDropRequest = false;
      nextStopRequest = null;
    }
ctx.fillText(`Passengers: ${newPassengers}`, 10, canvas.height - 35);
ctx.fillText(`Stop Requested: ${pendingDropRequest ? "Yes" : "No"}`, 10, canvas.height - 20);

    // Save stop event to history
    saveStopHistoryEntry({
      x: (distance2) * 2,
      time: Date.now(),
      special: stop.special,
      passengersAdded: newPassengers,
      passengersDropped: dropOff,
      pointsGained: actualPoints
    });

    break;
  }
}
const stopNoticeDiv = document.getElementById('stopNotice');

for (const stop of stops) {
  if (!stop.collected && stop.x > bus.x) {
    distance = Math.floor((stop.x - bus.x) / 2);

    break;
  }
}



// --- Request Drop at Future Stop ---
if (passengersOnBoard > 0 && !pendingDropRequest) {
  pendingDropRequest = true;
  nextStopRequest = stops.find(stop => stop.x > bus.x && !stop.collected);
}

// --- Highlight Requested Stop ---
if (pendingDropRequest && nextStopRequest) {
  const screenX = nextStopRequest.x - camX;
  ctx.beginPath();
  ctx.arc(screenX, window.innerHeight * 0.5, STOP_RADIUS + 10, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 220, 0, 0.6)';
  ctx.fill();
}

if (flashAlpha > 0) {
  ctx.save();
  ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  flashAlpha -= 0.1; // Decrease transparency
  if (flashAlpha < 0) flashAlpha = 0;
}

drawTrains(ctx);
  if (night && !spotlightOn) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.99)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
if (spotlightOn) {
  // Dark overlay over whole canvas (more opaque)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';  // dark shadow over everything
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Create a linear gradient for the spotlight light cone
  const busScreenX = bus.x - camX + canvas.width / 2 + 50; 
  const busScreenY = 430

  const coneLength = 500;
  const coneBaseWidth = 1200;
  const coneTipWidth = 10;

  // Create gradient along the cone's axis
  let gradient = ctx.createLinearGradient(busScreenX, busScreenY, busScreenX + coneLength, busScreenY);

  // Gradient stops - from almost transparent light to full shadow
  gradient.addColorStop(0, 'rgba(0,0,0,0)');    // fully transparent at the tip of bus
  gradient.addColorStop(0.2, 'rgba(127,127,127,0.1)');
  gradient.addColorStop(0.6, 'rgba(255,255,255,0.1)');
  gradient.addColorStop(1, 'rgba(127,127,127,0.1)');

  // Save current context and clip to cone shape
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(busScreenX, busScreenY - coneTipWidth / 2);
  ctx.lineTo(busScreenX + coneLength, busScreenY - coneBaseWidth / 2);
  ctx.lineTo(busScreenX + coneLength, busScreenY + coneBaseWidth / 2);
  ctx.lineTo(busScreenX, busScreenY + coneTipWidth / 2);
  ctx.closePath();

  ctx.clip();

  // Draw the gradient inside the cone shape
  ctx.fillStyle = gradient;
  ctx.fillRect(busScreenX, busScreenY - coneBaseWidth / 2, coneLength, coneBaseWidth);

  ctx.restore();

}
  drawTrafficLights(ctx, camX);  
  if (debugMode) {
  ctx.strokeStyle = 'lime';
  ctx.strokeRect(bus.x - camX, bus.y, bus.width, bus.height);
}
if (debugMode) {
  ctx.fillStyle = 'white';
  ctx.font = '14px monospace';
  ctx.fillText(`Bus X: ${bus.x.toFixed(0)}`, 10, 20);
  ctx.fillText(`Cam X: ${camX.toFixed(0)}`, 10, 40);
}
if (debugMode) {
  stops.forEach(stop => {
    ctx.fillStyle = stop.special ? 'yellow' : 'orange';
    ctx.fillRect(stop.x - camX, canvas.height - 110, 10, 10);
  });
}
  if (!debugMode) return;
  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  for (let x = -camX % 100; x < canvas.width; x += 100) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  if (debugMode) {
  const nextStop = stops.find(s => s.x > bus.x && !s.collected);
  if (nextStop) {
    ctx.fillStyle = '#ff0';
    ctx.fillText('Next Stop →', nextStop.x - camX, bus.y - 50);
  }
}

  trackSpeed()
  drawSpeedGraph()
  let frameTimeColor = 'green';
if (deltaTime > 33) frameTimeColor = 'red';
else if (deltaTime > 16) frameTimeColor = 'yellow';

ctx.fillStyle = frameTimeColor;
ctx.fillRect(canvas.width - 60, 0, 50, 10);
ctx.fillStyle = '#fff';
ctx.font = '10px monospace';
ctx.fillText(`${Math.round(deltaTime)}ms`, canvas.width - 55, 0);
}
let speedHistory = [];
function trackSpeed() {
  speedHistory.push(vx);
  if (speedHistory.length > 100) speedHistory.shift();
}
function drawSpeedGraph() {
  if (!debugMode || speedHistory.length < 2) return;

  const graphWidth = 200;
  const graphHeight = 100;
  const graphX = canvas.width - graphWidth - 10;
  const graphY = canvas.height - graphHeight - 10;

  // Draw background box
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(graphX, graphY, graphWidth, graphHeight);

  // Draw border
  ctx.strokeStyle = '#00ffff';
  ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);

  // Draw graph line
  ctx.beginPath();
  ctx.strokeStyle = '#00ffff';
  for (let i = 0; i < speedHistory.length; i++) {
    const x = graphX + (i / speedHistory.length) * graphWidth;
    const y = graphY + graphHeight - (speedHistory[i] * 3); // Scale speed visually
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Draw labels
  ctx.fillStyle = '#ffffff';
  ctx.font = '10px monospace';
  ctx.fillText('Speed', graphX + 5, graphY + 10);
  ctx.fillText(`vx: ${vx.toFixed(2)}`, graphX + 5, graphY + graphHeight - 3);
}


drawBus()
  // Listen for keys to switch bus
  window.addEventListener('keydown', e => {
    if (e.key === '1') {
      currentBusIndex = 0;
      info.textContent = "Current: Gillig 29'";
      currentSystem === "A"
      acceleration = 0.011
      drawBus();
    } else if (e.key === '2') {
      currentBusIndex = 1;
      info.textContent = "Current: Gillig 40 HEV'";
      currentSystem === "C"
      acceleration = 0.1
      drawBus();
    } else if (e.key === '3') {
      currentBusIndex = 2;
      info.textContent = "Current: New Flyer Xcelsior 40'";
      currentSystem === "B"
      acceleration = 0.011
      drawBus();
    }
  });
  
  let highFriction = false;
function drawBackDoors(bus) {
  if (!bus.backDoorPositions) return;

  bus.backDoorPositions.forEach(doorX => {
    const x = bus.x - camX + doorX;
    const y = bus.y + 40;
    const doorW = bus.doorSize.width;
    const doorH = bus.doorSize.height;

    // Top Half: Black gradient
    const topHeight = doorH / 1.5;
    const topGradient = ctx.createLinearGradient(0, y, 0, y + topHeight);
    topGradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
    topGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
    ctx.fillStyle = topGradient;
    ctx.fillRect(x, y, doorW, topHeight);

    // Bottom Half: Darker than bus body
    const busGradient = ctx.createLinearGradient(
      bus.x - camX,
      bus.y + bus.height,
      bus.x - camX + bus.width,
      bus.y
    );

    for (const stop of gradientStops) {
      busGradient.addColorStop(stop.offset, stop.color);
    }

    ctx.fillStyle = busGradient;
    ctx.fillRect(x, y + topHeight, doorW, doorH / 3);
  });


}// ==== GLOBALS ====

let lastTimestamp = performance.now();



// Signal signs globals

// ==== FUNCTIONS ====

// Traffic Lights Generation and Update (unchanged from before)

function drawTrafficLights(ctx, camX, canvasWidth) {
  const y = 520;

  trafficLights.forEach(light => {
    const x = light.x - camX;
    if (x < -100 || x > canvasWidth + 100) return;

    const color = lightColors[light.state] || "#00ff00";

    ctx.beginPath();
    ctx.arc(x, y, lightRadius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  });
}

// Signal signs generation and cleanup
function updateSignalSigns(bus, canvasWidth) {
  const busX = bus.x;

  // Remove signs far behind the bus
  for (let i = signalSigns.length - 1; i >= 0; i--) {
    if (signalSigns[i].x < busX - 300) {
      signalSigns.splice(i, 1);
    }
  }

  // Add new signs ahead if fewer than maxSigns
  while (signalSigns.length < maxSigns) {
    let nextLight = null;
    for (let light of trafficLights) {
      if (light.x > busX + 100) {
        const hasSign = signalSigns.some(sign => 
          Math.abs(sign.x - (light.x - 100)) < 10 || 
          Math.abs(sign.x - (light.x - 2000)) < 10
        );
        if (!hasSign) {
          nextLight = light;
          break;
        }
      }
    }
    if (!nextLight) break;

    const possibleOffsets = [500, 1000].filter(offset => 
      !signalSigns.some(sign => Math.abs(sign.x - (nextLight.x - offset)) < 10)
    );
    if (possibleOffsets.length === 0) break;

    const offset = possibleOffsets[Math.floor(Math.random() * possibleOffsets.length)];
    const signX = nextLight.x - offset;

    if (signX > busX - 1000) {
      signalSigns.push({ x: signX, distance: offset });
    } else {
      break;
    }
  }
}

// Draw signal signs on canvas
function drawSignalSigns(ctx, camX, canvasWidth) {
  const boxColor = "#1abf00";
  const textColor = "#fff";
  const boxWidth = 110;
  const boxHeight = 30;

  signalSigns.forEach(sign => {
    const x = sign.x - camX;
    const y = 150;

    if (x < -100 || x > canvasWidth + 100) return;


    // Sign box
    ctx.fillStyle = boxColor;
    ctx.fillRect(x - boxWidth / 2, y - boxHeight, boxWidth, boxHeight);

    // Text
    ctx.fillStyle = textColor;
    ctx.font = "bold 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("NEXT SIGNAL", x, y - boxHeight + 12);
    ctx.fillText(`${sign.distance}px`, x, y - boxHeight + 25);
  });
}
function showStopHistory() {
  const history = JSON.parse(localStorage.getItem("stopHistory") || "[]");
  const display = document.getElementById("stopHistoryDisplay");

  if (!history.length) {
    display.innerHTML = "<div class='entry empty'>No stop history yet.</div>";
    return;
  }

  display.innerHTML = history.map((entry, index) => {
    const date = new Date(entry.time).toLocaleString();
    return `
      <div class="entry">
        <div class="entry-header">#${index + 1} • ${entry.special ? "Kneeling" : "Standard"}</div>
        <div class="entry-body">
          <div><strong>Time:</strong> ${date}</div>
          <div><strong>Stop Position:</strong> ${entry.x}px</div>
          <div><strong>Passengers:</strong> +${entry.passengersAdded}, -${entry.passengersDropped}</div>
          <div><strong>Points:</strong> +${entry.pointsGained}</div>
        </div>
      </div>
    `;
  }).join('');
}

function checkTrafficLightViolations(bus) {
  for (let light of trafficLights) {
    if (light.state === 2) { // Red light
      const dx = bus.x - light.x;

      if (Math.abs(dx) < 100 && bus.vx > 0.1 && !light.violated) {
        points -= 10;
savePoints()
        console.log("Violation! -10 Points. Points now:", points);
        light.violated = true;

        // Trigger flash
        flashAlpha = 1;
        flashTimer = 10; // Frames to fade out
      }

      if (Math.abs(dx) > 200) {
        light.violated = false;
      }
    }
  }
}

function updateViolationMessage(deltaTime) {
  if (violationMessageTimer > 0) {
    violationMessageTimer -= deltaTime;
    if (violationMessageTimer < 0) violationMessageTimer = 0;
  }
}

function drawViolationMessage(ctx) {
  if (violationMessageTimer > 0) {
    ctx.fillStyle = "red";
    ctx.font = "bold 24px Arial";
    ctx.fillText("TRAFFIC VIOLATION!", 300, 50);
  }
}
let key8Pressed = false;
let key9Pressed = false;
window.addEventListener('keydown', (e) => {
  if (e.key === '8') key8Pressed = true;
  if (e.key === '9') key9Pressed = true;
});

window.addEventListener('keyup', (e) => {
  if (e.key === '8') key8Pressed = false;
  if (e.key === '9') key9Pressed = false;
});
let blockedByCar = false;

function checkBusBlockedByCars() {
  blockedByCar = false;

  for (const car of aiCars) {
    const dx = car.x - bus.x;
    const dy = car.y - bus.y;

    if (car.stuck && dx > 0 && dx < 100 && Math.abs(dy) < 10) {
      blockedByCar = true;
      break;
    }
  }
}

    // --- KEYBOARD HANDLER (R, T, Y for controls) ---
    window.onkeydown = (e) => {
        if (e.repeat) return; 
        
        const key = e.key.toUpperCase();

        if (key === 'Y') { // Left Signal
            if (isHazardOn) {
                isHazardOn = false;
                isLeftSignalOn = true;
                isRightSignalOn = false;
            } else if (isLeftSignalOn) {
                isLeftSignalOn = false;
            } else {
                isLeftSignalOn = true;
                isRightSignalOn = false;
            }
        } else if (key === 'R') { // Right Signal
            if (isHazardOn) {
                isHazardOn = false;
                isRightSignalOn = true;
                isLeftSignalOn = false;
            } else if (isRightSignalOn) {
                isRightSignalOn = false;
            } else {
                isRightSignalOn = true;
                isLeftSignalOn = false;
            }
        } else if (key === 'T') { // Hazard
            isHazardOn = !isHazardOn;
            if (isHazardOn) {
                isLeftSignalOn = false;
                isRightSignalOn = false;
            }
        }
    };
    
    // --- CLICK HANDLER (For interacting with the dashboard directly) ---
    canvas.onclick = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        const checkClickArea = (center) => {
            const dx = clickX - center.x;
            const dy = clickY - center.y;
            return (dx * dx + dy * dy) < ((radius + 5) * (radius + 5)); 
        };

        // Reuse key logic for clicks
        if (checkClickArea(LEFT_SIGNAL_CENTER)) {
            window.onkeydown({ key: 'Y', repeat: false });
        } else if (checkClickArea(RIGHT_SIGNAL_CENTER)) {
            window.onkeydown({ key: 'R', repeat: false });
        } else if (checkClickArea(HAZARD_CENTER)) {
            window.onkeydown({ key: 'T', repeat: false });
        }
    };
let t = true
function animate(timestamp) {
          // 1. BLINKING UPDATE: Toggles the global flasher every 400ms
      isFlashing = (timestamp % 600) < 200;

  if (!lastTimestamp) lastTimestamp = timestamp; // initialize first frame
  const deltaTime = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  const bus = buses[currentBusIndex];

    // -------------------------------------------------
    updateFuel(deltaTime, vx);
    // -------------------------------------------------


    // --- Before updating velocity or calling sound functions: ---
    if (fuelDepleted) {
      // Freeze movement and sound updates if out of fuel
      vx = 0; // Stop the bus
    }
    // --- End Fuel Depleted Check ---


  if (!driverLocked) {
    if (accelerating) {
      vx += acceleration;
      if (vx > maxSpeed) vx = maxSpeed;
    } else {
      if (vx < 0.1) {
        vx = 0;
        braking = false;
        if (currentBusIndex === 1) {
          acceleration = 0.1;
        } else if (currentBusIndex === 2) {
          acceleration = 0.004
        } else {
          acceleration = 0.07;
        }
      }
      if (braking) {
        vx *= 0.981233;
      } else {
        vx *= 0.9999;
      }
    }
  } else {
    vx = 0;
  }
  if (vx > maxSpeed) vx = maxSpeed;
if (t) {

// === Assign player offset ===
scheduleOffsets.set(bus, 0);
t = false
}
  bus.vx = vx;
  if (!blockedByCar) {
    bus.x += bus.vx;
  }
  bus.wheelAngle += bus.vx / 22.5;

  if (freeCam) {
    if (key8Pressed) freeCamX -= 10; // Move left
    if (key9Pressed) freeCamX += 10; // Move right
    camX = freeCamX;
  } else {
    if (Math.abs(camFollowX - bus.x) > 20) {
      camX = bus.x - 20;
      camFollowX = bus.x;
      delayTimer = 0;
    } else {
      delayTimer++;
      if (delayTimer > 20) {
        camFollowX = bus.x;
        camX += (camFollowX - camX) * 0.10;
      }
    }
  }

  checkTrainSpawn(bus);

  const trainApproaching = trains.some(train =>
    trainTracks.some(track =>
      Math.abs(train.worldX - track.x) < 100
    )
  );
    if (frontOpen) {
    accelerating = false
    vx = 0}
  generateTrainTrafficLights(bus.x);
  updateTrainTrafficLights(deltaTime);

  generateTracksUpTo(bus.x + 100000); // Generate tracks 100k ahead of bus
  checkTrainSpawn(bus);
  updateAICars(bus);
  updateTrainTrafficLights(deltaTime);
  busPath.push({ x: bus.x, y: bus.y });
  updateLatenessUI(bus);
  generateTrafficLights(bus.x);
  updateTrafficLights(deltaTime);
  updateSignalSigns(bus, ctx.canvas.width);
  drawMinimap(bus, camX);
  updateAIBuses(deltaTime, bus);

  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  // Remove or comment out if playerBus is const
  // playerBus = bus;

  updateLatenessUI(bus);
  if (stop.collected) {
  stop.regenTime = performance.now() + STOP_REGEN_MIN + Math.random() * (STOP_REGEN_MAX - STOP_REGEN_MIN);
    updateStops(deltaTime);
  }
  drawBus();
  drawTrafficLights(ctx, camX, ctx.canvas.width);
  drawSignalSigns(ctx, camX, ctx.canvas.width);

  checkTrafficLightViolations(bus);
  updateViolationMessage(deltaTime);
  drawViolationMessage(ctx);

  if (braking) {
    accelerating = false;
  }

  document.getElementById("pointsDisplay").innerText = "Points: " + points;

  requestAnimationFrame(animate);
}

  // Initial bits, default to 0s
  let bits = Array(8).fill(0);

  // Focused bit index (for arrows)
  let focusedIndex = 0;

  const bitDisplay = document.getElementById("bitDisplay");
  const statusEl = document.getElementById("status");

  // Command map as before
  const binaryCommandMap = {
    "01101101": () => articulated = !articulated,
  };

  // Render bits visually
  function renderBits() {
    bitDisplay.innerHTML = "";
    bits.forEach((bit, i) => {
      const span = document.createElement("span");
      span.textContent = bit;
      span.style.cursor = "pointer";
      span.style.padding = "5px 10px";
      span.style.border = "2px solid";
      span.style.borderColor = (i === focusedIndex) ? "yellow" : "white";
      span.style.borderRadius = "4px";
      span.style.userSelect = "none";
      span.style.fontWeight = "bold";
      span.style.fontSize = "1.5em";
      span.style.backgroundColor = bit ? "#0a7" : "#333";
      span.style.color = bit ? "black" : "white";

      // Toggle bit on click
      span.addEventListener("click", () => {
        bits[i] = bits[i] === 0 ? 1 : 0;
        renderBits();
      });

      bitDisplay.appendChild(span);
    });
  }

  // Arrow button handlers
  document.getElementById("leftArrow").addEventListener("click", () => {
    focusedIndex = (focusedIndex - 1 + bits.length) % bits.length;
    renderBits();
  });

  document.getElementById("rightArrow").addEventListener("click", () => {
    focusedIndex = (focusedIndex + 1) % bits.length;
    renderBits();
  });

  // Execute button handler
  document.getElementById("executeBtn").addEventListener("click", () => {
    const binaryStr = bits.join("");
    const command = binaryCommandMap[binaryStr];
    if (command) {
      command();
      alert(`Command for ${binaryStr} executed!`);
    } else {
      alert(`No command found for ${binaryStr}`);
    }
  });

  // Initial render and status
  renderBits();

  const routeInput = document.getElementById("routeNumber");
  const translationCheck = document.getElementById("translationCheck");
  const rSlider = document.getElementById("rSlider");
  const gSlider = document.getElementById("gSlider");
  const bSlider = document.getElementById("bSlider");
  const routePreview = document.getElementById("routePreview");
  const translationText = document.getElementById("translationText");

  const panel = document.getElementById("busRoutePanel");
  const toggleBtn = document.getElementById("busRoutePanelToggle");

  // Toggle panel visibility
  toggleBtn.addEventListener("click", () => {
    if (panel.hasAttribute("hidden")) {
      panel.removeAttribute("hidden");
      toggleBtn.textContent = "▼ Route Editor";
      toggleBtn.setAttribute("aria-expanded", "true");
    } else {
      panel.setAttribute("hidden", "");
      toggleBtn.textContent = "► Route Editor";
      toggleBtn.setAttribute("aria-expanded", "false");
    }
  });

  // Convert number 101-126 to letters A-Z
  function translateNumberToLetter(num) {
    if (num < 101 || num > 126) return null;
    return String.fromCharCode(65 + (num - 101)); // 65 = 'A'
  }

  function updateDisplay() {
    let val = routeInput.value.replace(/\D/g, ""); // digits only
    if (val.length === 0) {
      routePreview.textContent = "---";
      translationText.textContent = "";
      return;
    }
    let num = Math.min(Math.max(parseInt(val, 10), 0), 999);
    routeInput.value = num.toString();

    if (translationCheck.checked) {
      let letter = translateNumberToLetter(num);
      if (letter) {
        routePreview.textContent = letter;
        translationText.textContent = `Translated from ${num}`;
      } else {
        routePreview.textContent = num;
        translationText.textContent = "";
      }
    } else {
      routePreview.textContent = num;
      translationText.textContent = "";
    }

    // Update preview color
    routePreview.style.color = `rgb(${rSlider.value},${gSlider.value},${bSlider.value})`;
  }

  // Update on all input changes
  routeInput.addEventListener("input", updateDisplay);
  translationCheck.addEventListener("change", updateDisplay);
  rSlider.addEventListener("input", updateDisplay);
  gSlider.addEventListener("input", updateDisplay);
  bSlider.addEventListener("input", updateDisplay);

  // Initial display update
  updateDisplay();
animate();
</script>
